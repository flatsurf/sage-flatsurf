
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>flatsurf.geometry.similarity_surface &#8212; sage-flatsurf 0.4.7 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/classic.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">sage-flatsurf 0.4.7 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">flatsurf.geometry.similarity_surface</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for flatsurf.geometry.similarity_surface</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Similarity surfaces.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1">#*********************************************************************</span>
<span class="c1">#  This file is part of sage-flatsurf.</span>
<span class="c1">#</span>
<span class="c1">#        Copyright (C) 2016-2020 Vincent Delecroix</span>
<span class="c1">#                      2020-2022 Julian RÃ¼th</span>
<span class="c1">#</span>
<span class="c1">#  sage-flatsurf is free software: you can redistribute it and/or modify</span>
<span class="c1">#  it under the terms of the GNU General Public License as published by</span>
<span class="c1">#  the Free Software Foundation, either version 2 of the License, or</span>
<span class="c1">#  (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1">#  sage-flatsurf is distributed in the hope that it will be useful,</span>
<span class="c1">#  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1">#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1">#  GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1">#  You should have received a copy of the GNU General Public License</span>
<span class="c1">#  along with sage-flatsurf. If not, see &lt;https://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#*********************************************************************</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="kn">import</span> <span class="nb">range</span>
<span class="kn">from</span> <span class="nn">six</span> <span class="kn">import</span> <span class="n">iteritems</span>

<span class="kn">from</span> <span class="nn">sage.misc.cachefunc</span> <span class="kn">import</span> <span class="n">cached_method</span>
<span class="kn">from</span> <span class="nn">sage.misc.sage_unittest</span> <span class="kn">import</span> <span class="n">TestSuite</span>

<span class="kn">from</span> <span class="nn">sage.structure.sage_object</span> <span class="kn">import</span> <span class="n">SageObject</span>

<span class="kn">from</span> <span class="nn">sage.rings.infinity</span> <span class="kn">import</span> <span class="n">Infinity</span>

<span class="kn">from</span> <span class="nn">sage.rings.all</span> <span class="kn">import</span> <span class="n">ZZ</span><span class="p">,</span> <span class="n">QQ</span><span class="p">,</span> <span class="n">AA</span><span class="p">,</span> <span class="n">NumberField</span>

<span class="kn">from</span> <span class="nn">sage.modules.free_module_element</span> <span class="kn">import</span> <span class="n">vector</span>

<span class="kn">from</span> <span class="nn">.similarity</span> <span class="kn">import</span> <span class="n">SimilarityGroup</span>
<span class="kn">from</span> <span class="nn">.polygon</span> <span class="kn">import</span> <span class="n">ConvexPolygons</span><span class="p">,</span> <span class="n">wedge_product</span>

<span class="kn">from</span> <span class="nn">.surface</span> <span class="kn">import</span> <span class="n">Surface</span><span class="p">,</span> <span class="n">Surface_dict</span><span class="p">,</span> <span class="n">Surface_list</span><span class="p">,</span> <span class="n">LabelComparator</span>
<span class="kn">from</span> <span class="nn">.surface_objects</span> <span class="kn">import</span> <span class="n">Singularity</span><span class="p">,</span> <span class="n">SaddleConnection</span><span class="p">,</span> <span class="n">SurfacePoint</span>
<span class="kn">from</span> <span class="nn">.circle</span> <span class="kn">import</span> <span class="n">Circle</span>
<span class="kn">from</span> <span class="nn">.matrix_2x2</span> <span class="kn">import</span> <span class="n">similarity_from_vectors</span>

<span class="n">ZZ_1</span> <span class="o">=</span> <span class="n">ZZ</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
<span class="n">ZZ_2</span> <span class="o">=</span> <span class="n">ZZ_1</span> <span class="o">+</span> <span class="n">ZZ_1</span>


<div class="viewcode-block" id="SimilaritySurface"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface">[docs]</a><span class="k">class</span> <span class="nc">SimilaritySurface</span><span class="p">(</span><span class="n">SageObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An oriented surface built from a set of polygons and edges identified with</span>
<span class="sd">    similarities (i.e. composition of homothety, rotations and translations).</span>

<span class="sd">    Each polygon is identified with a unique key (its label). The choice of the</span>
<span class="sd">    label of the polygons is done at startup. If the set is finite then by</span>
<span class="sd">    default the labels are the first non-negative integers 0,1,...</span>

<span class="sd">    The edges are labeled by a pair ``(polygon label, edge number)``.</span>

<span class="sd">    EXAMPLES:</span>

<span class="sd">    The easiest way to construct a similarity surface is to use the pre-built</span>
<span class="sd">    constructions from</span>
<span class="sd">    :class:`flatsurf.geometry.similarity_surface_generators.SimilaritySurfaceGenerators`::</span>

<span class="sd">        sage: from flatsurf import polygons, similarity_surfaces</span>
<span class="sd">        sage: P = polygons(vertices=[(0,0), (2,0), (1,4), (0,5)])</span>
<span class="sd">        sage: similarity_surfaces.self_glued_polygon(P)</span>
<span class="sd">        HalfTranslationSurface built from 1 polygon</span>

<span class="sd">    The second way is to build a surface (using e.g. :class:`flatsurf.geometry.surface.Surface_list`)</span>
<span class="sd">    and then use this surface as an argument for class:`SimilaritySurface`)::</span>

<span class="sd">        sage: from flatsurf.geometry.similarity_surface import SimilaritySurface</span>
<span class="sd">        sage: from flatsurf.geometry.surface import Surface_list</span>
<span class="sd">        sage: P = polygons(vertices=[(0,0), (1,0), (1,1), (0,1)])</span>
<span class="sd">        sage: Stop = Surface_list(QQ)</span>
<span class="sd">        sage: Stop.add_polygon(P)</span>
<span class="sd">        0</span>
<span class="sd">        sage: Stop.add_polygon(2*P)</span>
<span class="sd">        1</span>
<span class="sd">        sage: Stop.add_polygon(3*P)</span>
<span class="sd">        2</span>
<span class="sd">        sage: Stop.set_edge_pairing(0, 1, 1, 3)</span>
<span class="sd">        sage: Stop.set_edge_pairing(0, 0, 2, 2)</span>
<span class="sd">        sage: Stop.set_edge_pairing(0, 2, 2, 0)</span>
<span class="sd">        sage: Stop.set_edge_pairing(0, 3, 1, 1)</span>
<span class="sd">        sage: Stop.set_edge_pairing(1, 2, 2, 1)</span>
<span class="sd">        sage: Stop.set_edge_pairing(1, 0, 2, 3)</span>
<span class="sd">        sage: S = SimilaritySurface(Stop)</span>
<span class="sd">        sage: S</span>
<span class="sd">        SimilaritySurface built from 3 polygons</span>

<span class="sd">    To perform a sanity check on the obtained surface, you can run its test</span>
<span class="sd">    suite::</span>

<span class="sd">        sage: TestSuite(S).run()</span>

<span class="sd">    In the following example, we build two broken surfaces and</span>
<span class="sd">    check that the test suite fails as expected::</span>

<span class="sd">        sage: P = polygons(vertices=[(0,0), (1,0), (1,1), (0,1)])</span>
<span class="sd">        sage: Stop = Surface_list(QQ)</span>
<span class="sd">        sage: Stop.add_polygon(P)</span>
<span class="sd">        0</span>
<span class="sd">        sage: S = SimilaritySurface(Stop)</span>
<span class="sd">        sage: TestSuite(S).run()</span>
<span class="sd">        ...</span>
<span class="sd">          AssertionError: edge (0, 0) is not glued</span>
<span class="sd">          ------------------------------------------------------------</span>
<span class="sd">          The following tests failed: _test_gluings</span>
<span class="sd">        Failure in _test_underlying_surface</span>
<span class="sd">        The following tests failed: _test_underlying_surface</span>

<span class="sd">        sage: Stop.set_edge_pairing(0, 0, 0, 3)</span>
<span class="sd">        sage: Stop.set_edge_pairing(0, 1, 0, 3)</span>
<span class="sd">        sage: Stop.set_edge_pairing(0, 2, 0, 3)</span>
<span class="sd">        sage: S = SimilaritySurface(Stop)</span>
<span class="sd">        sage: TestSuite(S).run()</span>
<span class="sd">        ...</span>
<span class="sd">          AssertionError: edge gluing is not a pairing:</span>
<span class="sd">          (0, 0) -&gt; (0, 3) -&gt; (0, 2)</span>
<span class="sd">          ------------------------------------------------------------</span>
<span class="sd">          The following tests failed: _test_gluings</span>
<span class="sd">        Failure in _test_underlying_surface</span>
<span class="sd">        The following tests failed: _test_underlying_surface</span>

<span class="sd">    Finally, you can also implement a similarity surface by inheriting from</span>
<span class="sd">    :class:`SimilaritySurface` and implement the methods:</span>

<span class="sd">    - ``base_ring(self)``: the base ring in which coordinates lives</span>

<span class="sd">    - ``polygon(self, lab)``: the polygon associated to the label ``lab``</span>

<span class="sd">    - ``base_label(self)``: which label to use as the base one</span>

<span class="sd">    - ``opposite_edge(self, lab, edge)``: a pair (``other_label``,</span>
<span class="sd">      ``other_edge``) representing the edge being glued</span>

<span class="sd">    - ``is_finite(self)``: whether the surface is built from finitely many polygons</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surface</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf.geometry.similarity_surface import SimilaritySurface</span>
<span class="sd">            sage: SimilaritySurface(3)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            TypeError: invalid argument surface=3 to build a similarity surface</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">SimilaritySurface</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">underlying_surface</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">Surface</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s</span> <span class="o">=</span> <span class="n">surface</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;invalid argument surface=</span><span class="si">{}</span><span class="s2"> to build a similarity surface&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">surface</span><span class="p">))</span>

    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">_matrix_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sage.matrix.matrix_space</span> <span class="kn">import</span> <span class="n">MatrixSpace</span>
        <span class="k">return</span> <span class="n">MatrixSpace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">(),</span> <span class="mi">2</span><span class="p">)</span>

<div class="viewcode-block" id="SimilaritySurface.underlying_surface"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.underlying_surface">[docs]</a>    <span class="k">def</span> <span class="nf">underlying_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the surface underlying this SimilaritySurface.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span></div>

    <span class="k">def</span> <span class="nf">_test_underlying_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="n">is_sub_testsuite</span> <span class="o">=</span> <span class="s1">&#39;tester&#39;</span> <span class="ow">in</span> <span class="n">options</span>
        <span class="n">tester</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tester</span><span class="p">(</span><span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="c1"># TODO: this nested subsuite is very fragile since we have no</span>
        <span class="c1">#       way of forwarding the doctests to be skipped... Since</span>
        <span class="c1">#       for now, the unique usage of this is for pickling of</span>
        <span class="c1">#       infinite surface we provide that manually</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
            <span class="n">skip</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;_test_pickling&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">skip</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">TestSuite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">tester</span><span class="o">.</span><span class="n">_verbose</span><span class="p">,</span>
                                <span class="n">prefix</span> <span class="o">=</span> <span class="n">tester</span><span class="o">.</span><span class="n">_prefix</span> <span class="o">+</span> <span class="s2">&quot;  &quot;</span><span class="p">,</span>
                                <span class="n">raise_on_failure</span><span class="o">=</span><span class="n">is_sub_testsuite</span><span class="p">,</span>
                                <span class="n">skip</span><span class="o">=</span><span class="n">skip</span><span class="p">)</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">tester</span><span class="o">.</span><span class="n">_prefix</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="SimilaritySurface.base_ring"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.base_ring">[docs]</a>    <span class="k">def</span> <span class="nf">base_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The field on which the coordinates of ``self`` live.</span>

<span class="sd">        This method must be overriden in subclasses!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span></div>

<div class="viewcode-block" id="SimilaritySurface.polygon"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.polygon">[docs]</a>    <span class="k">def</span> <span class="nf">polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lab</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the polygon with label ``lab``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimilaritySurface.base_label"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.base_label">[docs]</a>    <span class="k">def</span> <span class="nf">base_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Always returns the same label.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">base_label</span><span class="p">()</span></div>

<div class="viewcode-block" id="SimilaritySurface.opposite_edge"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.opposite_edge">[docs]</a>    <span class="k">def</span> <span class="nf">opposite_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the label ``l`` of a polygon and an edge ``e`` in that polygon</span>
<span class="sd">        returns the pair (``ll``, ``ee``) to which this edge is glued.</span>
<span class="sd">        If e is not provided, then it expects the only parameter to be</span>
<span class="sd">        the pair (``l``,``e``) and will again return a the pair (``ll``,``ee``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">e</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimilaritySurface.is_finite"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.is_finite">[docs]</a>    <span class="k">def</span> <span class="nf">is_finite</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether or not the surface is finite.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">is_finite</span><span class="p">()</span></div>

<div class="viewcode-block" id="SimilaritySurface.is_mutable"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.is_mutable">[docs]</a>    <span class="k">def</span> <span class="nf">is_mutable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return if the surface is mutable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">()</span></div>

<div class="viewcode-block" id="SimilaritySurface.set_immutable"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.set_immutable">[docs]</a>    <span class="k">def</span> <span class="nf">set_immutable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mark the surface as immutable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">set_immutable</span><span class="p">()</span></div>

<div class="viewcode-block" id="SimilaritySurface.is_triangulated"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.is_triangulated">[docs]</a>    <span class="k">def</span> <span class="nf">is_triangulated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">is_triangulated</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span></div>

    <span class="c1">#</span>
    <span class="c1"># generic methods</span>
    <span class="c1">#</span>

    <span class="c1">#def compute_surface_type_from_gluings(self,limit=None):</span>
    <span class="c1">#    r&quot;&quot;&quot;</span>
    <span class="c1">#    Compute the surface type by looking at the edge gluings.</span>
    <span class="c1">#    If limit is defined, we try to guess the type by looking at limit many edges.</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    if limit is None:</span>
    <span class="c1">#        if not self.is_finite():</span>
    <span class="c1">#            raise ValueError(&quot;Need a limit when working with an infinite surface.&quot;)</span>
    <span class="c1">#        it = self.edge_iterator()</span>
    <span class="c1">#        label,edge = it.next()</span>
    <span class="c1">#        # Use honest matrices!</span>
    <span class="c1">#        m = SimilaritySurface_generic.edge_matrix(self,label,edge)</span>
    <span class="c1">#        surface_type = surface_type_from_matrix(m)</span>
    <span class="c1">#        for label,edge in it:</span>
    <span class="c1">#            # Use honest matrices!</span>
    <span class="c1">#            m = SimilaritySurface_generic.edge_matrix(self,label,edge)</span>
    <span class="c1">#            surface_type = combine_surface_types(surface_type, surface_type_from_matrix(m))</span>
    <span class="c1">#        return surface_type</span>
    <span class="c1">#    else:</span>
    <span class="c1">#        count=0</span>
    <span class="c1">#        it = self.edge_iterator()</span>
    <span class="c1">#        label,edge = it.next()</span>
    <span class="c1">#        # Use honest matrices!</span>
    <span class="c1">#        m = SimilaritySurface_generic.edge_matrix(self,label,edge)</span>
    <span class="c1">#        surface_type = surface_type_from_matrix(m)</span>
    <span class="c1">#        for label,edge in it:</span>
    <span class="c1">#            # Use honest matrices!</span>
    <span class="c1">#            m = SimilaritySurface_generic.edge_matrix(self,label,edge)</span>
    <span class="c1">#            surface_type = combine_surface_types(surface_type, surface_type_from_matrix(m))</span>
    <span class="c1">#            count=count+1</span>
    <span class="c1">#            if count &gt;= limit:</span>
    <span class="c1">#                return surface_type</span>
    <span class="c1">#        return surface_type</span>

<div class="viewcode-block" id="SimilaritySurface.walker"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.walker">[docs]</a>    <span class="k">def</span> <span class="nf">walker</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">walker</span><span class="p">()</span></div>

<div class="viewcode-block" id="SimilaritySurface.label_iterator"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.label_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">label_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polygons</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator over all polygon labels.</span>

<span class="sd">        If the keyword polygons is True then we return pairs (label, polygon)</span>
<span class="sd">        instead of just labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">polygons</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">label_polygon_iterator</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">label_iterator</span><span class="p">()</span></div>

<div class="viewcode-block" id="SimilaritySurface.edge_iterator"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.edge_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">edge_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gluings</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over the edges of polygons, which are pairs (l,e) where l is a polygon label, 0 &lt;= e &lt; N and N is the number of edges of the polygon with label l.</span>

<span class="sd">        If the keyword gluings is set to true, then we iterate over ordered</span>
<span class="sd">        pairs of edges ((l,e),(ll,ee)) where edge (l,e) is glued to (ll,ee).</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import ConvexPolygons</span>
<span class="sd">            sage: P = ConvexPolygons(QQ)</span>
<span class="sd">            sage: tri0=P([(1,0),(0,1),(-1,-1)])</span>
<span class="sd">            sage: tri1=P([(-1,0),(0,-1),(1,1)])</span>
<span class="sd">            sage: gluings=[((0,0),(1,0)),((0,1),(1,1)),((0,2),(1,2))]</span>
<span class="sd">            sage: from flatsurf.geometry.surface import surface_list_from_polygons_and_gluings</span>
<span class="sd">            sage: from flatsurf.geometry.translation_surface import TranslationSurface</span>
<span class="sd">            sage: s=TranslationSurface(surface_list_from_polygons_and_gluings([tri0,tri1], gluings))</span>
<span class="sd">            sage: for edge in s.edge_iterator():</span>
<span class="sd">            ....:     print(edge)</span>
<span class="sd">            (0, 0)</span>
<span class="sd">            (0, 1)</span>
<span class="sd">            (0, 2)</span>
<span class="sd">            (1, 0)</span>
<span class="sd">            (1, 1)</span>
<span class="sd">            (1, 2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">gluings</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">edge_gluing_iterator</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">()</span></div>

<div class="viewcode-block" id="SimilaritySurface.num_polygons"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.num_polygons">[docs]</a>    <span class="k">def</span> <span class="nf">num_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of polygons.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">num_polygons</span><span class="p">()</span></div>

<div class="viewcode-block" id="SimilaritySurface.num_edges"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.num_edges">[docs]</a>    <span class="k">def</span> <span class="nf">num_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the total number of edges of all polygons used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span></div>

<div class="viewcode-block" id="SimilaritySurface.num_singularities"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.num_singularities">[docs]</a>    <span class="k">def</span> <span class="nf">num_singularities</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import *</span>

<span class="sd">            sage: translation_surfaces.regular_octagon().num_singularities()</span>
<span class="sd">            1</span>

<span class="sd">            sage: S = SymmetricGroup(4)</span>
<span class="sd">            sage: r = S(&#39;(1,2)(3,4)&#39;)</span>
<span class="sd">            sage: u = S(&#39;(2,3)&#39;)</span>
<span class="sd">            sage: translation_surfaces.origami(r,u).num_singularities()</span>
<span class="sd">            2</span>

<span class="sd">            sage: S = SymmetricGroup(8)</span>
<span class="sd">            sage: r = S(&#39;(1,2,3,4,5,6,7,8)&#39;)</span>
<span class="sd">            sage: u = S(&#39;(1,8,5,4)(2,3)(6,7)&#39;)</span>
<span class="sd">            sage: translation_surfaces.origami(r,u).num_singularities()</span>
<span class="sd">            4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the method only work for finite surfaces&quot;</span><span class="p">)</span>

        <span class="c1"># NOTE:</span>
        <span class="c1"># the very same code is implemented in the method angles (translation</span>
        <span class="c1"># surfaces). we should factor out the code</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">((</span><span class="n">p</span><span class="p">,</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_iterator</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()))</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">p</span><span class="p">,</span><span class="n">e</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ee</span> <span class="o">=</span> <span class="p">(</span><span class="n">e</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span>
            <span class="n">p</span><span class="p">,</span><span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">ee</span><span class="p">)</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">e</span><span class="p">)</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                <span class="n">edges</span><span class="o">.</span><span class="n">remove</span><span class="p">((</span><span class="n">p</span><span class="p">,</span><span class="n">e</span><span class="p">))</span>
                <span class="n">ee</span> <span class="o">=</span> <span class="p">(</span><span class="n">e</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span>
                <span class="n">p</span><span class="p">,</span><span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">ee</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n</span></div>

    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_polygons</span><span class="p">()</span> <span class="o">==</span> <span class="n">Infinity</span><span class="p">:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="s1">&#39;infinitely many&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_polygons</span><span class="p">())</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_polygons</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="s2">&quot;s&quot;</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> built from </span><span class="si">{}</span><span class="s2"> polygon</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

<div class="viewcode-block" id="SimilaritySurface.edge_matrix"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.edge_matrix">[docs]</a>    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">edge_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the 2x2 matrix representing a similarity which when applied to the polygon with label `p`</span>
<span class="sd">        makes it so the edge `e` can be glued to its opposite edge by translation.</span>

<span class="sd">        If `e` is not provided, then `p` should be a pair consisting of a polygon label and an edge.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf.geometry.similarity_surface_generators import SimilaritySurfaceGenerators</span>
<span class="sd">            sage: s = SimilaritySurfaceGenerators.example()</span>
<span class="sd">            sage: print(s.polygon(0))</span>
<span class="sd">            Polygon: (0, 0), (2, -2), (2, 0)</span>
<span class="sd">            sage: print(s.polygon(1))</span>
<span class="sd">            Polygon: (0, 0), (2, 0), (1, 3)</span>
<span class="sd">            sage: s.opposite_edge(0,0)</span>
<span class="sd">            (1, 1)</span>
<span class="sd">            sage: m = s.edge_matrix(0, 0)</span>
<span class="sd">            sage: m</span>
<span class="sd">            [   1  1/2]</span>
<span class="sd">            [-1/2    1]</span>
<span class="sd">            sage: m * vector((2,-2)) == -vector((-1, 3))</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">warning</span>
            <span class="n">warning</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;edge_matrix will now only take two arguments&#39;</span><span class="p">)</span>
            <span class="n">p</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">p</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="n">pp</span><span class="p">,</span> <span class="n">ee</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">ee</span><span class="p">)</span>

        <span class="c1"># be careful, because of the orientation, it is -v and not v</span>
        <span class="k">return</span> <span class="n">similarity_from_vectors</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="o">-</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matrix_space</span><span class="p">())</span></div>

<div class="viewcode-block" id="SimilaritySurface.edge_transformation"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.edge_transformation">[docs]</a>    <span class="k">def</span> <span class="nf">edge_transformation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the similarity bringing the provided edge to the opposite edge.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf.geometry.similarity_surface_generators import SimilaritySurfaceGenerators</span>
<span class="sd">            sage: s = SimilaritySurfaceGenerators.example()</span>
<span class="sd">            sage: print(s.polygon(0))</span>
<span class="sd">            Polygon: (0, 0), (2, -2), (2, 0)</span>
<span class="sd">            sage: print(s.polygon(1))</span>
<span class="sd">            Polygon: (0, 0), (2, 0), (1, 3)</span>
<span class="sd">            sage: print(s.opposite_edge(0,0))</span>
<span class="sd">            (1, 1)</span>
<span class="sd">            sage: g = s.edge_transformation(0,0)</span>
<span class="sd">            sage: g((0,0))</span>
<span class="sd">            (1, 3)</span>
<span class="sd">            sage: g((2,-2))</span>
<span class="sd">            (2, 0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">SimilarityGroup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">())</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">e</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># This is the similarity carrying the origin to a and (1,0) to b:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">pp</span><span class="p">,</span> <span class="n">ee</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
        <span class="n">qq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span>
        <span class="c1"># Be careful here: opposite vertices are identified</span>
        <span class="n">aa</span> <span class="o">=</span> <span class="n">qq</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">ee</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">bb</span> <span class="o">=</span> <span class="n">qq</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">ee</span><span class="p">)</span>
        <span class="c1"># This is the similarity carrying the origin to aa and (1,0) to bb:</span>
        <span class="n">gg</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">aa</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">aa</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">aa</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">aa</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># This is the similarity carrying (a,b) to (aa,bb):</span>
        <span class="k">return</span> <span class="n">gg</span> <span class="o">/</span> <span class="n">g</span></div>

<div class="viewcode-block" id="SimilaritySurface.set_vertex_zero"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.set_vertex_zero">[docs]</a>    <span class="k">def</span> <span class="nf">set_vertex_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies a combinatorial rotation to the polygon with the provided label.</span>

<span class="sd">        This makes what is currently vertex v of this polygon vertex 0. In other words,</span>
<span class="sd">        what is currently vertex (or edge) e will now become vertex (e-v)%n where</span>
<span class="sd">        n is the number of sides of the polygon.</span>

<span class="sd">        For the updated polygons, the polygons will be translated so that vertex</span>
<span class="sd">        0 is the origin.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Example with polygon glued to another polygon::</span>

<span class="sd">            sage: from flatsurf import *</span>
<span class="sd">            sage: s = translation_surfaces.veech_double_n_gon(4)</span>
<span class="sd">            sage: s.polygon(0)</span>
<span class="sd">            Polygon: (0, 0), (1, 0), (1, 1), (0, 1)</span>
<span class="sd">            sage: [s.opposite_edge(0,i) for i in range(4)]</span>
<span class="sd">            [(1, 0), (1, 1), (1, 2), (1, 3)]</span>
<span class="sd">            sage: ss = s.set_vertex_zero(0,1)</span>
<span class="sd">            sage: ss.polygon(0)</span>
<span class="sd">            Polygon: (0, 0), (0, 1), (-1, 1), (-1, 0)</span>
<span class="sd">            sage: [ss.opposite_edge(0,i) for i in range(4)]</span>
<span class="sd">            [(1, 1), (1, 2), (1, 3), (1, 0)]</span>
<span class="sd">            sage: TestSuite(ss).run()</span>

<span class="sd">        Example with polygon glued to self::</span>

<span class="sd">            sage: s = translation_surfaces.veech_2n_gon(2)</span>
<span class="sd">            sage: s.polygon(0)</span>
<span class="sd">            Polygon: (0, 0), (1, 0), (1, 1), (0, 1)</span>
<span class="sd">            sage: [s.opposite_edge(0,i) for i in range(4)]</span>
<span class="sd">            [(0, 2), (0, 3), (0, 0), (0, 1)]</span>
<span class="sd">            sage: ss = s.set_vertex_zero(0,3)</span>
<span class="sd">            sage: ss.polygon(0)</span>
<span class="sd">            Polygon: (0, 0), (0, -1), (1, -1), (1, 0)</span>
<span class="sd">            sage: [ss.opposite_edge(0,i) for i in range(4)]</span>
<span class="sd">            [(0, 2), (0, 3), (0, 0), (0, 1)]</span>
<span class="sd">            sage: TestSuite(ss).run()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="n">us</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">underlying_surface</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">us</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;set_vertex_zero can only be done in_place for a mutable surface.&quot;</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">us</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="n">n</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span>
            <span class="k">assert</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">v</span> <span class="ow">and</span> <span class="n">v</span><span class="o">&lt;</span><span class="n">n</span>
            <span class="n">glue</span><span class="o">=</span><span class="p">[]</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">ConvexPolygons</span><span class="p">(</span><span class="n">us</span><span class="o">.</span><span class="n">base_ring</span><span class="p">())</span>
            <span class="n">pp</span> <span class="o">=</span> <span class="n">P</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">edge</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="n">v</span><span class="p">)</span><span class="o">%</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">e</span><span class="o">=</span><span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="n">n</span>
                <span class="n">ll</span><span class="p">,</span><span class="n">ee</span> <span class="o">=</span> <span class="n">us</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">e</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ll</span><span class="o">==</span><span class="n">label</span><span class="p">:</span>
                    <span class="n">ee</span> <span class="o">=</span> <span class="p">(</span><span class="n">ee</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="n">v</span><span class="p">)</span><span class="o">%</span><span class="n">n</span>
                <span class="n">glue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ll</span><span class="p">,</span><span class="n">ee</span><span class="p">))</span>

            <span class="n">us</span><span class="o">.</span><span class="n">change_polygon</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">pp</span><span class="p">,</span><span class="n">gluing_list</span><span class="o">=</span><span class="n">glue</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">set_vertex_zero</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_label_comparator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a LabelComparator, which provides a fixed total ordering on the polygon labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lc</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lc</span> <span class="o">=</span> <span class="n">LabelComparator</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lc</span>

<div class="viewcode-block" id="SimilaritySurface.relabel"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.relabel">[docs]</a>    <span class="k">def</span> <span class="nf">relabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">relabeling_map</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempt to relabel the polygons according to a relabeling_map, which takes as input</span>
<span class="sd">        a current label and outputs a new label for the same polygon. The method returns a pair</span>
<span class="sd">        (surface,success) where surface is the relabeled surface, and success is a boolean value</span>
<span class="sd">        indicating the success of the operation. The operation will fail if the implementation of the</span>
<span class="sd">        underlying surface does not support labels used in the image of the relabeling map. In this case,</span>
<span class="sd">        other (arbitrary) labels will be used to replace the labels of the surface, and the resulting</span>
<span class="sd">        surface should still be okay.</span>

<span class="sd">        Currently, the relabeling_map must be a dictionary.</span>

<span class="sd">        If in_place is True then the relabeling is done to the current surface, otherwise a</span>
<span class="sd">        mutable copy is made before relabeling.</span>

<span class="sd">        ToDo:</span>
<span class="sd">          - Allow relabeling_map to be a function rather than just a dictionary.</span>
<span class="sd">            This will allow it to work for infinite surfaces.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import *</span>
<span class="sd">            sage: s=translation_surfaces.veech_double_n_gon(5)</span>
<span class="sd">            sage: ss,valid=s.relabel({0:1,1:2})</span>
<span class="sd">            sage: valid</span>
<span class="sd">            True</span>
<span class="sd">            sage: ss.base_label()</span>
<span class="sd">            1</span>
<span class="sd">            sage: ss.opposite_edge(1,0)</span>
<span class="sd">            (2, 0)</span>
<span class="sd">            sage: ss.num_polygons()</span>
<span class="sd">            2</span>
<span class="sd">            sage: TestSuite(ss).run()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="n">us</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">underlying_surface</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">us</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Your surface is not mutable, so can not be relabeled in place.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">relabeling_map</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Currently relabeling is only implemented via a dictionary.&quot;</span><span class="p">)</span>
            <span class="n">domain</span><span class="o">=</span><span class="nb">set</span><span class="p">()</span>
            <span class="n">codomain</span><span class="o">=</span><span class="nb">set</span><span class="p">()</span>
            <span class="n">data</span><span class="o">=</span><span class="p">{}</span>
            <span class="k">for</span> <span class="n">l1</span><span class="p">,</span><span class="n">l2</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">relabeling_map</span><span class="p">):</span>
                <span class="n">p</span><span class="o">=</span><span class="n">us</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">l1</span><span class="p">)</span>
                <span class="n">glue</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()):</span>
                    <span class="n">ll</span><span class="p">,</span><span class="n">ee</span> <span class="o">=</span> <span class="n">us</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">e</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">lll</span><span class="o">=</span><span class="n">relabeling_map</span><span class="p">[</span><span class="n">ll</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="n">lll</span><span class="o">=</span><span class="n">ll</span>
                    <span class="n">glue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lll</span><span class="p">,</span><span class="n">ee</span><span class="p">))</span>
                <span class="n">data</span><span class="p">[</span><span class="n">l2</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">glue</span><span class="p">)</span>
                <span class="n">domain</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">l1</span><span class="p">)</span>
                <span class="n">codomain</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">l2</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">codomain</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The relabeling_map must be injective. Received &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">relabeling_map</span><span class="p">))</span>
            <span class="n">changed_labels</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">codomain</span><span class="p">)</span>
            <span class="n">added_labels</span><span class="o">=</span><span class="n">codomain</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
            <span class="n">removed_labels</span><span class="o">=</span><span class="n">domain</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">codomain</span><span class="p">)</span>
            <span class="c1"># Pass to add_polygons</span>
            <span class="n">relabel_errors</span><span class="o">=</span><span class="p">{}</span>
            <span class="k">for</span> <span class="n">l2</span> <span class="ow">in</span> <span class="n">added_labels</span><span class="p">:</span>
                <span class="n">p</span><span class="p">,</span><span class="n">glue</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">l2</span><span class="p">]</span>
                <span class="n">l3</span> <span class="o">=</span> <span class="n">us</span><span class="o">.</span><span class="n">add_polygon</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">l2</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">l2</span><span class="o">==</span><span class="n">l3</span><span class="p">:</span>
                    <span class="c1"># This means the label l2 could not be added for some reason.</span>
                    <span class="c1"># Perhaps the implementation does not support this type of label.</span>
                    <span class="c1"># Or perhaps there is already a polygon with this label.</span>
                    <span class="n">relabel_errors</span><span class="p">[</span><span class="n">l2</span><span class="p">]</span><span class="o">=</span><span class="n">l3</span>
            <span class="c1"># Pass to change polygons</span>
            <span class="k">for</span> <span class="n">l2</span> <span class="ow">in</span> <span class="n">changed_labels</span><span class="p">:</span>
                <span class="n">p</span><span class="p">,</span><span class="n">glue</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">l2</span><span class="p">]</span>
                <span class="c1"># This should always work since the domain of the relabeling map should be labels for polygons.</span>
                <span class="n">us</span><span class="o">.</span><span class="n">change_polygon</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span><span class="n">p</span><span class="p">)</span>
            <span class="c1"># Deal with the base_label</span>
            <span class="n">base_label</span> <span class="o">=</span> <span class="n">us</span><span class="o">.</span><span class="n">base_label</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">base_label</span> <span class="ow">in</span> <span class="n">relabeling_map</span><span class="p">:</span>
                <span class="n">base_label</span> <span class="o">=</span> <span class="n">relabeling_map</span><span class="p">[</span><span class="n">base_label</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">base_label</span> <span class="ow">in</span> <span class="n">relabel_errors</span><span class="p">:</span>
                    <span class="n">base_label</span> <span class="o">=</span> <span class="n">relabel_errors</span><span class="p">[</span><span class="n">base_label</span><span class="p">]</span>
                <span class="n">us</span><span class="o">.</span><span class="n">change_base_label</span><span class="p">(</span><span class="n">base_label</span><span class="p">)</span>
            <span class="c1"># Pass to remove polygons:</span>
            <span class="k">for</span> <span class="n">l1</span> <span class="ow">in</span> <span class="n">removed_labels</span><span class="p">:</span>
                <span class="n">us</span><span class="o">.</span><span class="n">remove_polygon</span><span class="p">(</span><span class="n">l1</span><span class="p">)</span>
            <span class="c1"># Pass to update the edge gluings</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">relabel_errors</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="c1"># No problems. Update the gluings.</span>
                <span class="k">for</span> <span class="n">l2</span> <span class="ow">in</span> <span class="n">codomain</span><span class="p">:</span>
                    <span class="n">p</span><span class="p">,</span><span class="n">glue</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">l2</span><span class="p">]</span>
                    <span class="n">us</span><span class="o">.</span><span class="n">change_polygon_gluings</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span> <span class="n">glue</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use the gluings provided by relabel_errors when necessary</span>
                <span class="k">for</span> <span class="n">l2</span> <span class="ow">in</span> <span class="n">codomain</span><span class="p">:</span>
                    <span class="n">p</span><span class="p">,</span><span class="n">glue</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">l2</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()):</span>
                        <span class="n">ll</span><span class="p">,</span><span class="n">ee</span><span class="o">=</span><span class="n">glue</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="c1"># First try the error dictionary</span>
                            <span class="n">us</span><span class="o">.</span><span class="n">change_edge_gluing</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">relabel_errors</span><span class="p">[</span><span class="n">ll</span><span class="p">],</span><span class="n">ee</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                            <span class="n">us</span><span class="o">.</span><span class="n">change_edge_gluing</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">ll</span><span class="p">,</span><span class="n">ee</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">relabel_errors</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="n">relabeling_map</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimilaritySurface.copy"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">relabel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mutable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">new_field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">optimal_number_field</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of this surface. The method takes several flags to modify how the copy is taken.</span>

<span class="sd">        If relabel is True, then instead of returning an exact copy, it returns a copy indexed by the</span>
<span class="sd">        non-negative integers. This uses the Surface_list implementation. If relabel is False (default),</span>
<span class="sd">        then we return an exact copy. The returned surface uses the Surface_dict implementation.</span>

<span class="sd">        The mutability flag returns if the resulting surface should be mutable or not. By default, the</span>
<span class="sd">        resulting surface will not be mutable.</span>

<span class="sd">        If lazy is True, then the surface is copied by reference. This is the only type of copy</span>
<span class="sd">        possible for infinite surfaces. The parameter defaults to False for finite surfaces, and</span>
<span class="sd">        defaults to True for infinite surfaces.</span>

<span class="sd">        The new_field parameter can be used to place the vertices in a larger field than the basefield</span>
<span class="sd">        for the original surface.</span>

<span class="sd">        The optimal_number_field option can be used to find a best NumberField containing the</span>
<span class="sd">        (necessarily finite) surface.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import *</span>
<span class="sd">            sage: ss=translation_surfaces.ward(3)</span>
<span class="sd">            sage: print(ss.is_mutable())</span>
<span class="sd">            False</span>
<span class="sd">            sage: s=ss.copy(mutable=True)</span>
<span class="sd">            sage: print(s.is_mutable())</span>
<span class="sd">            True</span>
<span class="sd">            sage: TestSuite(s).run()</span>
<span class="sd">            sage: print(s==ss)</span>
<span class="sd">            True</span>

<span class="sd">            sage: # Changing the base field</span>
<span class="sd">            sage: from flatsurf import *</span>
<span class="sd">            sage: s=translation_surfaces.veech_double_n_gon(5)</span>
<span class="sd">            sage: ss=s.copy(mutable=False,new_field=AA)</span>
<span class="sd">            sage: TestSuite(ss).run()</span>
<span class="sd">            sage: ss.base_ring()</span>
<span class="sd">            Algebraic Real Field</span>

<span class="sd">            sage: # Optimization of number field</span>
<span class="sd">            sage: from flatsurf import *</span>
<span class="sd">            sage: s = translation_surfaces.arnoux_yoccoz(3)</span>
<span class="sd">            sage: ss = s.copy(new_field=AA).copy(optimal_number_field=True)</span>
<span class="sd">            sage: TestSuite(ss).run()</span>
<span class="sd">            sage: ss.base_ring().discriminant()</span>
<span class="sd">            -44</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># This will be the surface we copy. (Likely we will set s=self below.)</span>
        <span class="k">if</span> <span class="n">new_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">optimal_number_field</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You can not set a new_field and also set optimal_number_field=True.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">optimal_number_field</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite</span><span class="p">(),</span> <span class="s2">&quot;Can only optimize_number_field for a finite surface.&quot;</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">lazy</span><span class="p">,</span> <span class="s2">&quot;Lazy copying is unavailable when optimize_number_field=True.&quot;</span>
            <span class="n">coordinates_AA</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">l</span><span class="p">,</span><span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_iterator</span><span class="p">(</span><span class="n">polygons</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
                    <span class="n">coordinates_AA</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">AA</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                    <span class="n">coordinates_AA</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">AA</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="kn">from</span> <span class="nn">sage.rings.qqbar</span> <span class="kn">import</span> <span class="n">number_field_elements_from_algebraics</span>
            <span class="n">field</span><span class="p">,</span><span class="n">coordinates_NF</span><span class="p">,</span><span class="n">hom</span> <span class="o">=</span> <span class="n">number_field_elements_from_algebraics</span><span class="p">(</span><span class="n">coordinates_AA</span><span class="p">,</span> <span class="n">minimal</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">field</span> <span class="ow">is</span> <span class="n">QQ</span><span class="p">:</span>
                <span class="n">new_field</span> <span class="o">=</span> <span class="n">QQ</span>
                <span class="c1"># We pretend new_field = QQ was passed as a parameter.</span>
                <span class="c1"># It will now get picked up by the &quot;if new_field is not None:&quot; line below.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Unfortunately field doesn&#39;t come with an real embedding (which is given by hom!)</span>
                <span class="c1"># So, we make a copy of the field, and add the embedding.</span>
                <span class="n">field2</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">polynomial</span><span class="p">(),</span> <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">embedding</span> <span class="o">=</span> <span class="n">hom</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">gen</span><span class="p">()))</span>
                <span class="c1"># The following converts from field to field2:</span>
                <span class="n">hom2</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">hom</span><span class="p">(</span><span class="n">im_gens</span> <span class="o">=</span> <span class="p">[</span><span class="n">field2</span><span class="o">.</span><span class="n">gen</span><span class="p">()])</span>

                <span class="n">ss</span> <span class="o">=</span> <span class="n">Surface_dict</span><span class="p">(</span><span class="n">base_ring</span> <span class="o">=</span> <span class="n">field2</span><span class="p">)</span>
                <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">P</span> <span class="o">=</span> <span class="n">ConvexPolygons</span><span class="p">(</span><span class="n">field2</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">l</span><span class="p">,</span><span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_iterator</span><span class="p">(</span><span class="n">polygons</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
                    <span class="n">new_edges</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()):</span>
                        <span class="n">new_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">hom2</span><span class="p">(</span><span class="n">coordinates_NF</span><span class="p">[</span><span class="n">index</span><span class="p">]),</span> <span class="n">hom2</span><span class="p">(</span><span class="n">coordinates_NF</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span> <span class="p">)</span>
                        <span class="n">index</span> <span class="o">+=</span> <span class="mi">2</span>
                    <span class="n">pp</span> <span class="o">=</span> <span class="n">P</span><span class="p">(</span><span class="n">edges</span> <span class="o">=</span> <span class="n">new_edges</span><span class="p">)</span>
                    <span class="n">ss</span><span class="o">.</span><span class="n">add_polygon</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">l</span><span class="p">)</span>
                <span class="n">ss</span><span class="o">.</span><span class="n">change_base_label</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_label</span><span class="p">())</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">e1</span><span class="p">),(</span><span class="n">l2</span><span class="p">,</span><span class="n">e2</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">(</span><span class="n">gluings</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
                    <span class="n">ss</span><span class="o">.</span><span class="n">change_edge_gluing</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">relabel</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">mutable</span><span class="p">:</span>
                        <span class="n">s</span><span class="o">.</span><span class="n">set_immutable</span><span class="p">()</span>
                    <span class="k">return</span> <span class="n">s</span>
                <span class="c1"># Otherwise we are supposed to relabel. We will make a relabeled copy of s below.</span>
        <span class="k">if</span> <span class="n">new_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">flatsurf.geometry.surface</span> <span class="kn">import</span> <span class="n">BaseRingChangedSurface</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">BaseRingChangedSurface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">new_field</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">relabel</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">Surface_list</span><span class="p">(</span><span class="n">surface</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="ow">not</span> <span class="n">lazy</span><span class="p">,</span> <span class="n">mutable</span><span class="o">=</span><span class="n">mutable</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">Surface_dict</span><span class="p">(</span><span class="n">surface</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="ow">not</span> <span class="n">lazy</span><span class="p">,</span> <span class="n">mutable</span><span class="o">=</span><span class="n">mutable</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lazy</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only lazy copying available for infinite surfaces.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">underlying_surface</span><span class="p">()</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;An infinite surface can only be copied if it is immutable.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">relabel</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">Surface_list</span><span class="p">(</span><span class="n">surface</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mutable</span><span class="o">=</span><span class="n">mutable</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">Surface_dict</span><span class="p">(</span><span class="n">surface</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mutable</span><span class="o">=</span><span class="n">mutable</span><span class="p">))</span></div>

<div class="viewcode-block" id="SimilaritySurface.triangle_flip"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.triangle_flip">[docs]</a>    <span class="k">def</span> <span class="nf">triangle_flip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">test</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flips the diagonal of the quadrilateral formed by two triangles</span>
<span class="sd">        glued together along the provided edge (l1,e1). This can be broken</span>
<span class="sd">        into two steps: join along the edge to form a convex quadilateral,</span>
<span class="sd">        then cut along the other diagonal. Raises a ValueError if this</span>
<span class="sd">        quadrilateral would be non-convex. In this case no changes to the</span>
<span class="sd">        surface are made.</span>

<span class="sd">        The direction parameter defaults to (0,1). This is used to decide how</span>
<span class="sd">        the triangles being glued in are labeled. Let p1 be the triangle</span>
<span class="sd">        associated to label l1, and p2 be the triangle associated to l2</span>
<span class="sd">        but moved by a similarity to share the edge (l1,e1). Each triangle</span>
<span class="sd">        has a exactly one separatrix leaving a vertex which travels in the</span>
<span class="sd">        provided direction or its opposite. (For edges we only count as sepatrices</span>
<span class="sd">        traveling counter-clockwise around the triangle.) This holds for p1</span>
<span class="sd">        and p2 and the separatrices must point in opposite directions.</span>

<span class="sd">        The above description gives two new triangles t1 and t2 which must be</span>
<span class="sd">        glued in (obtained by flipping the diagonal of the quadrilateral).</span>
<span class="sd">        Up to swapping t1 and t2 we can assume the separatrix in t1 in the</span>
<span class="sd">        provided direction (or its opposite) points in the same direction as</span>
<span class="sd">        that of p1. Further up to cyclic permutation of vertex labels we can</span>
<span class="sd">        assume that the separatrices in p1 and t1 start at the vertex with the</span>
<span class="sd">        same index (an element of {0,1,2}). The same can be done for p2 and t2.</span>
<span class="sd">        We apply the label l1 to t1 and the label l2 to t2. This precisely</span>
<span class="sd">        determines how t1 and t2 should be used to replace p1 and p2.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``l1`` - label of polygon</span>

<span class="sd">        - ``e1`` - (integer) edge of the polygon</span>

<span class="sd">        - ``in_place`` (boolean) - If True do the flip to the current surface</span>
<span class="sd">          which must be mutable. In this case the updated surface will be</span>
<span class="sd">          returned.  Otherwise a mutable copy is made and then an edge is</span>
<span class="sd">          flipped, which is then returned.</span>

<span class="sd">        - ``test`` (boolean) - If True we don&#39;t actually flip, and we return</span>
<span class="sd">          True or False depending on whether or not the flip would be</span>
<span class="sd">          successful.</span>

<span class="sd">        - ``direction`` (2-dimensional vector) - Defaults to (0,1). The choice</span>
<span class="sd">          of this vector determines how the newly added triangles are labeled.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import *</span>

<span class="sd">            sage: s = similarity_surfaces.right_angle_triangle(ZZ(1),ZZ(1))</span>
<span class="sd">            sage: print(s.polygon(0))</span>
<span class="sd">            Polygon: (0, 0), (1, 0), (0, 1)</span>
<span class="sd">            sage: s.triangle_flip(0, 0, test=True)</span>
<span class="sd">            False</span>
<span class="sd">            sage: s.triangle_flip(0, 1, test=True)</span>
<span class="sd">            True</span>
<span class="sd">            sage: s.triangle_flip(0, 2, test=True)</span>
<span class="sd">            False</span>

<span class="sd">            sage: s = similarity_surfaces.right_angle_triangle(ZZ(1),ZZ(1))</span>
<span class="sd">            sage: from flatsurf.geometry.surface import Surface_list</span>
<span class="sd">            sage: s = s.__class__(Surface_list(surface=s, mutable=True))</span>
<span class="sd">            sage: try:</span>
<span class="sd">            ....:     s.triangle_flip(0,0,in_place=True)</span>
<span class="sd">            ....: except ValueError as e:</span>
<span class="sd">            ....:     print(e)</span>
<span class="sd">            Gluing triangles along this edge yields a non-convex quadrilateral.</span>
<span class="sd">            sage: s.triangle_flip(0,1,in_place=True)</span>
<span class="sd">            ConeSurface built from 2 polygons</span>
<span class="sd">            sage: s.polygon(0)</span>
<span class="sd">            Polygon: (0, 0), (1, 1), (0, 1)</span>
<span class="sd">            sage: s.polygon(1)</span>
<span class="sd">            Polygon: (0, 0), (-1, -1), (0, -1)</span>
<span class="sd">            sage: for p in s.edge_iterator(gluings=True):</span>
<span class="sd">            ....:     print(p)</span>
<span class="sd">            ((0, 0), (1, 0))</span>
<span class="sd">            ((0, 1), (0, 2))</span>
<span class="sd">            ((0, 2), (0, 1))</span>
<span class="sd">            ((1, 0), (0, 0))</span>
<span class="sd">            ((1, 1), (1, 2))</span>
<span class="sd">            ((1, 2), (1, 1))</span>
<span class="sd">            sage: try:</span>
<span class="sd">            ....:     s.triangle_flip(0,2,in_place=True)</span>
<span class="sd">            ....: except ValueError as e:</span>
<span class="sd">            ....:     print(e)</span>
<span class="sd">            ....:</span>
<span class="sd">            Gluing triangles along this edge yields a non-convex quadrilateral.</span>

<span class="sd">            sage: p = polygons((2,0),(-1,3),(-1,-3))</span>
<span class="sd">            sage: s = similarity_surfaces.self_glued_polygon(p)</span>
<span class="sd">            sage: from flatsurf.geometry.surface import Surface_list</span>
<span class="sd">            sage: s = s.__class__(Surface_list(surface=s,mutable=True))</span>
<span class="sd">            sage: s.triangle_flip(0,1,in_place=True)</span>
<span class="sd">            HalfTranslationSurface built from 1 polygon</span>
<span class="sd">            sage: for x in s.label_iterator(polygons=True):</span>
<span class="sd">            ....:     print(x)</span>
<span class="sd">            (0, Polygon: (0, 0), (-3, -3), (-1, -3))</span>
<span class="sd">            sage: for x in s.edge_iterator(gluings=True):</span>
<span class="sd">            ....:     print(x)</span>
<span class="sd">            ((0, 0), (0, 0))</span>
<span class="sd">            ((0, 1), (0, 1))</span>
<span class="sd">            ((0, 2), (0, 2))</span>
<span class="sd">            sage: TestSuite(s).run()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">test</span><span class="p">:</span>
            <span class="c1"># Just test if the flip would be successful</span>
            <span class="n">p1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">l1</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">p1</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="n">l2</span><span class="p">,</span><span class="n">e2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">e1</span><span class="p">)</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">l2</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">p2</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="n">sim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_transformation</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span><span class="n">e2</span><span class="p">)</span>
            <span class="n">hol</span> <span class="o">=</span> <span class="n">sim</span><span class="p">(</span> <span class="n">p2</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span> <span class="p">(</span><span class="n">e2</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span> <span class="p">)</span> <span class="o">-</span> <span class="n">p1</span><span class="o">.</span><span class="n">vertex</span><span class="p">((</span><span class="n">e1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
            <span class="kn">from</span> <span class="nn">flatsurf.geometry.polygon</span> <span class="kn">import</span> <span class="n">wedge_product</span>
            <span class="k">return</span> <span class="n">wedge_product</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">edge</span><span class="p">((</span><span class="n">e1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span><span class="p">),</span> <span class="n">hol</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> \
                <span class="n">wedge_product</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">edge</span><span class="p">((</span><span class="n">e1</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span><span class="p">),</span> <span class="n">hol</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="n">s</span><span class="o">=</span><span class="bp">self</span>
            <span class="k">assert</span> <span class="n">s</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">(),</span> <span class="s2">&quot;Surface must be mutable for in place triangle_flip.&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">p1</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">l1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">p1</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The polygon with the provided label is not a triangle.&quot;</span><span class="p">)</span>
        <span class="n">l2</span><span class="p">,</span><span class="n">e2</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">e1</span><span class="p">)</span>

        <span class="n">sim</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">edge_transformation</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span><span class="n">e2</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">derivative</span><span class="p">()</span>
        <span class="n">p2</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">l2</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">p2</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The polygon opposite the provided edge is not a triangle.&quot;</span><span class="p">)</span>
        <span class="n">P</span><span class="o">=</span><span class="n">p1</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
        <span class="n">p2</span><span class="o">=</span><span class="n">P</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[</span><span class="n">sim</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">p2</span><span class="o">.</span><span class="n">vertices</span><span class="p">()])</span>

        <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">direction</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">vector_space</span><span class="p">()((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="c1"># Get vertices corresponding to separatices in the provided direction.</span>
        <span class="n">v1</span><span class="o">=</span><span class="n">p1</span><span class="o">.</span><span class="n">find_separatrix</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">v2</span><span class="o">=</span><span class="n">p2</span><span class="o">.</span><span class="n">find_separatrix</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Our quadrilateral has vertices labeled:</span>
        <span class="c1"># * 0=p1.vertex(e1+1)=p2.vertex(e2)</span>
        <span class="c1"># * 1=p1.vertex(e1+2)</span>
        <span class="c1"># * 2=p1.vertex(e1)=p2.vertex(e2+1)</span>
        <span class="c1"># * 3=p2.vertex(e2+2)</span>
        <span class="c1"># Record the corresponding vertices of this quadrilateral.</span>
        <span class="n">q1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="n">v1</span><span class="o">-</span><span class="n">e1</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span>
        <span class="n">q2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="n">v2</span><span class="o">-</span><span class="n">e2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span><span class="p">)</span><span class="o">%</span><span class="mi">4</span>

        <span class="n">new_diagonal</span><span class="o">=</span><span class="n">p2</span><span class="o">.</span><span class="n">vertex</span><span class="p">((</span><span class="n">e2</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span><span class="p">)</span><span class="o">-</span><span class="n">p1</span><span class="o">.</span><span class="n">vertex</span><span class="p">((</span><span class="n">e1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span><span class="p">)</span>
        <span class="c1"># This list will store the new triangles which are being glued in.</span>
        <span class="c1"># (Unfortunately, they may not be cyclically labeled in the correct way.)</span>
        <span class="n">new_triangle</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">new_triangle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="p">[</span><span class="n">p1</span><span class="o">.</span><span class="n">edge</span><span class="p">((</span><span class="n">e1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span><span class="p">),</span><span class="n">p2</span><span class="o">.</span><span class="n">edge</span><span class="p">((</span><span class="n">e2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span><span class="p">),</span><span class="o">-</span><span class="n">new_diagonal</span><span class="p">]))</span>
            <span class="n">new_triangle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="p">[</span><span class="n">p2</span><span class="o">.</span><span class="n">edge</span><span class="p">((</span><span class="n">e2</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span><span class="p">),</span><span class="n">p1</span><span class="o">.</span><span class="n">edge</span><span class="p">((</span><span class="n">e1</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span><span class="p">),</span><span class="n">new_diagonal</span><span class="p">]))</span>
            <span class="c1"># The above triangles would be glued along edge 2 to form the diagonal of the quadrilateral being removed.</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Gluing triangles along this edge yields a non-convex quadrilateral.&quot;</span><span class="p">)</span>

        <span class="c1"># Find the separatrices of the two new triangles, and in particular which way they point.</span>
        <span class="n">new_sep</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">new_sep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_triangle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">find_separatrix</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">new_sep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_triangle</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">find_separatrix</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># The quadrilateral vertices corresponding to these separatrices are</span>
        <span class="c1"># new_sep[0]+1 and (new_sep[1]+3)%4 respectively.</span>

        <span class="c1"># i=0 if the new_triangle[0] should be labeled l1 and new_triangle[1] should be labeled l2.</span>
        <span class="c1"># i=1 indicates the opposite labeling.</span>
        <span class="k">if</span> <span class="n">new_sep</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">==</span><span class="n">q1</span><span class="p">:</span>
            <span class="c1"># For debugging:</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">new_sep</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">%</span><span class="mi">4</span><span class="o">==</span><span class="n">q2</span><span class="p">,</span> \
                <span class="s2">&quot;Bug: new_sep[1]=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">new_sep</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot; and q2=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">q2</span><span class="p">)</span>
            <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For debugging:</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">new_sep</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">%</span><span class="mi">4</span><span class="o">==</span><span class="n">q1</span>
            <span class="k">assert</span> <span class="n">new_sep</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">==</span><span class="n">q2</span>
            <span class="n">i</span><span class="o">=</span><span class="mi">1</span>

        <span class="c1"># These quantities represent the cyclic relabeling of triangles needed.</span>
        <span class="n">cycle1</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_sep</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">v1</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span>
        <span class="n">cycle2</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_sep</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">v2</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span>

        <span class="c1"># This will be the new triangle with label l1:</span>
        <span class="n">tri1</span><span class="o">=</span><span class="n">P</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="p">[</span><span class="n">new_triangle</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">cycle1</span><span class="p">),</span> \
                      <span class="n">new_triangle</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">edge</span><span class="p">((</span><span class="n">cycle1</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span><span class="p">),</span> \
                      <span class="n">new_triangle</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">edge</span><span class="p">((</span><span class="n">cycle1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span><span class="p">)])</span>
        <span class="c1"># This will be the new triangle with label l2:</span>
        <span class="n">tri2</span><span class="o">=</span><span class="n">P</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="p">[</span><span class="n">new_triangle</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">cycle2</span><span class="p">),</span> \
                      <span class="n">new_triangle</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">edge</span><span class="p">((</span><span class="n">cycle2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span><span class="p">),</span> \
                      <span class="n">new_triangle</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">edge</span><span class="p">((</span><span class="n">cycle2</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span><span class="p">)])</span>
        <span class="c1"># In the above, edge 2-cycle1 of tri1 would be glued to edge 2-cycle2 of tri2</span>
        <span class="n">diagonal_glue_e1</span><span class="o">=</span><span class="mi">2</span><span class="o">-</span><span class="n">cycle1</span>
        <span class="n">diagonal_glue_e2</span><span class="o">=</span><span class="mi">2</span><span class="o">-</span><span class="n">cycle2</span>

        <span class="c1"># FOR CATCHING BUGS:</span>
        <span class="k">assert</span> <span class="n">p1</span><span class="o">.</span><span class="n">find_separatrix</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">)</span><span class="o">==</span><span class="n">tri1</span><span class="o">.</span><span class="n">find_separatrix</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">p2</span><span class="o">.</span><span class="n">find_separatrix</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">)</span><span class="o">==</span><span class="n">tri2</span><span class="o">.</span><span class="n">find_separatrix</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">)</span>

        <span class="c1"># Two opposite edges will not change their labels (label,edge) under our regluing operation.</span>
        <span class="c1"># The other two opposite ones will change and in fact they change labels.</span>
        <span class="c1"># The following finds them (there are two cases).</span>
        <span class="c1"># At the end of the if statement, the following will be true:</span>
        <span class="c1"># * new_glue_e1 and new_glue_e2 will be the edges of the new triangle with label l1 and l2 which need regluing.</span>
        <span class="c1"># * old_e1 and old_e2 will be the corresponding edges of the old triangles.</span>
        <span class="c1"># (Note that labels are swapped between the pair. The appending 1 or 2 refers to the label used for the triangle.)</span>
        <span class="k">if</span> <span class="n">p1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span><span class="o">==</span><span class="n">tri1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">v1</span><span class="p">):</span>
            <span class="c1"># We don&#39;t have to worry about changing gluings on edge v1 of the triangles with label l1</span>
            <span class="c1"># We do have to worry about the following edge:</span>
            <span class="n">new_glue_e1</span><span class="o">=</span><span class="mi">3</span><span class="o">-</span><span class="n">diagonal_glue_e1</span><span class="o">-</span><span class="n">v1</span> <span class="c1"># returns the edge which is neither diagonal_glue_e1 nor v1.</span>
            <span class="c1"># This corresponded to the following old edge:</span>
            <span class="n">old_e1</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">-</span> <span class="n">e1</span> <span class="o">-</span> <span class="n">v1</span> <span class="c1"># Again this finds the edge which is neither e1 nor v1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">v1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span>
            <span class="c1"># FOR CATCHING BUGS:</span>
            <span class="k">assert</span> <span class="n">p1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span><span class="o">==</span><span class="n">tri1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
            <span class="c1"># We don&#39;t have to worry about changing gluings on edge (v1+2)%3 of the triangles with label l1</span>
            <span class="c1"># We do have to worry about the following edge:</span>
            <span class="n">new_glue_e1</span><span class="o">=</span><span class="mi">3</span><span class="o">-</span><span class="n">diagonal_glue_e1</span><span class="o">-</span><span class="n">temp</span> <span class="c1"># returns the edge which is neither diagonal_glue_e1 nor temp.</span>
            <span class="c1"># This corresponded to the following old edge:</span>
            <span class="n">old_e1</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">-</span> <span class="n">e1</span> <span class="o">-</span> <span class="n">temp</span> <span class="c1"># Again this finds the edge which is neither e1 nor temp</span>
        <span class="k">if</span> <span class="n">p2</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span><span class="o">==</span><span class="n">tri2</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">v2</span><span class="p">):</span>
            <span class="c1"># We don&#39;t have to worry about changing gluings on edge v2 of the triangles with label l2</span>
            <span class="c1"># We do have to worry about the following edge:</span>
            <span class="n">new_glue_e2</span><span class="o">=</span><span class="mi">3</span><span class="o">-</span><span class="n">diagonal_glue_e2</span><span class="o">-</span><span class="n">v2</span> <span class="c1"># returns the edge which is neither diagonal_glue_e2 nor v2.</span>
            <span class="c1"># This corresponded to the following old edge:</span>
            <span class="n">old_e2</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">-</span> <span class="n">e2</span> <span class="o">-</span> <span class="n">v2</span> <span class="c1"># Again this finds the edge which is neither e2 nor v2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">v2</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span>
            <span class="c1"># FOR CATCHING BUGS:</span>
            <span class="k">assert</span> <span class="n">p2</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span><span class="o">==</span><span class="n">tri2</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
            <span class="c1"># We don&#39;t have to worry about changing gluings on edge (v2+2)%3 of the triangles with label l2</span>
            <span class="c1"># We do have to worry about the following edge:</span>
            <span class="n">new_glue_e2</span><span class="o">=</span><span class="mi">3</span><span class="o">-</span><span class="n">diagonal_glue_e2</span><span class="o">-</span><span class="n">temp</span> <span class="c1"># returns the edge which is neither diagonal_glue_e2 nor temp.</span>
            <span class="c1"># This corresponded to the following old edge:</span>
            <span class="n">old_e2</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">-</span> <span class="n">e2</span> <span class="o">-</span> <span class="n">temp</span> <span class="c1"># Again this finds the edge which is neither e2 nor temp</span>

        <span class="c1"># remember the old gluings.</span>
        <span class="n">old_opposite1</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">old_e1</span><span class="p">)</span>
        <span class="n">old_opposite2</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span> <span class="n">old_e2</span><span class="p">)</span>

        <span class="c1"># We make changes to the underlying surface</span>
        <span class="n">us</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">underlying_surface</span><span class="p">()</span>

        <span class="c1"># Replace the triangles.</span>
        <span class="n">us</span><span class="o">.</span><span class="n">change_polygon</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">tri1</span><span class="p">)</span>
        <span class="n">us</span><span class="o">.</span><span class="n">change_polygon</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span><span class="n">tri2</span><span class="p">)</span>
        <span class="c1"># Glue along the new diagonal of the quadrilateral</span>
        <span class="n">us</span><span class="o">.</span><span class="n">change_edge_gluing</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">diagonal_glue_e1</span><span class="p">,</span>
                             <span class="n">l2</span><span class="p">,</span><span class="n">diagonal_glue_e2</span><span class="p">)</span>
        <span class="c1"># Now we deal with that pair of opposite edges of the quadrilateral that need regluing.</span>
        <span class="c1"># There are some special cases:</span>
        <span class="k">if</span> <span class="n">old_opposite1</span><span class="o">==</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span><span class="n">old_e2</span><span class="p">):</span>
            <span class="c1"># These opposite edges were glued to each other.</span>
            <span class="c1"># Do the same in the new surface:</span>
            <span class="n">us</span><span class="o">.</span><span class="n">change_edge_gluing</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">new_glue_e1</span><span class="p">,</span>
                                 <span class="n">l2</span><span class="p">,</span><span class="n">new_glue_e2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">old_opposite1</span><span class="o">==</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">old_e1</span><span class="p">):</span>
                <span class="c1"># That edge was &quot;self-glued&quot;.</span>
                <span class="n">us</span><span class="o">.</span><span class="n">change_edge_gluing</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span><span class="n">new_glue_e2</span><span class="p">,</span>
                                     <span class="n">l2</span><span class="p">,</span><span class="n">new_glue_e2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># The edge (l1,old_e1) was glued in a standard way.</span>
                <span class="c1"># That edge now corresponds to (l2,new_glue_e2):</span>
                <span class="n">us</span><span class="o">.</span><span class="n">change_edge_gluing</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span><span class="n">new_glue_e2</span><span class="p">,</span>
                                     <span class="n">old_opposite1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">old_opposite1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">old_opposite2</span><span class="o">==</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span><span class="n">old_e2</span><span class="p">):</span>
                <span class="c1"># That edge was &quot;self-glued&quot;.</span>
                <span class="n">us</span><span class="o">.</span><span class="n">change_edge_gluing</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">new_glue_e1</span><span class="p">,</span>
                                     <span class="n">l1</span><span class="p">,</span><span class="n">new_glue_e1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># The edge (l2,old_e2) was glued in a standard way.</span>
                <span class="c1"># That edge now corresponds to (l1,new_glue_e1):</span>
                <span class="n">us</span><span class="o">.</span><span class="n">change_edge_gluing</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">new_glue_e1</span><span class="p">,</span>
                                     <span class="n">old_opposite2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">old_opposite2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="SimilaritySurface.join_polygons"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.join_polygons">[docs]</a>    <span class="k">def</span> <span class="nf">join_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">test</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Join polygons across the provided edge (p1,e1). By default,</span>
<span class="sd">        it returns the surface obtained by joining the two polygons</span>
<span class="sd">        together. It raises a ValueError if gluing the two polygons</span>
<span class="sd">        together results in a non-convex polygon. This is done to the</span>
<span class="sd">        current surface if in_place is True, and otherwise a mutable</span>
<span class="sd">        copy is made and then modified.</span>

<span class="sd">        If test is True then instead of changing the surface, it just</span>
<span class="sd">        checks to see if the change would be successful and returns</span>
<span class="sd">        True if successful or False if not.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import *</span>
<span class="sd">            sage: ss=translation_surfaces.ward(3)</span>
<span class="sd">            sage: s=ss.copy(mutable=True)</span>
<span class="sd">            sage: s.join_polygons(0,0, in_place=True)</span>
<span class="sd">            TranslationSurface built from 2 polygons</span>
<span class="sd">            sage: print(s.polygon(0))</span>
<span class="sd">            Polygon: (0, 0), (1, -a), (2, 0), (3, a), (2, 2*a), (0, 2*a), (-1, a)</span>
<span class="sd">            sage: s.join_polygons(0,4, in_place=True)</span>
<span class="sd">            TranslationSurface built from 1 polygon</span>
<span class="sd">            sage: print(s.polygon(0))</span>
<span class="sd">            Polygon: (0, 0), (1, -a), (2, 0), (3, a), (2, 2*a), (1, 3*a), (0, 2*a), (-1, a)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">poly1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
        <span class="n">p2</span><span class="p">,</span><span class="n">e2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">e1</span><span class="p">)</span>
        <span class="n">poly2</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">p1</span><span class="o">==</span><span class="n">p2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">test</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t glue polygon to itself.&quot;</span><span class="p">)</span>
        <span class="n">t</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_transformation</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span>
        <span class="n">dt</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">derivative</span><span class="p">()</span>
        <span class="n">vs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">edge_map</span><span class="o">=</span><span class="p">{}</span> <span class="c1"># Store the pairs for the old edges.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">e1</span><span class="p">):</span>
            <span class="n">edge_map</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">vs</span><span class="p">)]</span><span class="o">=</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="n">vs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="n">ne</span><span class="o">=</span><span class="n">poly2</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">ne</span><span class="p">):</span>
            <span class="n">ee</span><span class="o">=</span><span class="p">(</span><span class="n">e2</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="n">ne</span>
            <span class="n">edge_map</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">vs</span><span class="p">)]</span><span class="o">=</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span><span class="n">ee</span><span class="p">)</span>
            <span class="n">vs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dt</span> <span class="o">*</span> <span class="n">poly2</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span> <span class="n">ee</span> <span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">e1</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">poly1</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()):</span>
            <span class="n">edge_map</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">vs</span><span class="p">)]</span><span class="o">=</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="n">vs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">new_polygon</span> <span class="o">=</span> <span class="n">ConvexPolygons</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">())(</span><span class="n">vs</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">test</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Joining polygons along this edge results in a non-convex polygon.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">test</span><span class="p">:</span>
            <span class="c1"># Gluing would be successful</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># Now no longer testing. Do the gluing.</span>
        <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="n">ss</span><span class="o">=</span><span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ss</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">s</span><span class="o">=</span><span class="n">ss</span><span class="o">.</span><span class="n">underlying_surface</span><span class="p">()</span>

        <span class="n">inv_edge_map</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">edge_map</span><span class="p">):</span>
            <span class="n">inv_edge_map</span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">key</span><span class="p">)</span>

        <span class="n">glue_list</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vs</span><span class="p">)):</span>
            <span class="n">p3</span><span class="p">,</span><span class="n">e3</span> <span class="o">=</span> <span class="n">edge_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">p4</span><span class="p">,</span><span class="n">e4</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">p3</span><span class="p">,</span><span class="n">e3</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">p4</span> <span class="o">==</span> <span class="n">p1</span> <span class="ow">or</span> <span class="n">p4</span> <span class="o">==</span> <span class="n">p2</span><span class="p">:</span>
                <span class="n">glue_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inv_edge_map</span><span class="p">[(</span><span class="n">p4</span><span class="p">,</span><span class="n">e4</span><span class="p">)])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">glue_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">p4</span><span class="p">,</span><span class="n">e4</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">base_label</span><span class="p">()</span><span class="o">==</span><span class="n">p2</span><span class="p">:</span>
             <span class="n">s</span><span class="o">.</span><span class="n">change_base_label</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>

        <span class="n">s</span><span class="o">.</span><span class="n">remove_polygon</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>

        <span class="n">s</span><span class="o">.</span><span class="n">change_polygon</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">new_polygon</span><span class="p">,</span> <span class="n">glue_list</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ss</span></div>

<div class="viewcode-block" id="SimilaritySurface.subdivide_polygon"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.subdivide_polygon">[docs]</a>    <span class="k">def</span> <span class="nf">subdivide_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">test</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">new_label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cut the polygon with label p along the diagonal joining vertex</span>
<span class="sd">        v1 to vertex v2. This cuts p into two polygons, one will keep the same</span>
<span class="sd">        label. The other will get a new label, which can be provided</span>
<span class="sd">        via new_label. Otherwise a default new label will be provided.</span>
<span class="sd">        If test=False, then the surface will be changed (in place). If</span>
<span class="sd">        test=True, then it just checks to see if the change would be successful</span>

<span class="sd">        The convention is that the resulting subdivided polygon which has an oriented</span>
<span class="sd">        edge going from the original vertex v1 to vertex v2 will keep the label p.</span>
<span class="sd">        The other polygon will get a new label.</span>

<span class="sd">        The change will be done in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">poly</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">ne</span><span class="o">=</span><span class="n">poly</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">v1</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">v2</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">v1</span><span class="o">&gt;=</span><span class="n">ne</span> <span class="ow">or</span> <span class="n">v2</span><span class="o">&gt;=</span><span class="n">ne</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">test</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provided vertices out of bounds.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">v1</span><span class="o">-</span><span class="n">v2</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">1</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">v1</span><span class="o">-</span><span class="n">v2</span><span class="p">)</span><span class="o">&gt;=</span><span class="n">ne</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">test</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provided diagonal is not actually a diagonal.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">v2</span><span class="o">&lt;</span><span class="n">v1</span><span class="p">:</span>
            <span class="n">v2</span><span class="o">=</span><span class="n">v2</span><span class="o">+</span><span class="n">ne</span>

        <span class="n">newedges1</span><span class="o">=</span><span class="p">[</span><span class="n">poly</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span><span class="o">-</span><span class="n">poly</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">v1</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v1</span><span class="o">+</span><span class="n">ne</span><span class="p">):</span>
            <span class="n">newedges1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="n">newpoly1</span> <span class="o">=</span> <span class="n">ConvexPolygons</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">())(</span><span class="n">newedges1</span><span class="p">)</span>

        <span class="n">newedges2</span><span class="o">=</span><span class="p">[</span><span class="n">poly</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span><span class="o">-</span><span class="n">poly</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">v2</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">):</span>
            <span class="n">newedges2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="n">newpoly2</span> <span class="o">=</span> <span class="n">ConvexPolygons</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">())(</span><span class="n">newedges2</span><span class="p">)</span>

        <span class="c1"># Store the old gluings</span>
        <span class="n">old_gluings</span> <span class="o">=</span> <span class="p">{(</span><span class="n">p</span><span class="p">,</span><span class="n">i</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ne</span><span class="p">)}</span>

        <span class="c1"># Update the polygon with label p, add a new polygon.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">underlying_surface</span><span class="p">()</span><span class="o">.</span><span class="n">change_polygon</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">newpoly1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">underlying_surface</span><span class="p">()</span><span class="o">.</span><span class="n">add_polygon</span><span class="p">(</span><span class="n">newpoly2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">underlying_surface</span><span class="p">()</span><span class="o">.</span><span class="n">add_polygon</span><span class="p">(</span><span class="n">newpoly2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">new_label</span><span class="p">)</span>
        <span class="c1"># This gluing is the diagonal we used.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">underlying_surface</span><span class="p">()</span><span class="o">.</span><span class="n">change_edge_gluing</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">new_label</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Setup conversion from old to new labels.</span>
        <span class="n">old_to_new_labels</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
            <span class="n">old_to_new_labels</span><span class="p">[(</span><span class="n">p</span><span class="p">,</span><span class="n">i</span><span class="o">%</span><span class="n">ne</span><span class="p">)]</span><span class="o">=</span><span class="p">(</span><span class="n">new_label</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="n">v1</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">ne</span><span class="o">+</span><span class="n">v1</span><span class="p">):</span>
            <span class="n">old_to_new_labels</span><span class="p">[(</span><span class="n">p</span><span class="p">,</span><span class="n">i</span><span class="o">%</span><span class="n">ne</span><span class="p">)]</span><span class="o">=</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="n">v2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">newpoly1</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()):</span>
            <span class="n">pair</span> <span class="o">=</span> <span class="n">old_gluings</span><span class="p">[(</span><span class="n">p</span><span class="p">,(</span><span class="n">v2</span><span class="o">+</span><span class="n">e</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">ne</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">old_to_new_labels</span><span class="p">:</span>
                <span class="n">pair</span> <span class="o">=</span> <span class="n">old_to_new_labels</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">underlying_surface</span><span class="p">()</span><span class="o">.</span><span class="n">change_edge_gluing</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">newpoly2</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()):</span>
            <span class="n">pair</span> <span class="o">=</span> <span class="n">old_gluings</span><span class="p">[(</span><span class="n">p</span><span class="p">,(</span><span class="n">v1</span><span class="o">+</span><span class="n">e</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">ne</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">old_to_new_labels</span><span class="p">:</span>
                <span class="n">pair</span> <span class="o">=</span> <span class="n">old_to_new_labels</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">underlying_surface</span><span class="p">()</span><span class="o">.</span><span class="n">change_edge_gluing</span><span class="p">(</span><span class="n">new_label</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="SimilaritySurface.singularity"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.singularity">[docs]</a>    <span class="k">def</span> <span class="nf">singularity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Represents the Singularity associated to the v-th vertex of the polygon with</span>
<span class="sd">        label l.</span>

<span class="sd">        If the surface is infinite, the limit needs to be set. In this case the construction</span>
<span class="sd">        of the singularity is successful if the sequence of vertices hit by passing through</span>
<span class="sd">        edges closes up in limit or less steps.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import *</span>
<span class="sd">            sage: s = translation_surfaces.square_torus()</span>
<span class="sd">            sage: pc = s.minimal_cover(cover_type=&quot;planar&quot;)</span>
<span class="sd">            sage: pc.singularity(pc.base_label(),0)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: need a limit when working with an infinite surface</span>
<span class="sd">            sage: pc.singularity(pc.base_label(),0,limit=4)</span>
<span class="sd">            singularity with vertex equivalence class frozenset(...)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Singularity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">limit</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimilaritySurface.point"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.point">[docs]</a>    <span class="k">def</span> <span class="nf">point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">ring</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a point in this surface.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``label`` - label of the polygon</span>

<span class="sd">        - ``point`` - coordinates of the point inside the polygon</span>

<span class="sd">        - ``ring`` (optional) - a ring for the coordinates</span>

<span class="sd">        - ``limit`` (optional) - undocumented (only necessary if the point corresponds</span>
<span class="sd">          to a singularity in an infinite surface)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import *</span>
<span class="sd">            sage: s = translation_surfaces.square_torus()</span>
<span class="sd">            sage: pc = s.minimal_cover(cover_type=&quot;planar&quot;)</span>
<span class="sd">            sage: pc.surface_point(pc.base_label(),(0,0))</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: need a limit when working with an infinite surface</span>
<span class="sd">            sage: pc.surface_point(pc.base_label(),(1,0),limit=4)</span>
<span class="sd">            Surface point with 4 coordinate representations</span>
<span class="sd">            sage: z = pc.surface_point(pc.base_label(),(sqrt(2)-1,sqrt(3)-1),ring=AA)</span>
<span class="sd">            sage: next(iter(z.coordinates(z.labels()[0]))).parent()</span>
<span class="sd">            Vector space of dimension 2 over Algebraic Real Field</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SurfacePoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">ring</span><span class="o">=</span><span class="n">ring</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span></div>

    <span class="c1"># TODO: deprecate</span>
    <span class="n">surface_point</span> <span class="o">=</span> <span class="n">point</span>

<div class="viewcode-block" id="SimilaritySurface.ramified_cover"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.ramified_cover">[docs]</a>    <span class="k">def</span> <span class="nf">ramified_cover</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a ramified cover of this surface with given ``degree`` and ramification ``data``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``degree`` (integer) -- the degree of the cover</span>

<span class="sd">        - ``data`` -- dictionary that associates a pair ``(polygon_label, edge_number)`` a permutation</span>
<span class="sd">          of ``{1, 2, ..., d}``</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The L-shape origami::</span>

<span class="sd">            sage: import flatsurf</span>
<span class="sd">            sage: T = flatsurf.translation_surfaces.square_torus()</span>
<span class="sd">            sage: T.ramified_cover(3, {(0,0): &#39;(1,2)&#39;, (0,1): &#39;(1,3)&#39;})</span>
<span class="sd">            TranslationSurface built from 3 polygons</span>
<span class="sd">            sage: O = T.ramified_cover(3, {(0,0): &#39;(1,2)&#39;, (0,1): &#39;(1,3)&#39;})</span>
<span class="sd">            sage: O.stratum()</span>
<span class="sd">            H_2(2)</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: import flatsurf</span>
<span class="sd">            sage: T = flatsurf.translation_surfaces.square_torus()</span>
<span class="sd">            sage: T.ramified_cover(3, {(0,0): &#39;(1,2)&#39;, (0,2): &#39;(1,3)&#39;})</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: inconsistent covering data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;this method is only available for finite surfaces&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">ramified_cover</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span></div>

<div class="viewcode-block" id="SimilaritySurface.minimal_cover"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.minimal_cover">[docs]</a>    <span class="k">def</span> <span class="nf">minimal_cover</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cover_type</span> <span class="o">=</span> <span class="s2">&quot;translation&quot;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the minimal translation or half-translation cover of the surface.</span>

<span class="sd">        Cover type may be either &quot;translation&quot;, &quot;half-translation&quot; or &quot;planar&quot;.</span>

<span class="sd">        The minimal planar cover of a surface S is the smallest cover C so that</span>
<span class="sd">        the developing map from the universal cover U to the plane induces a</span>
<span class="sd">        well defined map from C to the plane. This is an infinite translation</span>
<span class="sd">        surface that is naturally a branched cover of the plane.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf.geometry.surface import Surface_list</span>
<span class="sd">            sage: s = Surface_list(QQ)</span>
<span class="sd">            sage: from flatsurf.geometry.polygon import polygons</span>
<span class="sd">            sage: square = polygons.square(field=QQ)</span>
<span class="sd">            sage: s.add_polygon(square)</span>
<span class="sd">            0</span>
<span class="sd">            sage: s.change_edge_gluing(0,0,0,1)</span>
<span class="sd">            sage: s.change_edge_gluing(0,2,0,3)</span>
<span class="sd">            sage: from flatsurf.geometry.cone_surface import ConeSurface</span>
<span class="sd">            sage: cs = ConeSurface(s)</span>
<span class="sd">            sage: ts = cs.minimal_cover(cover_type=&quot;translation&quot;)</span>
<span class="sd">            sage: ts</span>
<span class="sd">            TranslationSurface built from 4 polygons</span>
<span class="sd">            sage: hts = cs.minimal_cover(cover_type=&quot;half-translation&quot;)</span>
<span class="sd">            sage: hts</span>
<span class="sd">            HalfTranslationSurface built from 2 polygons</span>
<span class="sd">            sage: TestSuite(hts).run()</span>
<span class="sd">            sage: ps = cs.minimal_cover(cover_type=&quot;planar&quot;)</span>
<span class="sd">            sage: ps</span>
<span class="sd">            TranslationSurface built from infinitely many polygons</span>
<span class="sd">            sage: TestSuite(ps).run(skip=&quot;_test_pickling&quot;)</span>

<span class="sd">            sage: from flatsurf import similarity_surfaces</span>
<span class="sd">            sage: S = similarity_surfaces.example()</span>
<span class="sd">            sage: T = S.minimal_cover(cover_type=&quot;translation&quot;)</span>
<span class="sd">            sage: T</span>
<span class="sd">            TranslationSurface built from infinitely many polygons</span>
<span class="sd">            sage: T.polygon(T.base_label())</span>
<span class="sd">            Polygon: (0, 0), (2, -2), (2, 0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cover_type</span> <span class="o">==</span> <span class="s2">&quot;translation&quot;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">flatsurf.geometry.translation_surface</span> <span class="kn">import</span> <span class="n">TranslationSurface</span>
            <span class="kn">from</span> <span class="nn">flatsurf.geometry.minimal_cover</span> <span class="kn">import</span> <span class="n">MinimalTranslationCover</span>
            <span class="k">return</span> <span class="n">TranslationSurface</span><span class="p">(</span><span class="n">MinimalTranslationCover</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">cover_type</span> <span class="o">==</span> <span class="s2">&quot;half-translation&quot;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">flatsurf.geometry.half_translation_surface</span> <span class="kn">import</span> <span class="n">HalfTranslationSurface</span>
            <span class="kn">from</span> <span class="nn">flatsurf.geometry.minimal_cover</span> <span class="kn">import</span> <span class="n">MinimalHalfTranslationCover</span>
            <span class="k">return</span> <span class="n">HalfTranslationSurface</span><span class="p">(</span><span class="n">MinimalHalfTranslationCover</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">cover_type</span> <span class="o">==</span> <span class="s2">&quot;planar&quot;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">flatsurf.geometry.translation_surface</span> <span class="kn">import</span> <span class="n">TranslationSurface</span>
            <span class="kn">from</span> <span class="nn">flatsurf.geometry.minimal_cover</span> <span class="kn">import</span> <span class="n">MinimalPlanarCover</span>
            <span class="k">return</span> <span class="n">TranslationSurface</span><span class="p">(</span><span class="n">MinimalPlanarCover</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Provided cover_type is not supported.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimilaritySurface.minimal_translation_cover"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.minimal_translation_cover">[docs]</a>    <span class="k">def</span> <span class="nf">minimal_translation_cover</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the minimal translation cover.</span>

<span class="sd">        &quot;Be careful that if the surface is not built from one polygon, this is</span>
<span class="sd">        not the smallest translation cover of the surface.&quot; - Vincent</span>

<span class="sd">        &quot;I disagree with the prior statement. Can you provide an example?&quot; -Pat</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.misc.superseded</span> <span class="kn">import</span> <span class="n">deprecation</span>
        <span class="n">deprecation</span><span class="p">(</span><span class="mi">13109</span><span class="p">,</span> <span class="s2">&quot;minimal_translation_cover is deprecated. Use minimal_cover(cover_type = </span><span class="se">\&quot;</span><span class="s2">translation</span><span class="se">\&quot;</span><span class="s2">) instead.&quot;</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">flatsurf.geometry.translation_surface</span> <span class="kn">import</span> <span class="n">MinimalTranslationCover</span><span class="p">,</span> <span class="n">TranslationSurface</span>
        <span class="k">return</span> <span class="n">TranslationSurface</span><span class="p">(</span><span class="n">MinimalTranslationCover</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>

<div class="viewcode-block" id="SimilaritySurface.vector_space"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.vector_space">[docs]</a>    <span class="k">def</span> <span class="nf">vector_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the vector space in which self naturally embeds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.modules.free_module</span> <span class="kn">import</span> <span class="n">VectorSpace</span>
        <span class="k">return</span> <span class="n">VectorSpace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">(),</span> <span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimilaritySurface.fundamental_group"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.fundamental_group">[docs]</a>    <span class="k">def</span> <span class="nf">fundamental_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the fundamental group of this surface.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the method only work for finite surfaces&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">base_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">base_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_label</span><span class="p">()</span>
        <span class="kn">from</span> <span class="nn">.fundamental_group</span> <span class="kn">import</span> <span class="n">FundamentalGroup</span>
        <span class="k">return</span> <span class="n">FundamentalGroup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_label</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimilaritySurface.tangent_bundle"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.tangent_bundle">[docs]</a>    <span class="k">def</span> <span class="nf">tangent_bundle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the tangent bundle</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``ring`` -- an optional field (defaults to the coordinate field of the</span>
<span class="sd">          surface)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ring</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ring</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tangent_bundle_cache</span><span class="p">[</span><span class="n">ring</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tangent_bundle_cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="kn">from</span> <span class="nn">.tangent_bundle</span> <span class="kn">import</span> <span class="n">SimilaritySurfaceTangentBundle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tangent_bundle_cache</span><span class="p">[</span><span class="n">ring</span><span class="p">]</span> <span class="o">=</span> <span class="n">SimilaritySurfaceTangentBundle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tangent_bundle_cache</span><span class="p">[</span><span class="n">ring</span><span class="p">]</span></div>

<div class="viewcode-block" id="SimilaritySurface.tangent_vector"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.tangent_vector">[docs]</a>    <span class="k">def</span> <span class="nf">tangent_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lab</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">ring</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a tangent vector.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``lab`` -- label of a polygon</span>

<span class="sd">        - ``p`` -- coordinates of a point in the polygon</span>

<span class="sd">        - ``v`` -- coordinates of a vector in R^2</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf.geometry.chamanara import chamanara_surface</span>
<span class="sd">            sage: S = chamanara_surface(1/2)</span>
<span class="sd">            sage: S.tangent_vector(S.base_label(), (1/2,1/2), (1,1))</span>
<span class="sd">            SimilaritySurfaceTangentVector in polygon (1, -1, 0) based at (1/2, -3/2) with vector (1, 1)</span>
<span class="sd">            sage: K.&lt;sqrt2&gt; = QuadraticField(2)</span>
<span class="sd">            sage: S.tangent_vector(S.base_label(), (1/2,1/2), (1,sqrt2), ring=K)</span>
<span class="sd">            SimilaritySurfaceTangentVector in polygon (1, -1, 0) based at (1/2, -3/2) with vector (1, sqrt2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">v</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;p (=</span><span class="si">{!r}</span><span class="s2">) and v (={!v}) should have two coordinates&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ring</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ring</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tangent_bundle</span><span class="p">(</span><span class="n">ring</span><span class="p">)(</span><span class="n">lab</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Use the ring=??? option to construct tangent vectors in other field different from the base_ring().&quot;</span><span class="p">)</span>
            <span class="c1"># Old version seemed to be to accepting of inputs (eg, from Symbolic Ring)</span>
            <span class="c1">#R = p.base_ring()</span>
            <span class="c1">#if R != v.base_ring():</span>
            <span class="c1">#    from sage.structure.element import get_coercion_model</span>
            <span class="c1">#    cm = get_coercion_model()</span>
            <span class="c1">#    R = cm.common_parent(R, v.base_ring())</span>
            <span class="c1">#    p = p.change_ring(R)</span>
            <span class="c1">#    v = v.change_ring(R)</span>

            <span class="c1">#R2 = self.base_ring()</span>
            <span class="c1">#if R != R2:</span>
            <span class="c1">#    if R2.has_coerce_map_from(R):</span>
            <span class="c1">#        p = p.change_ring(R2)</span>
            <span class="c1">#        v = v.change_ring(R2)</span>
            <span class="c1">#        R = R2</span>
            <span class="c1">#    elif not R.has_coerce_map_from(R2):</span>
            <span class="c1">#        raise ValueError(&quot;not able to find a common ring for arguments&quot;)</span>
            <span class="c1">#return self.tangent_bundle(R)(lab, p, v)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tangent_bundle</span><span class="p">(</span><span class="n">ring</span><span class="p">)(</span><span class="n">lab</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimilaritySurface.reposition_polygons"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.reposition_polygons">[docs]</a>    <span class="k">def</span> <span class="nf">reposition_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">relabel</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        We choose a maximal tree in the dual graph of the decomposition into</span>
<span class="sd">        polygons, and ensure that the gluings between two polygons joined by</span>
<span class="sd">        an edge in this tree is by translation.</span>

<span class="sd">        This guarantees that the group generated by the edge identifications is</span>
<span class="sd">        minimal among representions of the surface. In particular, if for instance</span>
<span class="sd">        you have a translation surface which is anot representable as a translation</span>
<span class="sd">        surface (because polygons are presented with rotations) then after this</span>
<span class="sd">        change it will be representable as a translation surface.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Only implemented for finite surfaces.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;reposition_polygons in_place is only available &quot;</span><span class="o">+</span>\
                    <span class="s2">&quot;for mutable surfaces.&quot;</span><span class="p">)</span>
            <span class="n">s</span><span class="o">=</span><span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">relabel</span><span class="o">=</span><span class="n">relabel</span><span class="p">,</span> <span class="n">mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">w</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">walker</span><span class="p">()</span>
        <span class="kn">from</span> <span class="nn">flatsurf.geometry.similarity</span> <span class="kn">import</span> <span class="n">SimilarityGroup</span>
        <span class="n">S</span><span class="o">=</span><span class="n">SimilarityGroup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">())</span>
        <span class="n">identity</span><span class="o">=</span><span class="n">S</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
        <span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">label</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
        <span class="n">changes</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span><span class="n">identity</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">edge_back</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="n">label2</span><span class="p">,</span><span class="n">edge2</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span>
            <span class="n">changes</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">changes</span><span class="p">[</span><span class="n">label2</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span><span class="o">.</span><span class="n">edge_transformation</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">edge</span><span class="p">)</span>
        <span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="c1"># Skip the base label:</span>
        <span class="n">label</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">changes</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">derivative</span><span class="p">()</span><span class="o">*</span><span class="n">p</span>
            <span class="n">s</span><span class="o">.</span><span class="n">underlying_surface</span><span class="p">()</span><span class="o">.</span><span class="n">change_polygon</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">p</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="SimilaritySurface.triangulation_mapping"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.triangulation_mapping">[docs]</a>    <span class="k">def</span> <span class="nf">triangulation_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a SurfaceMapping triangulating the suface or None if the surface is already triangulated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">flatsurf.geometry.mappings</span> <span class="kn">import</span> <span class="n">triangulation_mapping</span>
        <span class="k">return</span> <span class="n">triangulation_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimilaritySurface.triangulate"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.triangulate">[docs]</a>    <span class="k">def</span> <span class="nf">triangulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">relabel</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a triangulated version of this surface. (This may be mutable</span>
<span class="sd">        or not depending on the input.)</span>

<span class="sd">        If label=None (as default) all polygons are triangulated. Otherwise,</span>
<span class="sd">        label should be a polygon label. In this case, just this polygon</span>
<span class="sd">        is split into triangles.</span>

<span class="sd">        This is done in place if in_place is True (defaults to False).</span>

<span class="sd">        If we are not doing triangulation in_place, then we must make a copy.</span>
<span class="sd">        This can be a relabeled copy (indexed by the non-negative ints)</span>
<span class="sd">        or a label preserving copy. The copy is relabeled if relabel=True</span>
<span class="sd">        (default False).</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import *</span>
<span class="sd">            sage: s=translation_surfaces.mcmullen_L(1,1,1,1)</span>
<span class="sd">            sage: ss=s.triangulate()</span>
<span class="sd">            sage: gs=ss.graphical_surface()</span>
<span class="sd">            sage: gs.make_all_visible()</span>
<span class="sd">            sage: print(gs)</span>
<span class="sd">            Graphical version of Similarity Surface TranslationSurface built from 6 polygons</span>

<span class="sd">        A non-strictly convex example that caused trouble:</span>

<span class="sd">            sage: from flatsurf import *</span>
<span class="sd">            sage: s=similarity_surfaces.self_glued_polygon(polygons(edges=[(1,1),(-3,-1),(1,0),(1,0)]))</span>
<span class="sd">            sage: s=s.triangulate()</span>
<span class="sd">            sage: s.polygon(0).num_edges()</span>
<span class="sd">            3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># We triangulate the whole surface</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
                <span class="c1"># Store the current labels.</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">label</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_iterator</span><span class="p">()]</span>
                <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
                    <span class="n">s</span><span class="o">=</span><span class="bp">self</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">s</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="c1"># Subdivide each polygon in turn.</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">triangulate</span><span class="p">(</span><span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">l</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">s</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You can&#39;t triangulate an infinite surface in place.&quot;</span><span class="p">)</span>
                <span class="kn">from</span> <span class="nn">flatsurf.geometry.delaunay</span> <span class="kn">import</span> <span class="n">LazyTriangulatedSurface</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">LazyTriangulatedSurface</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">poly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="n">n</span><span class="o">=</span><span class="n">poly</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
                    <span class="n">s</span><span class="o">=</span><span class="bp">self</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">s</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># This polygon is already a triangle.</span>
                <span class="k">return</span> <span class="bp">self</span>
            <span class="kn">from</span> <span class="nn">flatsurf.geometry.polygon</span> <span class="kn">import</span> <span class="n">wedge_product</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">poly</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                <span class="n">n</span><span class="o">=</span><span class="n">poly</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">e1</span><span class="o">=</span><span class="n">poly</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">e2</span><span class="o">=</span><span class="n">poly</span><span class="o">.</span><span class="n">edge</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">n</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">wedge_product</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span><span class="n">e2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># This is in case the polygon is a triangle with subdivided edge.</span>
                        <span class="n">e3</span><span class="o">=</span><span class="n">poly</span><span class="o">.</span><span class="n">edge</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="n">n</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">wedge_product</span><span class="p">(</span><span class="n">e1</span><span class="o">+</span><span class="n">e2</span><span class="p">,</span><span class="n">e3</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">s</span><span class="o">.</span><span class="n">subdivide_polygon</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">i</span><span class="p">,(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="n">n</span><span class="p">)</span>
                            <span class="k">break</span>
            <span class="k">return</span> <span class="n">s</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Failed to return anything!&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_edge_needs_flip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">p1</span><span class="p">,</span><span class="n">e1</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns -1 if the the provided edge incident to two triangles which</span>
<span class="sd">        should be flipped to get closer to the Delaunay decomposition.</span>
<span class="sd">        Returns 0 if the quadrilateral formed by the triangles is inscribed</span>
<span class="sd">        in a circle, and returns 1 otherwise.</span>

<span class="sd">        A ValueError is raised if the edge is not indident to two triangles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p2</span><span class="p">,</span><span class="n">e2</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">e1</span><span class="p">)</span>
        <span class="n">poly1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
        <span class="n">poly2</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">poly1</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span><span class="o">!=</span><span class="mi">3</span> <span class="ow">or</span> <span class="n">poly2</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span><span class="o">!=</span><span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Edge must be adjacent to two triangles.&quot;</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">flatsurf.geometry.matrix_2x2</span> <span class="kn">import</span> <span class="n">similarity_from_vectors</span>
        <span class="n">sim1</span><span class="o">=</span><span class="n">similarity_from_vectors</span><span class="p">(</span><span class="n">poly1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">e1</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span><span class="o">-</span><span class="n">poly1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">e1</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">sim2</span><span class="o">=</span><span class="n">similarity_from_vectors</span><span class="p">(</span><span class="n">poly2</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">e2</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span><span class="o">-</span><span class="n">poly2</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">e2</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">sim</span><span class="o">=</span><span class="n">sim1</span><span class="o">*</span><span class="n">sim2</span>
        <span class="k">return</span> <span class="n">sim</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_edge_needs_join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">p1</span><span class="p">,</span><span class="n">e1</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns -1 if the the provided edge incident to two triangles which</span>
<span class="sd">        should be flipped to get closer to the Delaunay decomposition.</span>
<span class="sd">        Returns 0 if the quadrilateral formed by the triangles is inscribed</span>
<span class="sd">        in a circle, and returns 1 otherwise.</span>

<span class="sd">        A ValueError is raised if the edge is not indident to two triangles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p2</span><span class="p">,</span><span class="n">e2</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">e1</span><span class="p">)</span>
        <span class="n">poly1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
        <span class="n">poly2</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">flatsurf.geometry.matrix_2x2</span> <span class="kn">import</span> <span class="n">similarity_from_vectors</span>
        <span class="n">sim1</span><span class="o">=</span><span class="n">similarity_from_vectors</span><span class="p">(</span><span class="n">poly1</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span> <span class="o">-</span> <span class="n">poly1</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">e1</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span>\
            <span class="o">-</span><span class="n">poly1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">e1</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">sim2</span><span class="o">=</span><span class="n">similarity_from_vectors</span><span class="p">(</span><span class="n">poly2</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span> <span class="o">-</span> <span class="n">poly2</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">e2</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span>\
            <span class="o">-</span><span class="n">poly2</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">e2</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">sim</span><span class="o">=</span><span class="n">sim1</span><span class="o">*</span><span class="n">sim2</span>
        <span class="kn">from</span> <span class="nn">sage.functions.generalized</span> <span class="kn">import</span> <span class="n">sgn</span>
        <span class="k">return</span> <span class="n">sim</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span>

<div class="viewcode-block" id="SimilaritySurface.delaunay_single_flip"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.delaunay_single_flip">[docs]</a>    <span class="k">def</span> <span class="nf">delaunay_single_flip</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does a single in place flip of a triangulated mutable surface.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Not implemented for infinite surfaces.&quot;</span><span class="p">)</span>
        <span class="n">lc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label_comparator</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">e1</span><span class="p">),(</span><span class="n">l2</span><span class="p">,</span><span class="n">e2</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">(</span><span class="n">gluings</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">lc</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">l2</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">l1</span><span class="o">==</span><span class="n">l2</span> <span class="ow">and</span> <span class="n">e1</span><span class="o">&lt;=</span><span class="n">e2</span><span class="p">))</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_needs_flip</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">e1</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">triangle_flip</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="SimilaritySurface.is_delaunay_triangulated"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.is_delaunay_triangulated">[docs]</a>    <span class="k">def</span> <span class="nf">is_delaunay_triangulated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return if the surface is triangulated and the triangulation is Delaunay.</span>
<span class="sd">        If limit is set, then it checks this only limit many edges.</span>
<span class="sd">        Limit must be set for infinite surfaces.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;A limit must be set for infinite surfaces.&quot;</span><span class="p">)</span>
            <span class="n">limit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">e1</span><span class="p">),(</span><span class="n">l2</span><span class="p">,</span><span class="n">e2</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">(</span><span class="n">gluings</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="n">limit</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">count</span> <span class="o">=</span>  <span class="n">count</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">l1</span><span class="p">)</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span><span class="o">!=</span><span class="mi">3</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Polygon with label &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">l1</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; is not a triangle.&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">l2</span><span class="p">)</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span><span class="o">!=</span><span class="mi">3</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Polygon with label &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">l2</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; is not a triangle.&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_needs_flip</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">e1</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Edge &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">((</span><span class="n">l1</span><span class="p">,</span><span class="n">e1</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot; needs to be flipped.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This edge is glued to &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">((</span><span class="n">l2</span><span class="p">,</span><span class="n">e2</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="SimilaritySurface.is_delaunay_decomposed"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.is_delaunay_decomposed">[docs]</a>    <span class="k">def</span> <span class="nf">is_delaunay_decomposed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return if the decomposition of the surface into polygons is Delaunay.</span>
<span class="sd">        If limit is set, then it checks this only limit many polygons.</span>
<span class="sd">        Limit must be set for infinite surfaces.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;A limit must be set for infinite surfaces.&quot;</span><span class="p">)</span>
            <span class="n">limit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_polygons</span><span class="p">()</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">p1</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_iterator</span><span class="p">(</span><span class="n">polygons</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">c1</span><span class="o">=</span><span class="n">p1</span><span class="o">.</span><span class="n">circumscribing_circle</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># p1 is not circumscribed</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">e1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()):</span>
                <span class="n">c2</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_transformation</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">e1</span><span class="p">)</span><span class="o">*</span><span class="n">c1</span>
                <span class="n">l2</span><span class="p">,</span><span class="n">e2</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">e1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">c2</span><span class="o">.</span><span class="n">point_position</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">l2</span><span class="p">)</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">e2</span><span class="o">+</span><span class="mi">2</span><span class="p">))</span><span class="o">!=-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># The circumscribed circle developed into the adjacent polygon</span>
                    <span class="c1"># contains a vertex in its interior or boundary.</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="SimilaritySurface.delaunay_triangulation"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.delaunay_triangulation">[docs]</a>    <span class="k">def</span> <span class="nf">delaunay_triangulation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">triangulated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">relabel</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a Delaunay triangulation of a surface, or make some</span>
<span class="sd">        triangle flips to get closer to the Delaunay decomposition.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``triangulated`` (boolean) - If true, the algorithm assumes the</span>
<span class="sd">          surface is already triangulated. It does this without verification.</span>

<span class="sd">        - ``in_place`` (boolean) - If true, the triangulating and the</span>
<span class="sd">          triangle flips are done in place.  Otherwise, a mutable copy of the</span>
<span class="sd">          surface is made.</span>

<span class="sd">        - ``limit`` (None or Integer) - If None, this will return a</span>
<span class="sd">          Delaunay triangulation. If limit is an integer 1 or larger, then at</span>
<span class="sd">          most limit many diagonal flips will be done.</span>

<span class="sd">        - ``direction`` (None or Vector) - with two entries in the base field</span>
<span class="sd">            Used to determine labels when a pair of triangles is flipped. Each triangle</span>
<span class="sd">            has a unique separatrix which points in the provided direction or its</span>
<span class="sd">            negation. As such a vector determines a sign for each triangle.</span>
<span class="sd">            A pair of adjacent triangles have opposite signs. Labels are chosen</span>
<span class="sd">            so that this sign is preserved (as a function of labels).</span>

<span class="sd">        - ``relabel`` (boolean) - If in_place is False, then a copy must be</span>
<span class="sd">          made. By default relabel is False and labels will be respected by</span>
<span class="sd">          this copy. If relabel is True then polygons will be reindexed in an</span>
<span class="sd">          arbitrary way by the non-negative integers.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import *</span>
<span class="sd">            sage: from flatsurf.geometry.delaunay import *</span>

<span class="sd">            sage: m = matrix([[2,1],[1,1]])</span>
<span class="sd">            sage: s = m*translation_surfaces.infinite_staircase()</span>
<span class="sd">            sage: ss = s.delaunay_triangulation(relabel=True)</span>
<span class="sd">            sage: ss.base_label()</span>
<span class="sd">            0</span>
<span class="sd">            sage: ss.polygon(0)</span>
<span class="sd">            Polygon: (0, 0), (1, 1), (0, 1)</span>
<span class="sd">            sage: TestSuite(ss).run(skip=&quot;_test_pickling&quot;)</span>
<span class="sd">            sage: ss.is_delaunay_triangulated(limit=10)</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite</span><span class="p">()</span> <span class="ow">and</span> <span class="n">limit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;in_place delaunay triangulation is not possible for infinite surfaces unless a limit is set.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">underlying_surface</span><span class="p">()</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;delaunay_triangulation only works on infinite &quot;</span><span class="o">+</span>\
                    <span class="s2">&quot;surfaces if they are immutable or if a limit is set.&quot;</span><span class="p">)</span>
            <span class="kn">from</span> <span class="nn">flatsurf.geometry.delaunay</span> <span class="kn">import</span> <span class="n">LazyDelaunayTriangulatedSurface</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">LazyDelaunayTriangulatedSurface</span><span class="p">(</span> \
                <span class="bp">self</span><span class="p">,</span><span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span> <span class="n">relabel</span><span class="o">=</span><span class="n">relabel</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">in_place</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;in_place delaunay_triangulation only defined for mutable surfaces&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">triangulated</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
                <span class="n">s</span><span class="o">=</span><span class="bp">self</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">relabel</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
                <span class="n">s</span><span class="o">=</span><span class="bp">self</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">triangulate</span><span class="p">(</span><span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">relabel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">s</span><span class="o">.</span><span class="n">triangulate</span><span class="p">(</span><span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">loop</span><span class="o">=</span><span class="kc">True</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">base_ring</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>
            <span class="n">direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector_space</span><span class="p">()(</span> <span class="p">(</span><span class="n">base_ring</span><span class="o">.</span><span class="n">zero</span><span class="p">(),</span> <span class="n">base_ring</span><span class="o">.</span><span class="n">one</span><span class="p">())</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">direction</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">is_finite</span><span class="p">()</span> <span class="ow">and</span> <span class="n">limit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
            <span class="n">unchecked_labels</span><span class="o">=</span><span class="n">deque</span><span class="p">(</span><span class="n">label</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">label_iterator</span><span class="p">())</span>
            <span class="n">checked_labels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">while</span> <span class="n">unchecked_labels</span><span class="p">:</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">unchecked_labels</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="n">flipped</span><span class="o">=</span><span class="kc">False</span>
                <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">_edge_needs_flip</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">edge</span><span class="p">):</span>
                        <span class="c1"># Record the current opposite edge:</span>
                        <span class="n">label2</span><span class="p">,</span><span class="n">edge2</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">edge</span><span class="p">)</span>
                        <span class="c1"># Perform the flip.</span>
                        <span class="n">s</span><span class="o">.</span><span class="n">triangle_flip</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">)</span>
                        <span class="c1"># Move the opposite polygon to the list of labels we need to check.</span>
                        <span class="k">if</span> <span class="n">label2</span> <span class="o">!=</span> <span class="n">label</span><span class="p">:</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">checked_labels</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">label2</span><span class="p">)</span>
                                <span class="n">unchecked_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label2</span><span class="p">)</span>
                            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                                <span class="c1"># Occurs if label2 is not in checked_labels</span>
                                <span class="k">pass</span>
                        <span class="n">flipped</span><span class="o">=</span><span class="kc">True</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">flipped</span><span class="p">:</span>
                    <span class="n">unchecked_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">checked_labels</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">s</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Old method for infinite surfaces, or limits.</span>
            <span class="n">count</span><span class="o">=</span><span class="mi">0</span>
            <span class="n">lc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label_comparator</span><span class="p">()</span>
            <span class="k">while</span> <span class="n">loop</span><span class="p">:</span>
                <span class="n">loop</span><span class="o">=</span><span class="kc">False</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">e1</span><span class="p">),(</span><span class="n">l2</span><span class="p">,</span><span class="n">e2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">(</span><span class="n">gluings</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">lc</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">l2</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">l1</span><span class="o">==</span><span class="n">l2</span> <span class="ow">and</span> <span class="n">e1</span><span class="o">&lt;=</span><span class="n">e2</span><span class="p">))</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">_edge_needs_flip</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">e1</span><span class="p">):</span>
                        <span class="n">s</span><span class="o">.</span><span class="n">triangle_flip</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">)</span>
                        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">limit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">count</span><span class="o">&gt;=</span><span class="n">limit</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">s</span>
                        <span class="n">loop</span><span class="o">=</span><span class="kc">True</span>
                        <span class="k">break</span>
            <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="SimilaritySurface.delaunay_single_join"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.delaunay_single_join">[docs]</a>    <span class="k">def</span> <span class="nf">delaunay_single_join</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Not implemented for infinite surfaces.&quot;</span><span class="p">)</span>
        <span class="n">lc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label_comparator</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">e1</span><span class="p">),(</span><span class="n">l2</span><span class="p">,</span><span class="n">e2</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">(</span><span class="n">gluings</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">lc</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">l2</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">l1</span><span class="o">==</span><span class="n">l2</span> <span class="ow">and</span> <span class="n">e1</span><span class="o">&lt;=</span><span class="n">e2</span><span class="p">))</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_needs_join</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">e1</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">join_polygons</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="SimilaritySurface.delaunay_decomposition"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.delaunay_decomposition">[docs]</a>    <span class="k">def</span> <span class="nf">delaunay_decomposition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">triangulated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> \
            <span class="n">delaunay_triangulated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>\
            <span class="n">relabel</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the Delaunay Decomposition of this surface.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``triangulated`` (boolean) - If true, the algorithm assumes the</span>
<span class="sd">          surface is already triangulated. It does this without verification.</span>

<span class="sd">        - ``delaunay_triangulated`` (boolean) - If true, the algorithm assumes</span>
<span class="sd">          the surface is already delaunay_triangulated. It does this without</span>
<span class="sd">          verification.</span>

<span class="sd">        - ``in_place`` (boolean) - If true, the triangulating and the triangle</span>
<span class="sd">          flips are done in place. Otherwise, a mutable copy of the surface is</span>
<span class="sd">          made.</span>

<span class="sd">        - ``relabel`` (None or Integer) - If in_place is False, then a copy</span>
<span class="sd">          must be made of the surface.  If relabel is False (as default), the</span>
<span class="sd">          copy has the same labels as the original surface. Note that in this</span>
<span class="sd">          case, labels will be added if it is necessary to subdivide polygons</span>
<span class="sd">          into triangles.  If relabel is True, the new surface will have</span>
<span class="sd">          polygons labeled by the non-negative integers in an arbitrary way.</span>

<span class="sd">        - ``direction`` - (None or Vector with two entries in the base field) -</span>
<span class="sd">          Used to determine labels when a pair of triangles is flipped. Each triangle</span>
<span class="sd">          has a unique separatrix which points in the provided direction or its</span>
<span class="sd">          negation. As such a vector determines a sign for each triangle.</span>
<span class="sd">          A pair of adjacent triangles have opposite signs. Labels are chosen</span>
<span class="sd">          so that this sign is preserved (as a function of labels).</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import *</span>
<span class="sd">            sage: s0 = translation_surfaces.octagon_and_squares()</span>
<span class="sd">            sage: a = s0.base_ring().gens()[0]</span>
<span class="sd">            sage: m = Matrix([[1,2+a],[0,1]])</span>
<span class="sd">            sage: s = m*s0</span>
<span class="sd">            sage: s = s.triangulate()</span>
<span class="sd">            sage: ss = s.delaunay_decomposition(triangulated=True)</span>
<span class="sd">            sage: ss.num_polygons()</span>
<span class="sd">            3</span>

<span class="sd">            sage: p = polygons((4,0),(-2,1),(-2,-1))</span>
<span class="sd">            sage: s0 = similarity_surfaces.self_glued_polygon(p)</span>
<span class="sd">            sage: s = s0.delaunay_decomposition()</span>
<span class="sd">            sage: TestSuite(s).run()</span>

<span class="sd">            sage: m = matrix([[2,1],[1,1]])</span>
<span class="sd">            sage: s = m*translation_surfaces.infinite_staircase()</span>
<span class="sd">            sage: ss = s.delaunay_decomposition()</span>
<span class="sd">            sage: ss.base_label()</span>
<span class="sd">            0</span>
<span class="sd">            sage: ss.polygon(0)</span>
<span class="sd">            Polygon: (0, 0), (1, 0), (1, 1), (0, 1)</span>
<span class="sd">            sage: TestSuite(ss).run(skip=&quot;_test_pickling&quot;)</span>
<span class="sd">            sage: ss.is_delaunay_decomposed(limit=10)</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;in_place delaunay_decomposition is not possible for infinite surfaces.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">underlying_surface</span><span class="p">()</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;delaunay_decomposition only works on infinite &quot;</span><span class="o">+</span>\
                    <span class="s2">&quot;surfaces if they are immutable.&quot;</span><span class="p">)</span>
            <span class="kn">from</span> <span class="nn">flatsurf.geometry.delaunay</span> <span class="kn">import</span> <span class="n">LazyDelaunaySurface</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">LazyDelaunaySurface</span><span class="p">(</span> \
                <span class="bp">self</span><span class="p">,</span><span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span> <span class="n">relabel</span><span class="o">=</span><span class="n">relabel</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="n">s</span><span class="o">=</span><span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">relabel</span><span class="o">=</span><span class="n">relabel</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">delaunay_triangulated</span><span class="p">:</span>
            <span class="n">s</span><span class="o">.</span><span class="n">delaunay_triangulation</span><span class="p">(</span><span class="n">triangulated</span><span class="o">=</span><span class="n">triangulated</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> \
                <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">)</span>
        <span class="c1"># Now s is Delaunay Triangulated</span>
        <span class="n">loop</span><span class="o">=</span><span class="kc">True</span>
        <span class="n">lc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label_comparator</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">loop</span><span class="p">:</span>
            <span class="n">loop</span><span class="o">=</span><span class="kc">False</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">e1</span><span class="p">),(</span><span class="n">l2</span><span class="p">,</span><span class="n">e2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">(</span><span class="n">gluings</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">lc</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">l2</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">l1</span><span class="o">==</span><span class="n">l2</span> <span class="ow">and</span> <span class="n">e1</span><span class="o">&lt;=</span><span class="n">e2</span><span class="p">))</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">_edge_needs_join</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">e1</span><span class="p">):</span>
                    <span class="n">s</span><span class="o">.</span><span class="n">join_polygons</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">loop</span><span class="o">=</span><span class="kc">True</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="SimilaritySurface.saddle_connections"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.saddle_connections">[docs]</a>    <span class="k">def</span> <span class="nf">saddle_connections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">squared_length_bound</span><span class="p">,</span> <span class="n">initial_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initial_vertex</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sc_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of saddle connections on the surface whose length squared is less than or equal to squared_length_bound.</span>
<span class="sd">        The length of a saddle connection is measured using holonomy from polygon in which the trajectory starts.</span>

<span class="sd">        If initial_label and initial_vertex are not provided, we return all saddle connections satisfying the bound condition.</span>

<span class="sd">        If initial_label and initial_vertex are provided, it only provides saddle connections emanating from the corresponding</span>
<span class="sd">        vertex of a polygon. If only initial_label is provided, the added saddle connections will only emanate from the</span>
<span class="sd">        corresponding polygon.</span>

<span class="sd">        If sc_list is provided the found saddle connections are appended to this list and the resulting list is returned.</span>

<span class="sd">        If check==True it uses the checks in the SaddleConnection class to sanity check our results.</span>

<span class="sd">        EXAMPLES::</span>
<span class="sd">            sage: from flatsurf import *</span>
<span class="sd">            sage: s = translation_surfaces.square_torus()</span>
<span class="sd">            sage: sc_list = s.saddle_connections(13, check=True)</span>
<span class="sd">            sage: len(sc_list)</span>
<span class="sd">            32</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">squared_length_bound</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">sc_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sc_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">initial_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite</span><span class="p">()</span>
            <span class="k">assert</span> <span class="n">initial_vertex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;If initial_label is not provided, then initial_vertex must not be provided either.&quot;</span>
            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_iterator</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">saddle_connections</span><span class="p">(</span><span class="n">squared_length_bound</span><span class="p">,</span> <span class="n">initial_label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">sc_list</span><span class="o">=</span><span class="n">sc_list</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">sc_list</span>
        <span class="k">if</span> <span class="n">initial_vertex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">initial_label</span><span class="p">)</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span> <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">saddle_connections</span><span class="p">(</span><span class="n">squared_length_bound</span><span class="p">,</span> <span class="n">initial_label</span><span class="o">=</span><span class="n">initial_label</span><span class="p">,</span> <span class="n">initial_vertex</span><span class="o">=</span><span class="n">vertex</span><span class="p">,</span> <span class="n">sc_list</span><span class="o">=</span><span class="n">sc_list</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">sc_list</span>

        <span class="c1"># Now we have a specified initial_label and initial_vertex</span>
        <span class="n">SG</span> <span class="o">=</span> <span class="n">SimilarityGroup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">())</span>
        <span class="n">start_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">initial_label</span><span class="p">,</span> <span class="n">initial_vertex</span><span class="p">)</span>
        <span class="n">circle</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vector_space</span><span class="p">()</span><span class="o">.</span><span class="n">zero</span><span class="p">(),</span> <span class="n">squared_length_bound</span><span class="p">,</span> <span class="n">base_ring</span> <span class="o">=</span>   <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">())</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">initial_label</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">initial_vertex</span><span class="p">)</span>
        <span class="n">last_sim</span> <span class="o">=</span> <span class="n">SG</span><span class="p">(</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># First check the edge eminating rightward from the start_vertex.</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">initial_vertex</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">squared_length_bound</span><span class="p">:</span>
            <span class="n">sc_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">SaddleConnection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_data</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="p">)</span>

        <span class="c1"># Represents the bounds of the beam of trajectories we are sending out.</span>
        <span class="n">wedge</span> <span class="o">=</span> <span class="p">(</span> <span class="n">last_sim</span><span class="p">(</span> <span class="n">p</span><span class="o">.</span><span class="n">vertex</span><span class="p">((</span><span class="n">initial_vertex</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">p</span><span class="o">.</span><span class="n">num_edges</span><span class="p">())</span> <span class="p">),</span>
                  <span class="n">last_sim</span><span class="p">(</span> <span class="n">p</span><span class="o">.</span><span class="n">vertex</span><span class="p">((</span><span class="n">initial_vertex</span><span class="o">+</span><span class="n">p</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">p</span><span class="o">.</span><span class="n">num_edges</span><span class="p">())</span> <span class="p">))</span>

        <span class="c1"># This will collect the data we need for a depth first search.</span>
        <span class="n">chain</span> <span class="o">=</span> <span class="p">[(</span><span class="n">last_sim</span><span class="p">,</span> <span class="n">initial_label</span><span class="p">,</span> <span class="n">wedge</span><span class="p">,</span> <span class="p">[(</span><span class="n">initial_vertex</span><span class="o">+</span><span class="n">p</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span><span class="o">-</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="n">p</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">p</span><span class="o">.</span><span class="n">num_edges</span><span class="p">())])]</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Should verts really be edges?</span>
            <span class="n">sim</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">wedge</span><span class="p">,</span> <span class="n">verts</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">chain</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">continue</span>
            <span class="n">vert</span> <span class="o">=</span> <span class="n">verts</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="c1">#print(&quot;Inspecting &quot;+str(vert))</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="c1"># First check the vertex</span>
            <span class="n">vert_position</span> <span class="o">=</span> <span class="n">sim</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">vert</span><span class="p">))</span>
            <span class="c1">#print(wedge[1].n())</span>
            <span class="k">if</span> <span class="n">wedge_product</span><span class="p">(</span><span class="n">wedge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vert_position</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> \
               <span class="n">wedge_product</span><span class="p">(</span><span class="n">vert_position</span><span class="p">,</span> <span class="n">wedge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> \
               <span class="n">vert_position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">vert_position</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">squared_length_bound</span><span class="p">:</span>
                    <span class="n">sc_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">SaddleConnection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_data</span><span class="p">,</span> <span class="n">vert_position</span><span class="p">,</span>
                                                   <span class="n">end_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">vert</span><span class="p">),</span>
                                                   <span class="n">end_direction</span> <span class="o">=</span> <span class="o">~</span><span class="n">sim</span><span class="o">.</span><span class="n">derivative</span><span class="p">()</span><span class="o">*-</span><span class="n">vert_position</span><span class="p">,</span>
                                                   <span class="n">holonomy</span> <span class="o">=</span> <span class="n">vert_position</span><span class="p">,</span>
                                                   <span class="n">end_holonomy</span> <span class="o">=</span> <span class="o">~</span><span class="n">sim</span><span class="o">.</span><span class="n">derivative</span><span class="p">()</span><span class="o">*-</span><span class="n">vert_position</span><span class="p">,</span>
                                                   <span class="n">check</span> <span class="o">=</span> <span class="n">check</span><span class="p">)</span> <span class="p">)</span>
            <span class="c1"># Now check if we should develop across the edge</span>
            <span class="n">vert_position2</span> <span class="o">=</span> <span class="n">sim</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span> <span class="p">(</span><span class="n">vert</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">p</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span> <span class="p">))</span>
            <span class="k">if</span> <span class="n">wedge_product</span><span class="p">(</span><span class="n">vert_position</span><span class="p">,</span><span class="n">vert_position2</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> \
               <span class="n">wedge_product</span><span class="p">(</span><span class="n">wedge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">vert_position2</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> \
               <span class="n">wedge_product</span><span class="p">(</span><span class="n">vert_position</span><span class="p">,</span><span class="n">wedge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> \
               <span class="n">circle</span><span class="o">.</span><span class="n">line_segment_position</span><span class="p">(</span><span class="n">vert_position</span><span class="p">,</span> <span class="n">vert_position2</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">wedge_product</span><span class="p">(</span><span class="n">wedge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vert_position</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># First in new_wedge should be vert_position</span>
                    <span class="k">if</span> <span class="n">wedge_product</span><span class="p">(</span><span class="n">vert_position2</span><span class="p">,</span> <span class="n">wedge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">new_wedge</span> <span class="o">=</span> <span class="p">(</span><span class="n">vert_position</span><span class="p">,</span> <span class="n">vert_position2</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_wedge</span> <span class="o">=</span> <span class="p">(</span><span class="n">vert_position</span><span class="p">,</span> <span class="n">wedge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">wedge_product</span><span class="p">(</span><span class="n">vert_position2</span><span class="p">,</span> <span class="n">wedge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">new_wedge</span> <span class="o">=</span> <span class="p">(</span><span class="n">wedge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vert_position2</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_wedge</span><span class="o">=</span><span class="n">wedge</span>
                <span class="n">new_label</span><span class="p">,</span> <span class="n">new_edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">vert</span><span class="p">)</span>
                <span class="n">new_sim</span> <span class="o">=</span> <span class="n">sim</span><span class="o">*~</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_transformation</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">vert</span><span class="p">)</span>
                <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">new_label</span><span class="p">)</span>
                <span class="n">chain</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">new_sim</span><span class="p">,</span> <span class="n">new_label</span><span class="p">,</span> <span class="n">new_wedge</span><span class="p">,</span> <span class="p">[(</span><span class="n">new_edge</span><span class="o">+</span><span class="n">p</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span><span class="o">-</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="n">p</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">p</span><span class="o">.</span><span class="n">num_edges</span><span class="p">())])</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">sc_list</span></div>

<div class="viewcode-block" id="SimilaritySurface.set_default_graphical_surface"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.set_default_graphical_surface">[docs]</a>    <span class="k">def</span> <span class="nf">set_default_graphical_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graphical_surface</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace the default graphical surface with the provided GraphicalSurface.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">flatsurf.graphical.surface</span> <span class="kn">import</span> <span class="n">GraphicalSurface</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">graphical_surface</span><span class="p">,</span> <span class="n">GraphicalSurface</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;graphical_surface must be a GraphicalSurface&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">!=</span> <span class="n">graphical_surface</span><span class="o">.</span><span class="n">get_surface</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The provided graphical_surface renders a different surface!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gs</span> <span class="o">=</span>  <span class="n">graphical_surface</span></div>

<div class="viewcode-block" id="SimilaritySurface.graphical_surface"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.graphical_surface">[docs]</a>    <span class="k">def</span> <span class="nf">graphical_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a GraphicalSurface representing this surface.</span>

<span class="sd">        By default this returns a cached version of the GraphicalSurface. If</span>
<span class="sd">        ``cached=False`` is provided as a keyword option then a new</span>
<span class="sd">        GraphicalSurface is returned. Other keyword options:</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``cached`` -- a boolean (default ``True``). If true return a cached</span>
<span class="sd">          GraphicalSurface. Otherwise we make a new one.</span>

<span class="sd">        - ``polygon_labels`` -- a boolean (default ``True``) whether the label</span>
<span class="sd">          of polygons are displayed</span>

<span class="sd">        - ``edge_labels`` -- option to control the display of edge labels. It</span>
<span class="sd">          can be one of</span>

<span class="sd">            - ``False`` or ``None`` for no labels</span>

<span class="sd">            - ``&#39;gluings&#39;`` -- to put on each side of each non-adjacent edge, the</span>
<span class="sd">              name of the polygon to which it is glued</span>

<span class="sd">            - ``&#39;number&#39;`` -- to put on each side of each edge the number of the</span>
<span class="sd">              edge</span>

<span class="sd">            - ``&#39;gluings and numbers&#39;`` -- full information</span>

<span class="sd">            - ``&#39;letter&#39;`` -- add matching letters to glued edges in an arbitrary way</span>

<span class="sd">        - ``default_position_function`` -- a function mapping polygon labels to</span>
<span class="sd">          similarities describing the position of the corresponding polygon.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Test the difference between the cached graphical_surface and the uncached version::</span>

<span class="sd">            sage: from flatsurf import *</span>
<span class="sd">            sage: s = translation_surfaces.octagon_and_squares()</span>
<span class="sd">            sage: s.plot()     # not tested (problem with matplotlib font caches on Travis)</span>
<span class="sd">            Graphics object consisting of 32 graphics primitives</span>
<span class="sd">            sage: s.graphical_surface(cached=False,adjacencies=[]).plot()   # not tested (problem with matplotlib font caches on Travis)</span>
<span class="sd">            Graphics object consisting of 18 graphics primitives</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">flatsurf.graphical.surface</span> <span class="kn">import</span> <span class="n">GraphicalSurface</span>
        <span class="k">if</span> <span class="s2">&quot;cached&quot;</span> <span class="ow">in</span> <span class="n">kwds</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">kwds</span><span class="p">[</span><span class="s2">&quot;cached&quot;</span><span class="p">]:</span>
                <span class="c1"># cached=False: return a new surface.</span>
                <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;cached&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">GraphicalSurface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
            <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;cached&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_gs&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gs</span><span class="o">.</span><span class="n">process_options</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gs</span> <span class="o">=</span> <span class="n">GraphicalSurface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gs</span></div>

<div class="viewcode-block" id="SimilaritySurface.plot"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a plot of the surface.</span>

<span class="sd">        There may be zero or one argument. If provided the single argument</span>
<span class="sd">        should be a GraphicalSurface whick will be used in the plot.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``polygon_labels`` -- a boolean (default ``True``) whether the label</span>
<span class="sd">          of polygons are displayed</span>

<span class="sd">        - ``edge_labels`` -- option to control the display of edge labels. It</span>
<span class="sd">          can be one of</span>

<span class="sd">            - ``False`` or ``None`` for no labels</span>

<span class="sd">            - ``&#39;gluings&#39;`` -- to put on each side of each non-adjacent edge, the</span>
<span class="sd">              name of the polygon to which it is glued</span>

<span class="sd">            - ``&#39;number&#39;`` -- to put on each side of each edge the number of the</span>
<span class="sd">              edge</span>

<span class="sd">            - ``&#39;gluings and number&#39;`` -- full information</span>

<span class="sd">        - ``adjacencies`` -- a list of pairs ``(p,e)`` to be used to set</span>
<span class="sd">          adjacencies of polygons.</span>

<span class="sd">        - ``default_position_function`` -- a function mapping polygon labels to</span>
<span class="sd">          similarities describing the position of the corresponding polygon.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;SimilaritySurface.plot() can take at most one non-keyword argument.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">flatsurf.graphical.surface</span> <span class="kn">import</span> <span class="n">GraphicalSurface</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">GraphicalSurface</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If an argument is provided, it must be a GraphicalSurface.&quot;</span><span class="p">)</span>
            <span class="n">gs</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">gs</span><span class="o">.</span><span class="n">process_options</span><span class="p">(</span><span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graphical_surface</span><span class="p">(</span><span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gs</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span></div>

<div class="viewcode-block" id="SimilaritySurface.plot_polygon"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.similarity_surface.SimilaritySurface.plot_polygon">[docs]</a>    <span class="k">def</span> <span class="nf">plot_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">graphical_surface</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">plot_polygon</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">plot_edges</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">plot_edge_labels</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                     <span class="n">edge_labels</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">polygon_options</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;axes&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">},</span> <span class="n">edge_options</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">edge_label_options</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a plot of the polygon with the provided label.</span>

<span class="sd">        Note that this method plots the polygon in its coordinates as opposed to</span>
<span class="sd">        graphical coordinates that the :func:``plot`` method uses. This makes it useful</span>
<span class="sd">        for visualizing the natural coordinates of the polygon.</span>

<span class="sd">        INPUT:</span>

<span class="sd">            - ``graphical_surface`` -- (default ``None``) If provided this function pulls graphical options</span>
<span class="sd">              from the graphical surface. If not provided, we use the default graphical surface.</span>

<span class="sd">            - ``plot_polygon`` -- (default ``True``) If True, we plot the solid polygon.</span>

<span class="sd">            - ``polygon_options`` -- (default ``{&quot;axes&quot;:True}``) Options for the rendering of the polygon.</span>
<span class="sd">              These options will be passed to :func:`~flatsurf.graphical.polygon.GraphicalPolygon.plot_polygon`.</span>
<span class="sd">              This should be either None or a dictionary.</span>

<span class="sd">            - ``plot_edges`` -- (default ``True``) If True, we plot the edges of the polygon as segments.</span>

<span class="sd">            - ``edge_options`` -- (default ``None``) Options for the rendering of the polygon edges.</span>
<span class="sd">              These options will be passed to :func:`~flatsurf.graphical.polygon.GraphicalPolygon.plot_edge`.</span>
<span class="sd">              This should be either None or a dictionary.</span>

<span class="sd">            - ``plot_edge_labels`` -- (default ``True``) If True, we plot labels on the edges.</span>

<span class="sd">            - ``edge_label_options`` -- (default ``None``) Options for the rendering of the edge labels.</span>
<span class="sd">              These options will be passed to :func:`~flatsurf.graphical.polygon.GraphicalPolygon.plot_edge_label`.</span>
<span class="sd">              This should be either None or a dictionary.</span>

<span class="sd">            - ``edge_labels`` -- (default ``None``) If None and plot_edge_labels is True, we write the edge</span>
<span class="sd">              number on each edge. Otherwise edge_labels should be a list of strings of length equal to the</span>
<span class="sd">              number of edges of the polygon. The strings will be printed on each edge.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import *</span>
<span class="sd">            sage: s = similarity_surfaces.example()</span>
<span class="sd">            sage: s.plot() # not tested (problem with matplotlib font caches on Travis)</span>
<span class="sd">            Graphics object consisting of 13 graphics primitives</span>
<span class="sd">            s.plot_polygon(1) # not tested (problem with matplotlib font caches on Travis)</span>
<span class="sd">            Graphics object consisting of 7 graphics primitives</span>

<span class="sd">            sage: labels = []</span>
<span class="sd">            sage: p = s.polygon(1)</span>
<span class="sd">            sage: for e in range(p.num_edges()): \</span>
<span class="sd">                labels.append(str(p.edge(e)))</span>
<span class="sd">            sage: s.plot_polygon(1, polygon_options=None, plot_edges=False, \</span>
<span class="sd">                edge_labels=labels, edge_label_options={&quot;color&quot;:&quot;red&quot;}) # not tested (problem with matplotlib font caches on Travis)</span>
<span class="sd">            Graphics object consisting of 4 graphics primitives</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">graphical_surface</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">graphical_surface</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graphical_surface</span><span class="p">()</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">flatsurf.graphical.polygon</span> <span class="kn">import</span> <span class="n">GraphicalPolygon</span>
        <span class="n">gp</span> <span class="o">=</span> <span class="n">GraphicalPolygon</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_polygon</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">polygon_options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">o</span> <span class="o">=</span> <span class="n">graphical_surface</span><span class="o">.</span><span class="n">polygon_options</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">o</span> <span class="o">=</span> <span class="n">graphical_surface</span><span class="o">.</span><span class="n">polygon_options</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">o</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">polygon_options</span><span class="p">)</span>
            <span class="n">plt</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">plot_polygon</span><span class="p">(</span><span class="o">**</span><span class="n">o</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">edge_options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">o</span> <span class="o">=</span> <span class="n">graphical_surface</span><span class="o">.</span><span class="n">non_adjacent_edge_options</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">o</span> <span class="o">=</span> <span class="n">graphical_surface</span><span class="o">.</span><span class="n">non_adjacent_edge_options</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">o</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">edge_options</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()):</span>
                <span class="n">plt</span> <span class="o">+=</span> <span class="n">gp</span><span class="o">.</span><span class="n">plot_edge</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">**</span><span class="n">o</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_edge_labels</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">edge_label_options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">o</span> <span class="o">=</span> <span class="n">graphical_surface</span><span class="o">.</span><span class="n">edge_label_options</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">o</span> <span class="o">=</span> <span class="n">graphical_surface</span><span class="o">.</span><span class="n">edge_label_options</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">o</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">edge_label_options</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">edge_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">el</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">el</span> <span class="o">=</span> <span class="n">edge_labels</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>
                <span class="n">plt</span> <span class="o">+=</span> <span class="n">gp</span><span class="o">.</span><span class="n">plot_edge_label</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">el</span><span class="p">,</span> <span class="o">**</span><span class="n">o</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">plt</span></div>

<span class="c1"># I&#39;m not sure we want to support this...</span>
<span class="c1">#</span>
<span class="c1">#    def minimize_monodromy_mapping(self):</span>
<span class="c1">#        r&quot;&quot;&quot;</span>
<span class="c1">#        Return a mapping from this surface to a similarity surface</span>
<span class="c1">#        with a minimal monodromy group.</span>
<span class="c1">#        Note that this may be slow for infinite surfaces.</span>
<span class="c1">#</span>
<span class="c1">#        EXAMPLES::</span>
<span class="c1">#            sage: from flatsurf.geometry.polygon import ConvexPolygons</span>
<span class="c1">#            sage: K.&lt;sqrt2&gt; = NumberField(x**2 - 2, embedding=1.414)</span>
<span class="c1">#            sage: octagon = ConvexPolygons(K)([(1,0),(sqrt2/2, sqrt2/2),(0, 1),(-sqrt2/2, sqrt2/2),(-1,0),(-sqrt2/2, -sqrt2/2),(0, -1),(sqrt2/2, -sqrt2/2)])</span>
<span class="c1">#            sage: square = ConvexPolygons(K)([(1,0),(0,1),(-1,0),(0,-1)])</span>
<span class="c1">#            sage: gluings = [((0,i),(1+(i%2),i//2)) for i in range(8)]</span>
<span class="c1">#            sage: from flatsurf.geometry.surface import surface_from_polygons_and_gluings</span>
<span class="c1">#            sage: s=surface_from_polygons_and_gluings([octagon,square,square],gluings)</span>
<span class="c1">#            sage: print s</span>
<span class="c1">#            Rational cone surface built from 3 polygons</span>
<span class="c1">#            sage: m=s.minimize_monodromy_mapping()</span>
<span class="c1">#            sage: s2=m.codomain()</span>
<span class="c1">#            sage: print s2</span>
<span class="c1">#            Translation surface built from 3 polygons</span>
<span class="c1">#            sage: v=s.tangent_vector(2,(0,0),(1,0))</span>
<span class="c1">#            sage: print m.push_vector_forward(v)</span>
<span class="c1">#            SimilaritySurfaceTangentVector in polygon 2 based at (0, 0) with vector (-1/2*sqrt2, -1/2*sqrt2)</span>
<span class="c1">#            sage: w=s2.tangent_vector(2,(0,0),(0,-1))</span>
<span class="c1">#            sage: print m.pull_vector_back(w)</span>
<span class="c1">#            SimilaritySurfaceTangentVector in polygon 2 based at (0, 0) with vector (1/2*sqrt2, 1/2*sqrt2)</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        lw = self.walker()</span>
<span class="c1">#        class MatrixFunction:</span>
<span class="c1">#            def __init__(self, lw):</span>
<span class="c1">#                self._lw=lw</span>
<span class="c1">#                from sage.matrix.constructor import identity_matrix</span>
<span class="c1">#                self._d = {lw.surface().base_label():</span>
<span class="c1">#                    identity_matrix(lw.surface().base_ring(), n=2)}</span>
<span class="c1">#            def __call__(self, label):</span>
<span class="c1">#                try:</span>
<span class="c1">#                    return self._d[label]</span>
<span class="c1">#                except KeyError:</span>
<span class="c1">#                    e = self._lw.edge_back(label)</span>
<span class="c1">#                    label2,e2 = self._lw.surface().opposite_edge(label,e)</span>
<span class="c1">#                    m=self._lw.surface().edge_matrix(label,e) * self(label2)</span>
<span class="c1">#                    self._d[label]=m</span>
<span class="c1">#                    return m</span>
<span class="c1">#        mf = MatrixFunction(lw)</span>
<span class="c1">#        from flatsurf.geometry.mappings import (</span>
<span class="c1">#            MatrixListDeformedSurfaceMapping,</span>
<span class="c1">#            IdentityMapping)</span>
<span class="c1">#        mapping = MatrixListDeformedSurfaceMapping(self, mf)</span>
<span class="c1">#        surface_type = mapping.codomain().compute_surface_type_from_gluings(limit=100)</span>
<span class="c1">#        new_codomain = convert_to_type(mapping.codomain(),surface_type)</span>
<span class="c1">#        identity = IdentityMapping(mapping.codomain(), new_codomain)</span>
<span class="c1">#        return identity * mapping</span>
<span class="c1">#</span>
<span class="c1">#    def minimal_monodromy_surface(self):</span>
<span class="c1">#        r&quot;&quot;&quot;</span>
<span class="c1">#        Return an equivalent similarity surface with minimal monodromy.</span>
<span class="c1">#        Note that this may be slow for infinite surfaces.</span>
<span class="c1">#</span>
<span class="c1">#        EXAMPLES::</span>
<span class="c1">#            sage: from flatsurf.geometry.polygon import ConvexPolygons</span>
<span class="c1">#            sage: K.&lt;sqrt2&gt; = NumberField(x**2 - 2, embedding=1.414)</span>
<span class="c1">#            sage: octagon = ConvexPolygons(K)([(1,0),(sqrt2/2, sqrt2/2),(0, 1),(-sqrt2/2, sqrt2/2),(-1,0),(-sqrt2/2, -sqrt2/2),(0, -1),(sqrt2/2, -sqrt2/2)])</span>
<span class="c1">#            sage: square = ConvexPolygons(K)([(1,0),(0,1),(-1,0),(0,-1)])</span>
<span class="c1">#            sage: gluings = [((0,i),(1+(i%2),i//2)) for i in range(8)]</span>
<span class="c1">#            sage: from flatsurf.geometry.surface import surface_from_polygons_and_gluings</span>
<span class="c1">#            sage: s=surface_from_polygons_and_gluings([octagon,square,square],gluings)</span>
<span class="c1">#            sage: print s</span>
<span class="c1">#            Rational cone surface built from 3 polygons</span>
<span class="c1">#            sage: s2=s.minimal_monodromy_surface()</span>
<span class="c1">#            sage: print s2</span>
<span class="c1">#            Translation surface built from 3 polygons</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        return self.minimize_monodromy_mapping().codomain()</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implements a naive notion of equality where two finite surfaces are equal if:</span>
<span class="sd">        - their base labels are equal,</span>
<span class="sd">        - their polygons are equal and labeled and glued in the same way.</span>
<span class="sd">        For infinite surfaces we use reference equality.</span>
<span class="sd">        Raises a value error if the surfaces are defined over different rings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SimilaritySurface</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can not compare infinite surfaces.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">base_ring</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Refusing to compare surfaces with different base rings.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">():</span>
            <span class="n">hash1</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">hash2</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hash1</span> <span class="o">!=</span> <span class="n">hash2</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_label</span><span class="p">()</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">base_label</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_polygons</span><span class="p">()</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">num_polygons</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span><span class="n">polygon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_iterator</span><span class="p">(</span><span class="n">polygons</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">polygon2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">polygon</span> <span class="o">!=</span> <span class="n">polygon2</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">edge</span><span class="p">)</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">edge</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hash compatible with equals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Attempting to hash with mutable underlying surface.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_hash&#39;</span><span class="p">):</span>
            <span class="c1"># Return the cached hash.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>
        <span class="c1"># Compute the hash</span>
        <span class="n">h</span> <span class="o">=</span> <span class="mi">17</span><span class="o">*</span><span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">())</span><span class="o">+</span><span class="mi">23</span><span class="o">*</span><span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_label</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_iterator</span><span class="p">(</span><span class="n">polygons</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">7</span><span class="o">*</span><span class="nb">hash</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">edgepair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">(</span><span class="n">gluings</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="nb">hash</span><span class="p">(</span><span class="n">edgepair</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="o">=</span><span class="n">h</span>
        <span class="k">return</span> <span class="n">h</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">sage-flatsurf 0.4.7 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">flatsurf.geometry.similarity_surface</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2021, Vincent Delecroix and Pat Hooper.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.1.1.
    </div>
  </body>
</html>