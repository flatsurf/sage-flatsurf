
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>flatsurf.geometry.polygon &#8212; sage-flatsurf 0.4.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.css" />
    
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/togglebutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">sage-flatsurf 0.4.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">flatsurf.geometry.polygon</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for flatsurf.geometry.polygon</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Polygons embedded in the plane R^2.</span>

<span class="sd">This file implements polygons with</span>

<span class="sd"> - action of matrices in GL^+(2,R)</span>
<span class="sd"> - conversion between ground fields</span>

<span class="sd">The emphasis is mostly on convex polygons but there is some limited support</span>
<span class="sd">for non-convex polygons.</span>

<span class="sd">EXAMPLES::</span>

<span class="sd">    sage: from flatsurf.geometry.polygon import polygons</span>

<span class="sd">    sage: K.&lt;sqrt2&gt; = NumberField(x^2 - 2, embedding=AA(2).sqrt())</span>
<span class="sd">    sage: p = polygons((1,0), (-sqrt2,1+sqrt2), (sqrt2-1,-1-sqrt2))</span>
<span class="sd">    sage: p</span>
<span class="sd">    Polygon: (0, 0), (1, 0), (-sqrt2 + 1, sqrt2 + 1)</span>

<span class="sd">    sage: M = MatrixSpace(K,2)</span>
<span class="sd">    sage: m = M([[1,1+sqrt2],[0,1]])</span>
<span class="sd">    sage: m * p</span>
<span class="sd">    Polygon: (0, 0), (1, 0), (sqrt2 + 4, sqrt2 + 1)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1">######################################################################</span>
<span class="c1">#  This file is part of sage-flatsurf.</span>
<span class="c1">#</span>
<span class="c1">#        Copyright (C) 2016-2020 Vincent Delecroix</span>
<span class="c1">#                      2020      Julian RÃ¼th</span>
<span class="c1">#</span>
<span class="c1">#  sage-flatsurf is free software: you can redistribute it and/or modify</span>
<span class="c1">#  it under the terms of the GNU General Public License as published by</span>
<span class="c1">#  the Free Software Foundation, either version 2 of the License, or</span>
<span class="c1">#  (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1">#  sage-flatsurf is distributed in the hope that it will be useful,</span>
<span class="c1">#  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1">#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1">#  GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1">#  You should have received a copy of the GNU General Public License</span>
<span class="c1">#  along with sage-flatsurf. If not, see &lt;https://www.gnu.org/licenses/&gt;.</span>
<span class="c1">######################################################################</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="kn">import</span> <span class="nb">range</span><span class="p">,</span> <span class="nb">map</span><span class="p">,</span> <span class="nb">filter</span><span class="p">,</span> <span class="nb">zip</span>

<span class="kn">import</span> <span class="nn">operator</span>

<span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">cached_method</span><span class="p">,</span> <span class="n">Parent</span><span class="p">,</span> <span class="n">UniqueRepresentation</span><span class="p">,</span> <span class="n">Sets</span><span class="p">,</span> <span class="n">Rings</span><span class="p">,</span>\
                     <span class="n">Fields</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">,</span> <span class="n">QQ</span><span class="p">,</span> <span class="n">AA</span><span class="p">,</span> <span class="n">RR</span><span class="p">,</span> <span class="n">RIF</span><span class="p">,</span> <span class="n">QQbar</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">polygen</span><span class="p">,</span> <span class="n">vector</span><span class="p">,</span>\
                     <span class="n">free_module_element</span><span class="p">,</span> <span class="n">NumberField</span><span class="p">,</span> <span class="n">FreeModule</span><span class="p">,</span> <span class="n">lcm</span><span class="p">,</span> <span class="n">gcd</span>
<span class="kn">from</span> <span class="nn">sage.misc.cachefunc</span> <span class="kn">import</span> <span class="n">cached_function</span>
<span class="kn">from</span> <span class="nn">sage.misc.functional</span> <span class="kn">import</span> <span class="n">numerical_approx</span>
<span class="kn">from</span> <span class="nn">sage.structure.element</span> <span class="kn">import</span> <span class="n">get_coercion_model</span><span class="p">,</span> <span class="n">Vector</span>
<span class="kn">from</span> <span class="nn">sage.structure.coerce</span> <span class="kn">import</span> <span class="n">py_scalar_parent</span>
<span class="n">cm</span> <span class="o">=</span> <span class="n">get_coercion_model</span><span class="p">()</span>
<span class="kn">from</span> <span class="nn">sage.structure.element</span> <span class="kn">import</span> <span class="n">Element</span>
<span class="kn">from</span> <span class="nn">sage.categories.action</span> <span class="kn">import</span> <span class="n">Action</span>
<span class="kn">from</span> <span class="nn">sage.modules.free_module_element</span> <span class="kn">import</span> <span class="n">vector</span>
<span class="kn">from</span> <span class="nn">sage.modules.free_module</span> <span class="kn">import</span> <span class="n">VectorSpace</span>
<span class="kn">from</span> <span class="nn">sage.structure.sequence</span> <span class="kn">import</span> <span class="n">Sequence</span>

<span class="kn">from</span> <span class="nn">.matrix_2x2</span> <span class="kn">import</span> <span class="n">angle</span>
<span class="kn">from</span> <span class="nn">.subfield</span> <span class="kn">import</span> <span class="n">number_field_elements_from_algebraics</span><span class="p">,</span> <span class="n">cos_minpoly</span><span class="p">,</span> <span class="n">chebyshev_T</span><span class="p">,</span> <span class="n">subfield_from_elements</span>

<span class="c1"># we implement action of GL(2,K) on polygons</span>

<span class="n">ZZ_0</span> <span class="o">=</span> <span class="n">ZZ</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="n">ZZ_2</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<div class="viewcode-block" id="dot_product"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.dot_product">[docs]</a><span class="k">def</span> <span class="nf">dot_product</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="wedge_product"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.wedge_product">[docs]</a><span class="k">def</span> <span class="nf">wedge_product</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="wedge"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.wedge">[docs]</a><span class="k">def</span> <span class="nf">wedge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    General wedge product of two vectors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span> <span class="o">==</span> <span class="n">R</span>
    <span class="k">return</span> <span class="n">free_module_element</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="p">[(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">d</span><span class="p">)])</span></div>

<div class="viewcode-block" id="tensor"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.tensor">[docs]</a><span class="k">def</span> <span class="nf">tensor</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    General tensor product of two vectors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span> <span class="o">==</span> <span class="n">R</span>
    <span class="k">return</span> <span class="n">matrix</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="p">[</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">)])</span></div>

<div class="viewcode-block" id="line_intersection"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.line_intersection">[docs]</a><span class="k">def</span> <span class="nf">line_intersection</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="n">q1</span><span class="p">,</span><span class="n">q2</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the point of intersection between the line joining p1 to p2</span>
<span class="sd">    and the line joining q1 to q2. If the lines are parallel we return</span>
<span class="sd">    None. Here p1, p2, q1 and q2 should be vectors in the plane.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">wedge_product</span><span class="p">(</span><span class="n">p2</span><span class="o">-</span><span class="n">p1</span><span class="p">,</span><span class="n">q2</span><span class="o">-</span><span class="n">q1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="c1"># Since the wedge product is non-zero, the following is invertible:</span>
    <span class="n">m</span><span class="o">=</span><span class="n">matrix</span><span class="p">([[</span><span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">q2</span><span class="p">[</span><span class="mi">0</span><span class="p">]],[</span><span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">q1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">q2</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span>
    <span class="k">return</span> <span class="n">p1</span><span class="o">+</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">q1</span><span class="o">-</span><span class="n">p1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">p2</span><span class="o">-</span><span class="n">p1</span><span class="p">)</span></div>

<div class="viewcode-block" id="is_same_direction"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.is_same_direction">[docs]</a><span class="k">def</span> <span class="nf">is_same_direction</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">zero</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf.geometry.polygon import is_same_direction</span>
<span class="sd">        sage: V = QQ**2</span>

<span class="sd">        sage: is_same_direction(V((0,1)), V((0,2)))</span>
<span class="sd">        True</span>
<span class="sd">        sage: is_same_direction(V((1,-1)), V((2,-2)))</span>
<span class="sd">        True</span>
<span class="sd">        sage: is_same_direction(V((4,-2)), V((2,-1)))</span>
<span class="sd">        True</span>
<span class="sd">        sage: is_same_direction(V((1,2)), V((2,4)))</span>
<span class="sd">        True</span>
<span class="sd">        sage: is_same_direction(V((0,2)), V((0,1)))</span>
<span class="sd">        True</span>

<span class="sd">        sage: is_same_direction(V((1,1)), V((1,2)))</span>
<span class="sd">        False</span>
<span class="sd">        sage: is_same_direction(V((1,2)), V((2,1)))</span>
<span class="sd">        False</span>
<span class="sd">        sage: is_same_direction(V((1,2)), V((1,-2)))</span>
<span class="sd">        False</span>
<span class="sd">        sage: is_same_direction(V((1,2)), V((-1,-2)))</span>
<span class="sd">        False</span>
<span class="sd">        sage: is_same_direction(V((2,-1)), V((-2,1)))</span>
<span class="sd">        False</span>

<span class="sd">        sage: is_same_direction(V((1,0)), V.zero())</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        TypeError: zero vector has no direction</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">w</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;zero vector has no direction&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="n">wedge_product</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="is_opposite_direction"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.is_opposite_direction">[docs]</a><span class="k">def</span> <span class="nf">is_opposite_direction</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf.geometry.polygon import is_opposite_direction</span>
<span class="sd">        sage: V = QQ**2</span>

<span class="sd">        sage: is_opposite_direction(V((0,1)), V((0,-2)))</span>
<span class="sd">        True</span>
<span class="sd">        sage: is_opposite_direction(V((1,-1)), V((-2,2)))</span>
<span class="sd">        True</span>
<span class="sd">        sage: is_opposite_direction(V((4,-2)), V((-2,1)))</span>
<span class="sd">        True</span>
<span class="sd">        sage: is_opposite_direction(V((-1,-2)), V((2,4)))</span>
<span class="sd">        True</span>

<span class="sd">        sage: is_opposite_direction(V((1,1)), V((1,2)))</span>
<span class="sd">        False</span>
<span class="sd">        sage: is_opposite_direction(V((1,2)), V((2,1)))</span>
<span class="sd">        False</span>
<span class="sd">        sage: is_opposite_direction(V((0,2)), V((0,1)))</span>
<span class="sd">        False</span>
<span class="sd">        sage: is_opposite_direction(V((1,2)), V((1,-2)))</span>
<span class="sd">        False</span>
<span class="sd">        sage: is_opposite_direction(V((1,2)), V((-1,2)))</span>
<span class="sd">        False</span>
<span class="sd">        sage: is_opposite_direction(V((2,-1)), V((-2,-1)))</span>
<span class="sd">        False</span>

<span class="sd">        sage: is_opposite_direction(V((1,0)), V.zero())</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        TypeError: zero vector has no direction</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">w</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;zero vector has no direction&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="n">wedge_product</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="solve"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.solve">[docs]</a><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return (a,b) so that: x + au = y + bv</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``x``, ``u``, ``y``, ``v`` -- two dimensional vectors</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf.geometry.polygon import solve</span>
<span class="sd">        sage: K.&lt;sqrt2&gt; = NumberField(x^2 - 2, embedding=AA(2).sqrt())</span>
<span class="sd">        sage: V = VectorSpace(K,2)</span>
<span class="sd">        sage: x = V((1,-sqrt2))</span>
<span class="sd">        sage: y = V((1,1))</span>
<span class="sd">        sage: a = V((0,1))</span>
<span class="sd">        sage: b = V((-sqrt2, sqrt2+1))</span>
<span class="sd">        sage: u = V((0,1))</span>
<span class="sd">        sage: v = V((-sqrt2, sqrt2+1))</span>
<span class="sd">        sage: a, b = solve(x,u,y,v)</span>
<span class="sd">        sage: x + a*u == y + b*v</span>
<span class="sd">        True</span>

<span class="sd">        sage: u = V((1,1))</span>
<span class="sd">        sage: v = V((1,sqrt2))</span>
<span class="sd">        sage: a, b = solve(x,u,y,v)</span>
<span class="sd">        sage: x + a*u == y + b*v</span>
<span class="sd">        True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="o">-</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_zero</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;parallel vectors&quot;</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="n">d</span><span class="p">,</span> <span class="n">b</span><span class="o">/</span><span class="n">d</span><span class="p">)</span></div>

<div class="viewcode-block" id="segment_intersect"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.segment_intersect">[docs]</a><span class="k">def</span> <span class="nf">segment_intersect</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return whether the segments ``e1`` and ``e2`` intersect.</span>

<span class="sd">    OUTPUT:</span>

<span class="sd">    - ``0`` - do not intersect</span>
<span class="sd">    - ``1`` - one endpoint in common</span>
<span class="sd">    - ``2`` - non-trivial intersection</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf.geometry.polygon import segment_intersect</span>
<span class="sd">        sage: segment_intersect(((0,0),(1,0)),((0,1),(0,3)))</span>
<span class="sd">        0</span>
<span class="sd">        sage: segment_intersect(((0,0),(1,0)),((0,0),(0,3)))</span>
<span class="sd">        1</span>
<span class="sd">        sage: segment_intersect(((0,0),(1,0)),((0,-1),(0,3)))</span>
<span class="sd">        2</span>
<span class="sd">        sage: segment_intersect(((-1,-1),(1,1)),((0,0),(2,2)))</span>
<span class="sd">        2</span>
<span class="sd">        sage: segment_intersect(((-1,-1),(1,1)),((1,1),(2,2)))</span>
<span class="sd">        1</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">e1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">e1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">e2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">e2</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;degenerate segments&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">base_ring</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">elts</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="p">(</span><span class="n">e1</span><span class="p">,</span><span class="n">e2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">base_ring</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">common_parent</span><span class="p">(</span><span class="o">*</span><span class="n">elts</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base_ring</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="n">base_ring</span> <span class="o">=</span> <span class="n">py_scalar_parent</span><span class="p">(</span><span class="n">base_ring</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">base_ring</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">xs1</span><span class="p">,</span> <span class="n">ys1</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">base_ring</span><span class="p">,</span> <span class="n">e1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">xt1</span><span class="p">,</span> <span class="n">yt1</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">base_ring</span><span class="p">,</span> <span class="n">e1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">xs2</span><span class="p">,</span> <span class="n">ys2</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">base_ring</span><span class="p">,</span> <span class="n">e2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">xt2</span><span class="p">,</span> <span class="n">yt2</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">base_ring</span><span class="p">,</span> <span class="n">e2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">xs1</span><span class="p">,</span> <span class="n">ys1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">xt1</span><span class="p">,</span> <span class="n">yt1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">xs2</span><span class="p">,</span> <span class="n">ys2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">s0</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">det</span><span class="p">()</span>
    <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">xt2</span><span class="p">,</span> <span class="n">yt2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">det</span><span class="p">()</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s0</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">s1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">s0</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">s1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="c1"># e2 stands on one side of the line generated by e1</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">xs2</span><span class="p">,</span> <span class="n">ys2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">xt2</span><span class="p">,</span> <span class="n">yt2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">xs1</span><span class="p">,</span> <span class="n">ys1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">det</span><span class="p">()</span>
    <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">xt1</span><span class="p">,</span> <span class="n">yt1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">s3</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">det</span><span class="p">()</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s2</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">s3</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">s2</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">s3</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="c1"># e1 stands on one side of the line generated by e2</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">s0</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">s1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">s2</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">s3</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">xt1</span> <span class="o">&lt;</span> <span class="n">xs1</span> <span class="ow">or</span> <span class="p">(</span><span class="n">xt1</span> <span class="o">==</span> <span class="n">xs1</span> <span class="ow">and</span> <span class="n">yt1</span> <span class="o">&lt;</span> <span class="n">ys1</span><span class="p">):</span>
            <span class="n">xs1</span><span class="p">,</span><span class="n">xt1</span> <span class="o">=</span> <span class="n">xt1</span><span class="p">,</span><span class="n">xs1</span>
            <span class="n">ys1</span><span class="p">,</span><span class="n">yt1</span> <span class="o">=</span> <span class="n">yt1</span><span class="p">,</span><span class="n">ys1</span>
        <span class="k">if</span> <span class="n">xt2</span> <span class="o">&lt;</span> <span class="n">xs2</span> <span class="ow">or</span> <span class="p">(</span><span class="n">xt2</span> <span class="o">==</span> <span class="n">xs2</span> <span class="ow">and</span> <span class="n">yt2</span> <span class="o">&lt;</span> <span class="n">ys2</span><span class="p">):</span>
            <span class="n">xs2</span><span class="p">,</span><span class="n">xt2</span> <span class="o">=</span> <span class="n">xt2</span><span class="p">,</span><span class="n">xs2</span>
            <span class="n">ys2</span><span class="p">,</span><span class="n">yt2</span> <span class="o">=</span> <span class="n">yt2</span><span class="p">,</span><span class="n">ys2</span>

        <span class="k">if</span> <span class="n">xs1</span> <span class="o">==</span> <span class="n">xt1</span> <span class="o">==</span> <span class="n">xs2</span> <span class="o">==</span> <span class="n">xt2</span><span class="p">:</span>
            <span class="n">xs1</span><span class="p">,</span> <span class="n">xt1</span><span class="p">,</span> <span class="n">xs2</span><span class="p">,</span> <span class="n">xt2</span> <span class="o">=</span> <span class="n">ys1</span><span class="p">,</span> <span class="n">yt1</span><span class="p">,</span> <span class="n">ys2</span><span class="p">,</span> <span class="n">yt2</span>

        <span class="k">assert</span> <span class="n">xs1</span> <span class="o">&lt;</span> <span class="n">xt1</span> <span class="ow">and</span> <span class="n">xs2</span> <span class="o">&lt;</span> <span class="n">xt2</span><span class="p">,</span> <span class="p">(</span><span class="n">xs1</span><span class="p">,</span> <span class="n">xt1</span><span class="p">,</span> <span class="n">xs2</span><span class="p">,</span> <span class="n">xt2</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">xs2</span> <span class="o">&gt;</span> <span class="n">xt1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">xt2</span> <span class="o">&lt;</span> <span class="n">xs1</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span> <span class="c1"># no intersection</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">xs2</span> <span class="o">==</span> <span class="n">xt1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">xt2</span> <span class="o">==</span> <span class="n">xs1</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="c1"># one endpoint in common</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">xs1</span> <span class="o">&lt;=</span> <span class="n">xs2</span> <span class="o">&lt;</span> <span class="n">xt1</span> <span class="ow">or</span> <span class="n">xs1</span> <span class="o">&lt;</span> <span class="n">xt2</span> <span class="o">&lt;=</span> <span class="n">xt1</span> <span class="ow">or</span> \
                   <span class="p">(</span><span class="n">xs2</span> <span class="o">&lt;</span> <span class="n">xs1</span> <span class="ow">and</span> <span class="n">xt2</span> <span class="o">&gt;</span> <span class="n">xt1</span><span class="p">)</span> <span class="ow">or</span> \
                   <span class="p">(</span><span class="n">xs2</span> <span class="o">&gt;</span> <span class="n">xs1</span> <span class="ow">and</span> <span class="n">xt2</span> <span class="o">&lt;</span> <span class="n">xt1</span><span class="p">),</span> <span class="p">(</span><span class="n">xs1</span><span class="p">,</span> <span class="n">xt1</span><span class="p">,</span> <span class="n">xs2</span><span class="p">,</span> <span class="n">xt2</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">2</span> <span class="c1"># one dimensional</span>

    <span class="k">elif</span> <span class="n">s0</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">s1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># treat alignment here</span>
        <span class="k">if</span> <span class="n">s2</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">s3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="c1"># one endpoint in common</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">2</span> <span class="c1"># intersection in the middle</span>

    <span class="k">return</span> <span class="mi">2</span> <span class="c1"># middle intersection</span></div>

<div class="viewcode-block" id="is_between"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.is_between">[docs]</a><span class="k">def</span> <span class="nf">is_between</span><span class="p">(</span><span class="n">e0</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check whether the vector ``f`` is strictly in the sector formed by the vectors</span>
<span class="sd">    ``e0`` and ``e1`` (in counter-clockwise order).</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf.geometry.polygon import is_between</span>
<span class="sd">        sage: V = ZZ^2</span>
<span class="sd">        sage: is_between(V((1, 0)), V((1, 1)), V((2, 1)))</span>
<span class="sd">        True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">e0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">e1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">e1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">e0</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="c1"># positive determinant</span>
        <span class="c1"># [ e0[0] e1[0] ]^-1 = [ e1[1] -e1[0] ]</span>
        <span class="c1"># [ e0[1] e1[1] ]      [-e0[1]  e0[0] ]</span>
        <span class="c1"># f[0] * e1[1] - e1[0] * f[1] &gt; 0</span>
        <span class="c1"># - f[0] * e0[1] + e0[0] * f[1] &gt; 0</span>
        <span class="k">return</span> <span class="n">e1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">e1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">e0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">e0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">e0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">e1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">e1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">e0</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="c1"># aligned vector</span>
        <span class="k">return</span> <span class="n">e0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">e0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># negative determinant</span>
        <span class="c1"># [ e1[0] e0[0] ]^-1 = [ e0[1] -e0[0] ]</span>
        <span class="c1"># [ e1[1] e0[1] ]      [-e1[1]  e1[0] ]</span>
        <span class="c1"># f[0] * e0[1] - e0[0] * f[1] &gt; 0</span>
        <span class="c1"># - f[0] * e1[1] + e1[0] * f[1] &gt; 0</span>
        <span class="k">return</span> <span class="n">e0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">e0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">e1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">e1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="projectivization"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.projectivization">[docs]</a><span class="k">def</span> <span class="nf">projectivization</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">signed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">denominator</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    TESTS::</span>

<span class="sd">        sage: from flatsurf.geometry.polygon import projectivization</span>

<span class="sd">        sage: projectivization(2/3, -3/5, signed=True, denominator=True)</span>
<span class="sd">        (10, -9)</span>
<span class="sd">        sage: projectivization(2/3, -3/5, signed=False, denominator=True)</span>
<span class="sd">        (-10, 9)</span>
<span class="sd">        sage: projectivization(2/3, -3/5, signed=True, denominator=False)</span>
<span class="sd">        (10/9, -1)</span>
<span class="sd">        sage: projectivization(2/3, -3/5, signed=False, denominator=False)</span>
<span class="sd">        (-10/9, 1)</span>

<span class="sd">        sage: projectivization(-1/2, 0, signed=True, denominator=True)</span>
<span class="sd">        (-1, 0)</span>
<span class="sd">        sage: projectivization(-1/2, 0, signed=False, denominator=True)</span>
<span class="sd">        (1, 0)</span>
<span class="sd">        sage: projectivization(-1/2, 0, signed=True, denominator=False)</span>
<span class="sd">        (-1, 0)</span>
<span class="sd">        sage: projectivization(-1/2, 0, signed=False, denominator=False)</span>
<span class="sd">        (1, 0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">y</span><span class="p">:</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span>
        <span class="k">if</span> <span class="n">denominator</span> <span class="o">==</span> <span class="kc">True</span> <span class="ow">or</span> <span class="p">(</span><span class="n">denominator</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="s1">&#39;denominator&#39;</span><span class="p">)):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">signed</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">z</span> <span class="o">*</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">signed</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="triangulate"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.triangulate">[docs]</a><span class="k">def</span> <span class="nf">triangulate</span><span class="p">(</span><span class="n">vertices</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a triangulation of the list of vectors ``vertices``.</span>

<span class="sd">    This function assumes that ``vertices`` form the vertices of a polygon</span>
<span class="sd">    enumerated in counter-clockwise order.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf.geometry.polygon import triangulate</span>
<span class="sd">        sage: V = ZZ**2</span>
<span class="sd">        sage: verts = list(map(V, [(0,0), (1,0), (1,1), (0,1)]))</span>
<span class="sd">        sage: triangulate(verts)</span>
<span class="sd">        [(0, 2)]</span>

<span class="sd">        sage: quad = [(0,0), (1,-1), (0,1), (-1,-1)]</span>
<span class="sd">        sage: quad = list(map(V, quad))</span>
<span class="sd">        sage: for i in range(4):</span>
<span class="sd">        ....:     print(triangulate(quad[i:] + quad[:i]))</span>
<span class="sd">        [(0, 2)]</span>
<span class="sd">        [(1, 3)]</span>
<span class="sd">        [(0, 2)]</span>
<span class="sd">        [(1, 3)]</span>

<span class="sd">        sage: poly = [(0,0),(1,1),(2,0),(3,1),(4,0),(4,2),</span>
<span class="sd">        ....:     (-4,2),(-4,0),(-3,1),(-2,0),(-1,1)]</span>
<span class="sd">        sage: poly = list(map(V, poly))</span>
<span class="sd">        sage: triangulate(poly)</span>
<span class="sd">        [(1, 3), (3, 5), (5, 8), (6, 8), (8, 10), (10, 1), (1, 5), (5, 10)]</span>
<span class="sd">        sage: for i in range(len(poly)):</span>
<span class="sd">        ....:     _ = triangulate(poly[i:] + poly[:i])</span>

<span class="sd">        sage: poly = [(0,0), (1,0), (2,0), (2,1), (2,2), (1,2), (0,2), (0,1)]</span>
<span class="sd">        sage: poly = list(map(V, poly))</span>
<span class="sd">        sage: edges = triangulate(poly)</span>
<span class="sd">        sage: edges</span>
<span class="sd">        [(0, 3), (1, 3), (3, 5), (5, 7), (7, 3)]</span>
<span class="sd">        sage: for i in range(len(poly)):</span>
<span class="sd">        ....:     _ = triangulate(poly[i:] + poly[:i])</span>

<span class="sd">        sage: poly = [(0,0), (1,2), (3,3), (1,4), (0,6), (-1,4), (-3,-3), (-1,2)]</span>
<span class="sd">        sage: poly = list(map(V, poly))</span>
<span class="sd">        sage: triangulate(poly)</span>
<span class="sd">        [(0, 3), (1, 3), (3, 5), (5, 7), (7, 3)]</span>
<span class="sd">        sage: for i in range(len(poly)):</span>
<span class="sd">        ....:     _ = triangulate(poly[i:] + poly[:i])</span>

<span class="sd">        sage: x = polygen(QQ)</span>
<span class="sd">        sage: p = x^4 - 5*x^2 + 5</span>
<span class="sd">        sage: r = AA.polynomial_root(p, RIF(1.17,1.18))</span>
<span class="sd">        sage: K.&lt;a&gt; = NumberField(p, embedding=r)</span>
<span class="sd">        sage: V = K**2</span>
<span class="sd">        sage: poly = [(1/2*a^2 - 3/2, 1/2*a),</span>
<span class="sd">        ....:  (-a^3 + 2*a^2 + 2*a - 4, 0),</span>
<span class="sd">        ....:  (1/2*a^2 - 3/2, -1/2*a),</span>
<span class="sd">        ....:   (1/2*a^3 - a^2 - 1/2*a + 1, 1/2*a^2 - a),</span>
<span class="sd">        ....:   (-1/2*a^2 + 1, 1/2*a^3 - 3/2*a),</span>
<span class="sd">        ....:   (-1/2*a + 1, a^3 - 3/2*a^2 - 2*a + 5/2),</span>
<span class="sd">        ....:   (1, 0),</span>
<span class="sd">        ....:   (-1/2*a + 1, -a^3 + 3/2*a^2 + 2*a - 5/2),</span>
<span class="sd">        ....:   (-1/2*a^2 + 1, -1/2*a^3 + 3/2*a),</span>
<span class="sd">        ....:   (1/2*a^3 - a^2 - 1/2*a + 1, -1/2*a^2 + a)]</span>
<span class="sd">        sage: poly = list(map(V, poly))</span>
<span class="sd">        sage: triangulate(poly)</span>
<span class="sd">        [(0, 3), (1, 3), (3, 5), (5, 7), (7, 9), (9, 3), (3, 7)]</span>

<span class="sd">        sage: z = QQbar.zeta(24)</span>
<span class="sd">        sage: pts = [(1+i%2) * z**i for i in range(24)]</span>
<span class="sd">        sage: pts = [vector(AA, (x.real(), x.imag())) for x in pts]</span>
<span class="sd">        sage: triangulate(pts)</span>
<span class="sd">        [(0, 2), ..., (16, 0)]</span>

<span class="sd">    TESTS:</span>

<span class="sd">    This is https://github.com/flatsurf/sage-flatsurf/issues/87 ::</span>

<span class="sd">        sage: from flatsurf.geometry.polygon import triangulate</span>
<span class="sd">        sage: x = polygen(QQ)</span>
<span class="sd">        sage: K.&lt;c&gt; = NumberField(x^2 - 3, embedding=AA(3).sqrt())</span>
<span class="sd">        sage: pts = [(0, 0), (1, 0), (1/2*c + 1, -1/2), (c + 1, 0), (-3/2*c + 1, 5/2), (0, c - 2)]</span>
<span class="sd">        sage: pts = [vector(K, v) for v in pts]</span>
<span class="sd">        sage: triangulate(pts)</span>
<span class="sd">        [(0, 4), (1, 3), (4, 1)]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="c1"># NOTE: The algorithm is naive. We look at all possible chords between</span>
    <span class="c1"># the i-th and j-th vertices. If the chord does not intersect any edge</span>
    <span class="c1"># then we cut the polygon along this edge and call recursively</span>
    <span class="c1"># triangulate on the two pieces.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">eiright</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">eileft</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span> <span class="k">if</span> <span class="n">i</span> <span class="k">else</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
            <span class="n">ejright</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">ejleft</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">chord</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># check angles with neighbouring edges</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">is_between</span><span class="p">(</span><span class="n">eiright</span><span class="p">,</span> <span class="n">eileft</span><span class="p">,</span> <span class="n">chord</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="n">is_between</span><span class="p">(</span><span class="n">ejright</span><span class="p">,</span> <span class="n">ejleft</span><span class="p">,</span> <span class="o">-</span><span class="n">chord</span><span class="p">)):</span>
                <span class="k">continue</span>

            <span class="c1"># check intersection with other edges</span>
            <span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">good</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">vertices</span><span class="p">[(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">n</span><span class="p">])</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">segment_intersect</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">res</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">good</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">res</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">k</span> <span class="o">==</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">==</span> <span class="n">i</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">==</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">==</span> <span class="n">j</span>

            <span class="k">if</span> <span class="n">good</span><span class="p">:</span>
                <span class="n">part0</span> <span class="o">=</span> <span class="p">[(</span><span class="n">s</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="n">triangulate</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])]</span>
                <span class="n">part1</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="n">triangulate</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">:]</span> <span class="o">+</span> <span class="n">vertices</span><span class="p">[:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="n">j</span><span class="p">:</span>
                        <span class="n">s</span> <span class="o">+=</span> <span class="n">j</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">s</span> <span class="o">-=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">j</span>
                    <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="n">j</span><span class="p">:</span>
                        <span class="n">t</span> <span class="o">+=</span> <span class="n">j</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">t</span> <span class="o">-=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">j</span>
                    <span class="n">part1</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
                <span class="k">return</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span> <span class="o">+</span> <span class="n">part0</span> <span class="o">+</span> <span class="n">part1</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;input </span><span class="si">{}</span><span class="s2"> must be wrong&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vertices</span><span class="p">))</span></div>

<div class="viewcode-block" id="build_faces"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.build_faces">[docs]</a><span class="k">def</span> <span class="nf">build_faces</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a combinatorial list of pairs ``edges`` forming a cell-decomposition</span>
<span class="sd">    of a polygon (with vertices labeled from ``0`` to ``n-1``) return the list</span>
<span class="sd">    of cells.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf.geometry.polygon import build_faces</span>
<span class="sd">        sage: build_faces(4, [(0,2)])</span>
<span class="sd">        [[0, 1, 2], [2, 3, 0]]</span>
<span class="sd">        sage: build_faces(4, [(1,3)])</span>
<span class="sd">        [[1, 2, 3], [3, 0, 1]]</span>
<span class="sd">        sage: build_faces(5, [(0,2), (0,3)])</span>
<span class="sd">        [[0, 1, 2], [3, 4, 0], [0, 2, 3]]</span>
<span class="sd">        sage: build_faces(5, [(0,2)])</span>
<span class="sd">        [[0, 1, 2], [2, 3, 4, 0]]</span>
<span class="sd">        sage: build_faces(5, [(1,4)])</span>
<span class="sd">        [[1, 2, 3, 4], [4, 0, 1]]</span>
<span class="sd">        sage: build_faces(5, [(1,3),(3,0)])</span>
<span class="sd">        [[1, 2, 3], [3, 4, 0], [0, 1, 3]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">polygons</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))]</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">j</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">polygons</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">p</span> <span class="ow">and</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">p</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">j</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">if</span> <span class="n">j</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">polygons</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">i0</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">i1</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i0</span> <span class="o">&gt;</span> <span class="n">i1</span><span class="p">:</span>
            <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i0</span>
        <span class="n">polygons</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[:</span><span class="n">i0</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">polygons</span></div>

<div class="viewcode-block" id="MatrixActionOnPolygons"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.MatrixActionOnPolygons">[docs]</a><span class="k">class</span> <span class="nc">MatrixActionOnPolygons</span><span class="p">(</span><span class="n">Action</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polygons</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sage.matrix.matrix_space</span> <span class="kn">import</span> <span class="n">MatrixSpace</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">polygons</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>
        <span class="n">Action</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MatrixSpace</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">polygons</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_act_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the 2x2 matrix `g` to the polygon `x`.</span>

<span class="sd">        The matrix must have non-zero determinant. If the determinant is</span>
<span class="sd">        negative, then the vertices and edges are relabeled according to the</span>
<span class="sd">        involutions `v \mapsto (n-v)%n` and  `e \mapsto n-1-e` respectively.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: p = polygons(vertices = [(1,0),(0,1),(-1,-1)])</span>
<span class="sd">            sage: print(p)</span>
<span class="sd">            Polygon: (1, 0), (0, 1), (-1, -1)</span>
<span class="sd">            sage: r = matrix(ZZ,[[0,1], [1,0]])</span>
<span class="sd">            sage: print(r*p)</span>
<span class="sd">            Polygon: (0, 1), (-1, -1), (1, 0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">det</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">det</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">det</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[</span><span class="n">g</span><span class="o">*</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">vertices</span><span class="p">()])</span>
        <span class="k">if</span> <span class="n">det</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Note that in this case we reverse the order</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">vertices</span><span class="o">=</span><span class="n">vertices</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can not act on a polygon with matrix with zero determinant&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="PolygonPosition"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.PolygonPosition">[docs]</a><span class="k">class</span> <span class="nc">PolygonPosition</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for describing the position of a point within or outside of a polygon.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Position Types:</span>
    <span class="n">OUTSIDE</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">INTERIOR</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">EDGE_INTERIOR</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">VERTEX</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position_type</span><span class="p">,</span> <span class="n">edge</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">vertex</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_position_type</span><span class="o">=</span><span class="n">position_type</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_vertex</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">vertex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Constructed vertex position with no specified vertex.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vertex</span><span class="o">=</span><span class="n">vertex</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_in_edge_interior</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">edge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Constructed edge position with no specified edge.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_edge</span><span class="o">=</span><span class="n">edge</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_outside</span><span class="p">():</span>
            <span class="k">return</span> <span class="s2">&quot;point positioned outside polygon&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_in_interior</span><span class="p">():</span>
            <span class="k">return</span> <span class="s2">&quot;point positioned in interior of polygon&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_in_edge_interior</span><span class="p">():</span>
            <span class="k">return</span> <span class="s2">&quot;point positioned on interior of edge &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; of polygon&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;point positioned on vertex &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertex</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; of polygon&quot;</span>

<div class="viewcode-block" id="PolygonPosition.is_outside"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.PolygonPosition.is_outside">[docs]</a>    <span class="k">def</span> <span class="nf">is_outside</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_position_type</span> <span class="o">==</span> <span class="n">PolygonPosition</span><span class="o">.</span><span class="n">OUTSIDE</span></div>

<div class="viewcode-block" id="PolygonPosition.is_inside"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.PolygonPosition.is_inside">[docs]</a>    <span class="k">def</span> <span class="nf">is_inside</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return true if the position is not outside the closure of the polygon</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_position_type</span><span class="p">)</span></div>

<div class="viewcode-block" id="PolygonPosition.is_in_interior"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.PolygonPosition.is_in_interior">[docs]</a>    <span class="k">def</span> <span class="nf">is_in_interior</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_position_type</span> <span class="o">==</span> <span class="n">PolygonPosition</span><span class="o">.</span><span class="n">INTERIOR</span></div>

<div class="viewcode-block" id="PolygonPosition.is_in_boundary"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.PolygonPosition.is_in_boundary">[docs]</a>    <span class="k">def</span> <span class="nf">is_in_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return true if the position is in the boundary of the polygon</span>
<span class="sd">        (either the interior of an edge or a vertex).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_position_type</span> <span class="o">==</span> <span class="n">PolygonPosition</span><span class="o">.</span><span class="n">EDGE_INTERIOR</span> <span class="ow">or</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_position_type</span> <span class="o">==</span> <span class="n">PolygonPosition</span><span class="o">.</span><span class="n">VERTEX</span></div>

<div class="viewcode-block" id="PolygonPosition.is_in_edge_interior"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.PolygonPosition.is_in_edge_interior">[docs]</a>    <span class="k">def</span> <span class="nf">is_in_edge_interior</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_position_type</span> <span class="o">==</span> <span class="n">PolygonPosition</span><span class="o">.</span><span class="n">EDGE_INTERIOR</span></div>

<div class="viewcode-block" id="PolygonPosition.is_vertex"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.PolygonPosition.is_vertex">[docs]</a>    <span class="k">def</span> <span class="nf">is_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_position_type</span> <span class="o">==</span> <span class="n">PolygonPosition</span><span class="o">.</span><span class="n">VERTEX</span></div>

<div class="viewcode-block" id="PolygonPosition.get_position_type"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.PolygonPosition.get_position_type">[docs]</a>    <span class="k">def</span> <span class="nf">get_position_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_position_type</span></div>

<div class="viewcode-block" id="PolygonPosition.get_edge"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.PolygonPosition.get_edge">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_in_edge_interior</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Asked for edge when not in edge interior.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge</span></div>

<div class="viewcode-block" id="PolygonPosition.get_vertex"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.PolygonPosition.get_vertex">[docs]</a>    <span class="k">def</span> <span class="nf">get_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_vertex</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Asked for vertex when not a vertex.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertex</span></div></div>


<div class="viewcode-block" id="Polygon"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.Polygon">[docs]</a><span class="k">class</span> <span class="nc">Polygon</span><span class="p">(</span><span class="n">Element</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">Element</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">module</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">vertices</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">vv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">:</span> <span class="n">vv</span><span class="o">.</span><span class="n">set_immutable</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_non_intersection_check</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inside_outside_check</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_inside_outside_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import Polygons</span>
<span class="sd">            sage: P = Polygons(QQ)</span>
<span class="sd">            sage: P(vertices=[(0,0),(-1,-1),(0,1),(1,-1)])</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: the vertices are in clockwise order</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE: should we do something more efficient?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">area</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the vertices are in clockwise order&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_non_intersection_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import Polygons</span>
<span class="sd">            sage: P = Polygons(QQ)</span>
<span class="sd">            sage: P(vertices=[(0,0),(2,0),(1,1),(1,-1)])</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: edge 0 (= ((0, 0), (2, 0))) and edge 2 (= ((1, 1), (1, -1))) intersect</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">ei</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">ej</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">[(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">n</span><span class="p">])</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">segment_intersect</span><span class="p">(</span><span class="n">ei</span><span class="p">,</span> <span class="n">ej</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">res</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;edge </span><span class="si">%d</span><span class="s2"> (= </span><span class="si">%s</span><span class="s2">) and edge </span><span class="si">%d</span><span class="s2"> (= </span><span class="si">%s</span><span class="s2">) backtrack&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">ej</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">res</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;edge </span><span class="si">%d</span><span class="s2"> (= </span><span class="si">%s</span><span class="s2">) and edge </span><span class="si">%d</span><span class="s2"> (= </span><span class="si">%s</span><span class="s2">) intersect&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">ej</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Apparently tuples do not cache their hash!</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf.geometry.polygon import polygons</span>
<span class="sd">            sage: p1 = polygons.square()</span>
<span class="sd">            sage: p2 = polygons((1,0),(0,1),(-1,0),(0,-1), ring=QQbar)</span>
<span class="sd">            sage: p1 == p2</span>
<span class="sd">            True</span>

<span class="sd">            sage: p3 = polygons((2,0),(-1,1),(-1,-1))</span>
<span class="sd">            sage: p1 == p3</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_v</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf.geometry.polygon import polygons</span>
<span class="sd">            sage: p1 = polygons.square()</span>
<span class="sd">            sage: p2 = polygons((1,0),(0,1),(-1,0),(0,-1), ring=QQbar)</span>
<span class="sd">            sage: p1 != p2</span>
<span class="sd">            False</span>

<span class="sd">            sage: p3 = polygons((2,0),(-1,1),(-1,-1))</span>
<span class="sd">            sage: p1 != p3</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_v</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">TypeError</span>
    <span class="fm">__le__</span> <span class="o">=</span> <span class="fm">__lt__</span>
    <span class="fm">__gt__</span> <span class="o">=</span> <span class="fm">__lt__</span>
    <span class="fm">__ge__</span> <span class="o">=</span> <span class="fm">__lt__</span>

<div class="viewcode-block" id="Polygon.cmp"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.Polygon.cmp">[docs]</a>    <span class="k">def</span> <span class="nf">cmp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implement a total order on polygons</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;__cmp__ only implemented for ConvexPolygons&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">base_ring</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;__cmp__ only implemented for ConvexPolygons defined over the same base_ring&quot;</span><span class="p">)</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">sign</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">sign</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">area</span><span class="p">()</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">area</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">sign</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">zero</span><span class="p">():</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">sign</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">zero</span><span class="p">():</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sign</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">zero</span><span class="p">():</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">sign</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">zero</span><span class="p">():</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sign</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">zero</span><span class="p">():</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">sign</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">zero</span><span class="p">():</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="Polygon.triangulation"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.Polygon.triangulation">[docs]</a>    <span class="k">def</span> <span class="nf">triangulation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of pairs of indices of vertices that together with the boundary</span>
<span class="sd">        form a triangulation.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: P = polygons(vertices=[(0,0), (1,0), (1,1), (0,1), (0,2), (-1,2), (-1,1), (-2,1),</span>
<span class="sd">            ....:                    (-2,0), (-1,0), (-1,-1), (0,-1)], convex=False)</span>
<span class="sd">            sage: P.triangulation()</span>
<span class="sd">            [(0, 2), (2, 8), (3, 5), (6, 8), (8, 3), (3, 6), (9, 11), (0, 9), (2, 9)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">triangulate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">)</span></div>

<div class="viewcode-block" id="Polygon.translate"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.Polygon.translate">[docs]</a>    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: polygons(vertices=[(0,0), (2,0), (1,1)]).translate((3,-2))</span>
<span class="sd">            Polygon: (3, -2), (5, -2), (4, -1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">module</span><span class="p">()(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">P</span><span class="o">.</span><span class="n">element_class</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="p">[</span><span class="n">u</span><span class="o">+</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="Polygon.change_ring"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.Polygon.change_ring">[docs]</a>    <span class="k">def</span> <span class="nf">change_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an equal polygon over the base ring ``R``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: S = polygons.square()</span>
<span class="sd">            sage: K.&lt;sqrt2&gt; = NumberField(x^2 - 2, embedding=AA(2)**(1/2))</span>
<span class="sd">            sage: S.change_ring(K)</span>
<span class="sd">            Polygon: (0, 0), (1, 0), (1, 1), (0, 1)</span>
<span class="sd">            sage: S.change_ring(K).base_ring()</span>
<span class="sd">            Number Field in sqrt2 with defining polynomial x^2 - 2 with sqrt2 = 1.4142...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">ConvexPolygons</span><span class="p">(</span><span class="n">R</span><span class="p">)(</span><span class="n">vertices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="Polygon.is_convex"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.Polygon.is_convex">[docs]</a>    <span class="k">def</span> <span class="nf">is_convex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">wedge_product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Polygon.is_strictly_convex"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.Polygon.is_strictly_convex">[docs]</a>    <span class="k">def</span> <span class="nf">is_strictly_convex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether the polygon is strictly convex</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import *</span>
<span class="sd">            sage: polygons(vertices=[(0,0), (1,0), (1,1)]).is_strictly_convex()</span>
<span class="sd">            True</span>
<span class="sd">            sage: polygons(vertices=[(0,0), (1,0), (2,0), (1,1)]).is_strictly_convex()</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">wedge_product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">is_zero</span><span class="p">():</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Polygon.base_ring"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.Polygon.base_ring">[docs]</a>    <span class="k">def</span> <span class="nf">base_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span></div>

    <span class="n">field</span><span class="o">=</span><span class="n">base_ring</span>

<div class="viewcode-block" id="Polygon.num_edges"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.Polygon.num_edges">[docs]</a>    <span class="k">def</span> <span class="nf">num_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;Polygon: &quot;</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">()))</span>

<div class="viewcode-block" id="Polygon.module"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.Polygon.module">[docs]</a>    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">module</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the free module of rank 2 in which this polygon embeds.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: S = polygons.square()</span>
<span class="sd">            sage: S.module()</span>
<span class="sd">            Vector space of dimension 2 over Rational Field</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">module</span><span class="p">()</span></div>

<div class="viewcode-block" id="Polygon.vector_space"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.Polygon.vector_space">[docs]</a>    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">vector_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the vector space of dimension 2 in which this polygon embeds.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: S = polygons.square()</span>
<span class="sd">            sage: S.vector_space()</span>
<span class="sd">            Vector space of dimension 2 over Rational Field</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">vector_space</span><span class="p">()</span></div>

<div class="viewcode-block" id="Polygon.vertices"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.Polygon.vertices">[docs]</a>    <span class="k">def</span> <span class="nf">vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">translation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the set of vertices as vectors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">translation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span>

        <span class="n">translation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">vector_space</span><span class="p">()(</span><span class="n">translation</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">t</span><span class="o">+</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">()]</span></div>

<div class="viewcode-block" id="Polygon.vertex"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.Polygon.vertex">[docs]</a>    <span class="k">def</span> <span class="nf">vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the ``i``-th vertex as a vector</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">)]</span></div>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>

<div class="viewcode-block" id="Polygon.edges"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.Polygon.edges">[docs]</a>    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterator overt the edges</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">())]</span></div>

<div class="viewcode-block" id="Polygon.edge"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.Polygon.edge">[docs]</a>    <span class="k">def</span> <span class="nf">edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a vector representing the ``i``-th edge of the polygon.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">i</span><span class="p">)</span></div>

<div class="viewcode-block" id="Polygon.plot"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.Polygon.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">translation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the polygon with the origin at ``translation``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.plot.point</span> <span class="kn">import</span> <span class="n">point2d</span>
        <span class="kn">from</span> <span class="nn">sage.plot.line</span> <span class="kn">import</span> <span class="n">line2d</span>
        <span class="kn">from</span> <span class="nn">sage.plot.polygon</span> <span class="kn">import</span> <span class="n">polygon2d</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">VectorSpace</span><span class="p">(</span><span class="n">RR</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">(</span><span class="n">translation</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">point2d</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">line2d</span><span class="p">(</span><span class="n">P</span> <span class="o">+</span> <span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">],),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;orange&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">polygon2d</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span></div>

<div class="viewcode-block" id="Polygon.angle"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.Polygon.angle">[docs]</a>    <span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">numerical</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">assume_rational</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the angle at the begining of the start point of the edge ``e``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf.geometry.polygon import polygons</span>
<span class="sd">            sage: polygons.square().angle(0)</span>
<span class="sd">            1/4</span>
<span class="sd">            sage: polygons.regular_ngon(8).angle(0)</span>
<span class="sd">            3/8</span>

<span class="sd">            sage: T = polygons(vertices=[(0,0), (3,1), (1,5)])</span>
<span class="sd">            sage: [T.angle(i, numerical=True) for i in range(3)]  # abs tol 1e-13</span>
<span class="sd">            [0.16737532973071603, 0.22741638234956674, 0.10520828791971722]</span>
<span class="sd">            sage: sum(T.angle(i, numerical=True) for i in range(3))   # abs tol 1e-13</span>
<span class="sd">            0.5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">((</span><span class="n">e</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()),</span> <span class="n">numerical</span><span class="o">=</span><span class="n">numerical</span><span class="p">,</span> <span class="n">assume_rational</span><span class="o">=</span><span class="n">assume_rational</span><span class="p">)</span></div>

<div class="viewcode-block" id="Polygon.angles"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.Polygon.angles">[docs]</a>    <span class="k">def</span> <span class="nf">angles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numerical</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">assume_rational</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of angles of this polygon (divided by `2 \pi`).</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf.geometry.polygon import polygons</span>

<span class="sd">            sage: T = polygons(angles=[1,2,3])</span>
<span class="sd">            sage: [T.angle(i) for i in range(3)]</span>
<span class="sd">            [1/12, 1/6, 1/4]</span>
<span class="sd">            sage: sum(T.angle(i) for i in range(3))</span>
<span class="sd">            1/2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">())]</span></div>

<div class="viewcode-block" id="Polygon.area"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.Polygon.area">[docs]</a>    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the area of this polygon.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf.geometry.polygon import polygons</span>
<span class="sd">            sage: polygons.regular_ngon(8).area()</span>
<span class="sd">            2*a + 2</span>
<span class="sd">            sage: _ == 2*AA(2).sqrt() + 2</span>
<span class="sd">            True</span>

<span class="sd">            sage: AA(polygons.regular_ngon(11).area())</span>
<span class="sd">            9.36563990694544?</span>

<span class="sd">            sage: polygons.square().area()</span>
<span class="sd">            1</span>
<span class="sd">            sage: (2*polygons.square()).area()</span>
<span class="sd">            4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Will use an area formula obtainable from Green&#39;s theorem. See for instance:</span>
        <span class="c1"># http://math.blogoverflow.com/2014/06/04/greens-theorem-and-area-of-polygons/</span>
        <span class="n">total</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="p">()</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()):</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">total</span><span class="o">/</span><span class="n">ZZ_2</span></div>

<div class="viewcode-block" id="Polygon.j_invariant"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.Polygon.j_invariant">[docs]</a>    <span class="k">def</span> <span class="nf">j_invariant</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the Kenyon-Smille J-invariant of this polygon.</span>

<span class="sd">        The base ring of the polygon must be a number field.</span>

<span class="sd">        The output is a triple ``(Jxx, Jyy, Jxy)`` that corresponds</span>
<span class="sd">        respectively to the Sah-Arnoux-Fathi invariant of the vertical flow,</span>
<span class="sd">        the Sah-Arnoux-Fathi invariant of the horizontal flow and the `xy`-matrix.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import *</span>

<span class="sd">            sage: polygons.right_triangle(1/3,1).j_invariant()</span>
<span class="sd">            (</span>
<span class="sd">                      [0 0]</span>
<span class="sd">            (0), (0), [1 0]</span>
<span class="sd">            )</span>

<span class="sd">        The regular 8-gon::</span>

<span class="sd">            sage: polygons.regular_ngon(8).j_invariant()</span>
<span class="sd">            (</span>
<span class="sd">                      [2 2]</span>
<span class="sd">            (0), (0), [2 1]</span>
<span class="sd">            )</span>

<span class="sd">            (</span>
<span class="sd">                           [  0 3/2]</span>
<span class="sd">            (1/2), (-1/2), [3/2   0]</span>
<span class="sd">            )</span>

<span class="sd">        Some extra debugging::</span>

<span class="sd">            sage: from flatsurf.geometry.polygon import wedge</span>
<span class="sd">            sage: K.&lt;a&gt; = NumberField(x^3 - 2, embedding=AA(2)**(1/3))</span>
<span class="sd">            sage: ux = 1 + a + a**2</span>
<span class="sd">            sage: uy = -2/3 + a</span>
<span class="sd">            sage: vx = 1/5 - a**2</span>
<span class="sd">            sage: vy = a + 7/13*a**2</span>
<span class="sd">            sage: p = polygons((ux, uy), (vx,vy), (-ux-vx,-uy-vy), ring=K)</span>
<span class="sd">            sage: Jxx, Jyy, Jxy = p.j_invariant()</span>
<span class="sd">            sage: wedge(ux.vector(), vx.vector()) == Jxx</span>
<span class="sd">            True</span>
<span class="sd">            sage: wedge(uy.vector(), vy.vector()) == Jyy</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span> <span class="ow">is</span> <span class="n">QQ</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">V</span><span class="p">,</span> <span class="n">from_V</span><span class="p">,</span> <span class="n">to_V</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">vector_space</span><span class="p">()</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the surface needs to be define over a number field&quot;</span><span class="p">)</span>

        <span class="n">dim</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
        <span class="n">Jxx</span> <span class="o">=</span> <span class="n">Jyy</span> <span class="o">=</span> <span class="n">free_module_element</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">dim</span><span class="o">*</span><span class="p">(</span><span class="n">dim</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">Jxy</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>
        <span class="n">vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">to_V</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">to_V</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">to_V</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">to_V</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">Jxx</span> <span class="o">+=</span> <span class="n">wedge</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
            <span class="n">Jyy</span> <span class="o">+=</span> <span class="n">wedge</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
            <span class="n">Jxy</span> <span class="o">+=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
            <span class="n">Jxy</span> <span class="o">-=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">Jxx</span><span class="p">,</span> <span class="n">Jyy</span><span class="p">,</span> <span class="n">Jxy</span><span class="p">)</span></div>

<div class="viewcode-block" id="Polygon.is_isometric"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.Polygon.is_isometric">[docs]</a>    <span class="k">def</span> <span class="nf">is_isometric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">certificate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether ``self`` and ``other`` are isometric convex polygons via an orientation</span>
<span class="sd">        preserving isometry.</span>

<span class="sd">        If ``certificate`` is set to ``True`` return also a pair ``(index, rotation)``</span>
<span class="sd">        of an integer ``index`` and a matrix ``rotation`` such that the given rotation</span>
<span class="sd">        matrix identifies this polygon with the other and the edges 0 in this polygon</span>
<span class="sd">        is mapped to the edge ``index`` in the other.</span>

<span class="sd">        .. TODO::</span>

<span class="sd">            Implement ``is_linearly_equivalent`` and ``is_similar``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: S = polygons.square()</span>
<span class="sd">            sage: S.is_isometric(S)</span>
<span class="sd">            True</span>
<span class="sd">            sage: U = matrix(2,[0,-1,1,0]) * S</span>
<span class="sd">            sage: U.is_isometric(S)</span>
<span class="sd">            True</span>

<span class="sd">            sage: x = polygen(QQ)</span>
<span class="sd">            sage: K.&lt;sqrt2&gt; = NumberField(x^2 - 2, embedding=AA(2)**(1/2))</span>
<span class="sd">            sage: S = S.change_ring(K)</span>
<span class="sd">            sage: U = matrix(2, [sqrt2/2, -sqrt2/2, sqrt2/2, sqrt2/2]) * S</span>
<span class="sd">            sage: U.is_isometric(S)</span>
<span class="sd">            True</span>

<span class="sd">            sage: U2 = polygons((1,0), (sqrt2/2, sqrt2/2), (-1,0), (-sqrt2/2, -sqrt2/2))</span>
<span class="sd">            sage: U2.is_isometric(U)</span>
<span class="sd">            False</span>
<span class="sd">            sage: U2.is_isometric(U, certificate=True)</span>
<span class="sd">            (False, None)</span>

<span class="sd">            sage: S = polygons((1,0), (sqrt2/2, 3), (-2,3), (-sqrt2/2+1, -6))</span>
<span class="sd">            sage: T = polygons((sqrt2/2,3), (-2,3), (-sqrt2/2+1, -6), (1,0))</span>
<span class="sd">            sage: ans, certif = S.is_isometric(T, certificate=True)</span>
<span class="sd">            sage: assert ans</span>
<span class="sd">            sage: shift, rot = certif</span>
<span class="sd">            sage: polygons(edges=[rot * S.edge((k + shift) % 4) for k in range(4)], base_point=T.vertex(0)) == T</span>
<span class="sd">            True</span>


<span class="sd">            sage: T = (matrix(2, [sqrt2/2, -sqrt2/2, sqrt2/2, sqrt2/2]) * S).translate((3,2))</span>
<span class="sd">            sage: ans, certif = S.is_isometric(T, certificate=True)</span>
<span class="sd">            sage: assert ans</span>
<span class="sd">            sage: shift, rot = certif</span>
<span class="sd">            sage: polygons(edges=[rot * S.edge(k + shift) for k in range(4)], base_point=T.vertex(0)) == T</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">sedges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
        <span class="n">oedges</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>

        <span class="n">slengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="n">sedges</span><span class="p">]</span>
        <span class="n">olengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="n">oedges</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">slengths</span> <span class="o">==</span> <span class="n">olengths</span><span class="p">:</span>
                <span class="c1"># we have a match of lengths after a shift by i</span>
                <span class="n">xs</span><span class="p">,</span><span class="n">ys</span> <span class="o">=</span> <span class="n">sedges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">xo</span><span class="p">,</span><span class="n">yo</span> <span class="o">=</span> <span class="n">oedges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ms</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="n">xs</span><span class="p">,</span> <span class="o">-</span><span class="n">ys</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">xs</span><span class="p">])</span>
                <span class="n">mo</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="n">xo</span><span class="p">,</span> <span class="o">-</span><span class="n">yo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">xo</span><span class="p">])</span>
                <span class="n">rot</span> <span class="o">=</span> <span class="n">mo</span> <span class="o">*</span> <span class="o">~</span><span class="n">ms</span>
                <span class="k">assert</span> <span class="n">rot</span><span class="o">.</span><span class="n">det</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">rot</span> <span class="o">*</span> <span class="n">rot</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">is_one</span><span class="p">()</span>
                <span class="k">assert</span> <span class="n">oedges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">rot</span> <span class="o">*</span> <span class="n">sedges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">oedges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">rot</span> <span class="o">*</span> <span class="n">sedges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)):</span>
                    <span class="k">return</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="n">rot</span><span class="p">))</span> <span class="k">if</span> <span class="n">certificate</span> <span class="k">else</span> <span class="kc">True</span>
            <span class="n">olengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">olengths</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">oedges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">oedges</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">certificate</span> <span class="k">else</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Polygon.is_translate"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.Polygon.is_translate">[docs]</a>    <span class="k">def</span> <span class="nf">is_translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">certificate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether ``other`` is a translate of ``self``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: S = polygons(vertices=[(0,0), (3,0), (1,1)])</span>
<span class="sd">            sage: T1 = S.translate((2,3))</span>
<span class="sd">            sage: S.is_translate(T1)</span>
<span class="sd">            True</span>
<span class="sd">            sage: T2 = polygons(vertices=[(-1,1), (1,0), (2,1)])</span>
<span class="sd">            sage: S.is_translate(T2)</span>
<span class="sd">            False</span>
<span class="sd">            sage: T3 = polygons(vertices=[(0,0), (3,0), (2,1)])</span>
<span class="sd">            sage: S.is_translate(T3)</span>
<span class="sd">            False</span>

<span class="sd">            sage: S.is_translate(T1, certificate=True)</span>
<span class="sd">            (True, (0, 1))</span>
<span class="sd">            sage: S.is_translate(T2, certificate=True)</span>
<span class="sd">            (False, None)</span>
<span class="sd">            sage: S.is_translate(T3, certificate=True)</span>
<span class="sd">            (False, None)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">sedges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
        <span class="n">oedges</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sedges</span> <span class="o">==</span> <span class="n">oedges</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="k">if</span> <span class="n">certificate</span> <span class="k">else</span> <span class="kc">True</span>
            <span class="n">oedges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">oedges</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">certificate</span> <span class="k">else</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Polygon.is_half_translate"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.Polygon.is_half_translate">[docs]</a>    <span class="k">def</span> <span class="nf">is_half_translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">certificate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether ``other`` is a translate or half-translate of ``self``.</span>

<span class="sd">        If ``certificate`` is set to ``True`` then return also a pair ``(orientation, index)``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: S = polygons(vertices=[(0,0), (3,0), (1,1)])</span>
<span class="sd">            sage: T1 = S.translate((2,3))</span>
<span class="sd">            sage: S.is_half_translate(T1)</span>
<span class="sd">            True</span>
<span class="sd">            sage: T2 = polygons(vertices=[(-1,1), (1,0), (2,1)])</span>
<span class="sd">            sage: S.is_half_translate(T2)</span>
<span class="sd">            True</span>
<span class="sd">            sage: T3 = polygons(vertices=[(0,0), (3,0), (2,1)])</span>
<span class="sd">            sage: S.is_half_translate(T3)</span>
<span class="sd">            False</span>

<span class="sd">            sage: S.is_half_translate(T1, certificate=True)</span>
<span class="sd">            (True, (0, 1))</span>
<span class="sd">            sage: ans, certif = S.is_half_translate(T2, certificate=True)</span>
<span class="sd">            sage: assert ans</span>
<span class="sd">            sage: shift, rot = certif</span>
<span class="sd">            sage: polygons(edges=[rot * S.edge(k + shift) for k in range(3)], base_point=T2.vertex(0)) == T2</span>
<span class="sd">            True</span>
<span class="sd">            sage: S.is_half_translate(T3, certificate=True)</span>
<span class="sd">            (False, None)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">sedges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
        <span class="n">oedges</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sedges</span> <span class="o">==</span> <span class="n">oedges</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="k">if</span> <span class="n">certificate</span> <span class="k">else</span> <span class="kc">True</span>
            <span class="n">oedges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">oedges</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

        <span class="k">assert</span> <span class="n">oedges</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
        <span class="n">oedges</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">oedges</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sedges</span> <span class="o">==</span> <span class="n">oedges</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="k">if</span> <span class="n">certificate</span> <span class="k">else</span> <span class="kc">True</span>
            <span class="n">oedges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">oedges</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

        <span class="k">return</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">certificate</span> <span class="k">else</span> <span class="kc">False</span></div></div>

<div class="viewcode-block" id="ConvexPolygon"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.ConvexPolygon">[docs]</a><span class="k">class</span> <span class="nc">ConvexPolygon</span><span class="p">(</span><span class="n">Polygon</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A convex polygon in the plane RR^2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        To construct the polygon you should either use a list of edge vectors</span>
<span class="sd">        or a list of vertices. Using both will result in a ValueError. The polygon</span>
<span class="sd">        needs to be convex with postively oriented boundary.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``parent`` -- a parent</span>

<span class="sd">        - ``vertices`` -- a list of vertices of the polygon</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Polygon</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_convexity_check</span><span class="p">()</span>

<div class="viewcode-block" id="ConvexPolygon.is_convex"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.ConvexPolygon.is_convex">[docs]</a>    <span class="k">def</span> <span class="nf">is_convex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span></div>

    <span class="k">def</span> <span class="nf">_convexity_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import *</span>
<span class="sd">            sage: polygons(vertices=[(0,0),(1,0)])</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: a polygon should have more than two edges!</span>
<span class="sd">            sage: polygons(vertices=[(0,0),(1,2),(0,1),(-1,2)])</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: not convex</span>
<span class="sd">            sage: polygons(vertices=[(0,0),(1,0),(2,0)])</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: degenerate polygon</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;a polygon should have more than two edges!&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span><span class="o">.</span><span class="n">is_zero</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the sum over the edges do not sum up to 0&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">wedge_product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;not convex&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_opposite_direction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;degenerate polygon&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="ConvexPolygon.find_separatrix"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.ConvexPolygon.find_separatrix">[docs]</a>    <span class="k">def</span> <span class="nf">find_separatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start_vertex</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a pair (v,same) where v is a vertex and same is a boolean.</span>
<span class="sd">        The provided parameter &quot;direction&quot; should be a non-zero vector with</span>
<span class="sd">        two entries, or by default direction=(0,1).</span>

<span class="sd">        A separatrix is a ray leaving a vertex and entering the polygon.</span>

<span class="sd">        The vertex v will have a separatrix leaving it which is parallel to</span>
<span class="sd">        direction. The returned value &quot;same&quot; answers the question if this separatrix</span>
<span class="sd">        points in the same direction as &quot;direction&quot;. There is a boundary case:</span>
<span class="sd">        we allow the separatrix to be an edge if and only if traveling along</span>
<span class="sd">        the sepatrix from the vertex would travel in a counter-clockwise</span>
<span class="sd">        direction about the polygon.</span>

<span class="sd">        The vertex returned is uniquely defined from the above if the polygon</span>
<span class="sd">        is a triangle. Otherwise, we return the first vertex with this property</span>
<span class="sd">        obtained by inspecting starting at start_vertex (defaults to 0) and</span>
<span class="sd">        then moving in the counter-clockwise direction.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: p=polygons.square()</span>
<span class="sd">            sage: print(p.find_separatrix())</span>
<span class="sd">            (1, True)</span>
<span class="sd">            sage: print(p.find_separatrix(start_vertex=2))</span>
<span class="sd">            (3, False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">module</span><span class="p">()((</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">zero</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">one</span><span class="p">()))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">direction</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span>
        <span class="n">v</span><span class="o">=</span><span class="n">start_vertex</span>
        <span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span>
        <span class="n">zero</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">wedge_product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">v</span><span class="p">),</span><span class="n">direction</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">zero</span> <span class="ow">and</span> \
                <span class="n">wedge_product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">direction</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">zero</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">v</span><span class="p">,</span><span class="kc">True</span>
            <span class="k">if</span> <span class="n">wedge_product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">v</span><span class="p">),</span><span class="n">direction</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">zero</span> <span class="ow">and</span> \
                <span class="n">wedge_product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">direction</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">zero</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">v</span><span class="p">,</span><span class="kc">False</span>
            <span class="n">v</span><span class="o">=</span><span class="n">v</span><span class="o">+</span><span class="mi">1</span><span class="o">%</span><span class="n">n</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Failed to find a separatrix&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="ConvexPolygon.contains_point"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.ConvexPolygon.contains_point">[docs]</a>    <span class="k">def</span> <span class="nf">contains_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">translation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return true if the point is within the polygon (after the polygon is possibly translated)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_point_position</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="n">translation</span><span class="o">=</span><span class="n">translation</span><span class="p">)</span><span class="o">.</span><span class="n">is_inside</span><span class="p">()</span></div>

<div class="viewcode-block" id="ConvexPolygon.get_point_position"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.ConvexPolygon.get_point_position">[docs]</a>    <span class="k">def</span> <span class="nf">get_point_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">translation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a combinatorial position of a points position compared to the polygon</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``point`` -- a point in the plane (vector over the underlying base_ring())</span>

<span class="sd">        - ``translation`` -- optional translation to applied to the polygon (vector over the underlying base_ring())</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        - a PolygonPosition object</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf.geometry.polygon import polygons</span>
<span class="sd">            sage: s = polygons.square()</span>
<span class="sd">            sage: V = s.parent().vector_space()</span>
<span class="sd">            sage: s.get_point_position(V((1/2,1/2)))</span>
<span class="sd">            point positioned in interior of polygon</span>
<span class="sd">            sage: s.get_point_position(V((1,0)))</span>
<span class="sd">            point positioned on vertex 1 of polygon</span>
<span class="sd">            sage: s.get_point_position(V((1,1/2)))</span>
<span class="sd">            point positioned on interior of edge 1 of polygon</span>
<span class="sd">            sage: s.get_point_position(V((1,3/2)))</span>
<span class="sd">            point positioned outside polygon</span>

<span class="sd">            sage: p=polygons(edges=[(1,0),(1,0),(1,0),(0,1),(-3,0),(0,-1)])</span>
<span class="sd">            sage: V=p.vector_space()</span>
<span class="sd">            sage: p.get_point_position(V([10,0]))</span>
<span class="sd">            point positioned outside polygon</span>
<span class="sd">            sage: p.get_point_position(V([1/2,0]))</span>
<span class="sd">            point positioned on interior of edge 0 of polygon</span>
<span class="sd">            sage: p.get_point_position(V([3/2,0]))</span>
<span class="sd">            point positioned on interior of edge 1 of polygon</span>
<span class="sd">            sage: p.get_point_position(V([2,0]))</span>
<span class="sd">            point positioned on vertex 2 of polygon</span>
<span class="sd">            sage: p.get_point_position(V([5/2,0]))</span>
<span class="sd">            point positioned on interior of edge 2 of polygon</span>
<span class="sd">            sage: p.get_point_position(V([5/2,1/4]))</span>
<span class="sd">            point positioned in interior of polygon</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector_space</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">translation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Since we allow the initial vertex to be non-zero, this changed:</span>
            <span class="n">v1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Since we allow the initial vertex to be non-zero, this changed:</span>
            <span class="n">v1</span><span class="o">=</span><span class="n">translation</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Below, we only make use of edge vectors:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()):</span>
            <span class="n">v0</span><span class="o">=</span><span class="n">v1</span>
            <span class="n">e</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">v1</span><span class="o">=</span><span class="n">v0</span><span class="o">+</span><span class="n">e</span>
            <span class="n">w</span><span class="o">=</span><span class="n">wedge_product</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">point</span><span class="o">-</span><span class="n">v0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">PolygonPosition</span><span class="p">(</span><span class="n">PolygonPosition</span><span class="o">.</span><span class="n">OUTSIDE</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">w</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Lies on the line through edge i!</span>
                <span class="n">dp1</span> <span class="o">=</span> <span class="n">dot_product</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">point</span><span class="o">-</span><span class="n">v0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dp1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">PolygonPosition</span><span class="p">(</span><span class="n">PolygonPosition</span><span class="o">.</span><span class="n">VERTEX</span><span class="p">,</span> <span class="n">vertex</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
                <span class="n">dp2</span> <span class="o">=</span> <span class="n">dot_product</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">e</span><span class="p">)</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">dp1</span> <span class="ow">and</span> <span class="n">dp1</span> <span class="o">&lt;</span> <span class="n">dp2</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">PolygonPosition</span><span class="p">(</span><span class="n">PolygonPosition</span><span class="o">.</span><span class="n">EDGE_INTERIOR</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
        <span class="c1"># Loop terminated (on inside of each edge)</span>
        <span class="k">return</span> <span class="n">PolygonPosition</span><span class="p">(</span><span class="n">PolygonPosition</span><span class="o">.</span><span class="n">INTERIOR</span><span class="p">)</span></div>

<div class="viewcode-block" id="ConvexPolygon.flow_to_exit"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.ConvexPolygon.flow_to_exit">[docs]</a>    <span class="k">def</span> <span class="nf">flow_to_exit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">point</span><span class="p">,</span><span class="n">direction</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flow a point in the direction of holonomy until the point leaves the</span>
<span class="sd">        polygon.  Note that ValueErrors may be thrown if the point is not in the</span>
<span class="sd">        polygon, or if it is on the boundary and the holonomy does not point</span>
<span class="sd">        into the polygon.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``point`` -- a point in the closure of the polygon (as a vector)</span>

<span class="sd">        - ``holonomy`` -- direction of motion (a vector of non-zero length)</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        - The point in the boundary of the polygon where the trajectory exits</span>

<span class="sd">        - a PolygonPosition object representing the combinatorial position of the stopping point</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">vector_space</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="n">V</span><span class="o">.</span><span class="n">zero</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Zero vector provided as direction.&quot;</span><span class="p">)</span>
        <span class="n">v0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">w</span><span class="o">=</span><span class="n">direction</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()):</span>
            <span class="n">e</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">m</span><span class="o">=</span><span class="n">matrix</span><span class="p">([[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">direction</span><span class="p">[</span><span class="mi">0</span><span class="p">]],[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">direction</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">=</span><span class="n">m</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">point</span><span class="o">-</span><span class="n">v0</span><span class="p">)</span>
                <span class="n">s</span><span class="o">=</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">t</span><span class="o">=</span><span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># What if the matrix is non-invertible?</span>

                <span class="c1"># Answer: You&#39;ll get a ZeroDivisionError which means that the edge is parallel</span>
                <span class="c1"># to the direction.</span>

                <span class="c1"># s is location it intersects on edge, t is the portion of the direction to reach this intersection</span>
                <span class="k">if</span> <span class="n">t</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">s</span> <span class="ow">and</span> <span class="n">s</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># The ray passes through edge i.</span>
                    <span class="k">if</span> <span class="n">s</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># exits through vertex i+1</span>
                        <span class="n">v0</span><span class="o">=</span><span class="n">v0</span><span class="o">+</span><span class="n">e</span>
                        <span class="k">return</span> <span class="n">v0</span><span class="p">,</span> <span class="n">PolygonPosition</span><span class="p">(</span><span class="n">PolygonPosition</span><span class="o">.</span><span class="n">VERTEX</span><span class="p">,</span> <span class="n">vertex</span><span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">())</span>
                    <span class="k">if</span> <span class="n">s</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># exits through vertex i</span>
                        <span class="k">return</span> <span class="n">v0</span><span class="p">,</span> <span class="n">PolygonPosition</span><span class="p">(</span><span class="n">PolygonPosition</span><span class="o">.</span><span class="n">VERTEX</span><span class="p">,</span> <span class="n">vertex</span><span class="o">=</span> <span class="n">i</span><span class="p">)</span>
                        <span class="c1"># exits through vertex i</span>
                    <span class="c1"># exits through interior of edge i</span>
                    <span class="n">prod</span><span class="o">=</span><span class="n">t</span><span class="o">*</span><span class="n">direction</span>
                    <span class="k">return</span> <span class="n">point</span><span class="o">+</span><span class="n">prod</span><span class="p">,</span> <span class="n">PolygonPosition</span><span class="p">(</span><span class="n">PolygonPosition</span><span class="o">.</span><span class="n">EDGE_INTERIOR</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
                <span class="c1"># Here we know the edge and the direction are parallel</span>
                <span class="k">if</span> <span class="n">wedge_product</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">point</span><span class="o">-</span><span class="n">v0</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># In this case point lies on the edge.</span>
                    <span class="c1"># We need to work out which direction to move in.</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">point</span><span class="o">-</span><span class="n">v0</span><span class="p">)</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span> <span class="ow">or</span> <span class="n">is_same_direction</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">point</span><span class="o">-</span><span class="n">v0</span><span class="p">):</span>
                        <span class="c1"># exits through vertex i+1</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">PolygonPosition</span><span class="p">(</span><span class="n">PolygonPosition</span><span class="o">.</span><span class="n">VERTEX</span><span class="p">,</span> <span class="n">vertex</span><span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">())</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># exits through vertex i</span>
                        <span class="k">return</span> <span class="n">v0</span><span class="p">,</span> <span class="n">PolygonPosition</span><span class="p">(</span><span class="n">PolygonPosition</span><span class="o">.</span><span class="n">VERTEX</span><span class="p">,</span> <span class="n">vertex</span><span class="o">=</span> <span class="n">i</span><span class="p">)</span>
                <span class="k">pass</span>
            <span class="n">v0</span><span class="o">=</span><span class="n">v0</span><span class="o">+</span><span class="n">e</span>
        <span class="c1"># Our loop has terminated. This can mean one of several errors...</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_point_position</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pos</span><span class="o">.</span><span class="n">is_outside</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Started with point outside polygon&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Point on boundary of polygon and direction not pointed into the polygon.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="ConvexPolygon.flow_map"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.ConvexPolygon.flow_map">[docs]</a>    <span class="k">def</span> <span class="nf">flow_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a polygonal map associated to the flow in ``direction`` in this</span>
<span class="sd">        polygon.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf.geometry.polygon import polygons</span>
<span class="sd">            sage: S = polygons(vertices=[(0,0),(2,0),(2,2),(1,2),(0,2),(0,1)])</span>
<span class="sd">            sage: S.flow_map((0,1))</span>
<span class="sd">             Flow polygon map:</span>
<span class="sd">              3 2</span>
<span class="sd">              0</span>
<span class="sd">             top lengths: [1, 1]</span>
<span class="sd">             bot lengths: [2]</span>
<span class="sd">            sage: S.flow_map((1,1))</span>
<span class="sd">            Flow polygon map:</span>
<span class="sd">             3 2 1</span>
<span class="sd">             4 5 0</span>
<span class="sd">            top lengths: [1, 1, 2]</span>
<span class="sd">            bot lengths: [1, 1, 2]</span>
<span class="sd">            sage: S.flow_map((-1,-1))</span>
<span class="sd">            Flow polygon map:</span>
<span class="sd">             0 5 4</span>
<span class="sd">             1 2 3</span>
<span class="sd">            top lengths: [2, 1, 1]</span>
<span class="sd">            bot lengths: [2, 1, 1]</span>

<span class="sd">            sage: K.&lt;sqrt2&gt; = NumberField(x^2 - 2, embedding=AA(2).sqrt())</span>
<span class="sd">            sage: S.flow_map((sqrt2,1))</span>
<span class="sd">            Flow polygon map:</span>
<span class="sd">             3 2 1</span>
<span class="sd">             4 5 0</span>
<span class="sd">            top lengths: [1, 1, 2*sqrt2]</span>
<span class="sd">            bot lengths: [sqrt2, sqrt2, 2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>
        <span class="n">DP</span> <span class="o">=</span> <span class="n">direction</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
        <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector_space</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">DP</span> <span class="o">!=</span> <span class="n">P</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">common_parent</span><span class="p">(</span><span class="n">DP</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>
            <span class="n">ring</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>
            <span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ring</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>

        <span class="c1"># first compute the transversal length of each edge</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">P</span><span class="p">([</span><span class="n">direction</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">direction</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">dot_product</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">()]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span>
            <span class="n">l0</span> <span class="o">=</span> <span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="n">lengths</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">l0</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">l1</span> <span class="o">&lt;</span>  <span class="mi">0</span><span class="p">:</span> <span class="n">rt</span> <span class="o">=</span> <span class="n">j</span>
            <span class="k">if</span> <span class="n">l0</span> <span class="o">&gt;</span>  <span class="mi">0</span> <span class="ow">and</span> <span class="n">l1</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span> <span class="n">rb</span> <span class="o">=</span> <span class="n">j</span>
            <span class="k">if</span> <span class="n">l0</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">l1</span> <span class="o">&gt;</span>  <span class="mi">0</span><span class="p">:</span> <span class="n">lb</span> <span class="o">=</span> <span class="n">j</span>
            <span class="k">if</span> <span class="n">l0</span> <span class="o">&lt;</span>  <span class="mi">0</span> <span class="ow">and</span> <span class="n">l1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span> <span class="n">lt</span> <span class="o">=</span> <span class="n">j</span>

        <span class="k">if</span> <span class="n">rt</span> <span class="o">&lt;</span> <span class="n">lt</span><span class="p">:</span>
            <span class="n">top_lengths</span> <span class="o">=</span> <span class="n">lengths</span><span class="p">[</span><span class="n">rt</span><span class="p">:</span><span class="n">lt</span><span class="p">]</span>
            <span class="n">top_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">rt</span><span class="p">,</span><span class="n">lt</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">top_lengths</span> <span class="o">=</span> <span class="n">lengths</span><span class="p">[</span><span class="n">rt</span><span class="p">:]</span> <span class="o">+</span> <span class="n">lengths</span><span class="p">[:</span><span class="n">lt</span><span class="p">]</span>
            <span class="n">top_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">rt</span><span class="p">,</span><span class="n">n</span><span class="p">))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">lt</span><span class="p">))</span>
        <span class="n">top_lengths</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">top_lengths</span><span class="p">)]</span>
        <span class="n">top_labels</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">lb</span> <span class="o">&lt;</span> <span class="n">rb</span><span class="p">:</span>
            <span class="n">bot_lengths</span> <span class="o">=</span> <span class="n">lengths</span><span class="p">[</span><span class="n">lb</span><span class="p">:</span><span class="n">rb</span><span class="p">]</span>
            <span class="n">bot_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span><span class="n">rb</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bot_lengths</span> <span class="o">=</span> <span class="n">lengths</span><span class="p">[</span><span class="n">lb</span><span class="p">:]</span> <span class="o">+</span> <span class="n">lengths</span><span class="p">[:</span><span class="n">rb</span><span class="p">]</span>
            <span class="n">bot_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span><span class="n">n</span><span class="p">))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">rb</span><span class="p">))</span>

        <span class="kn">from</span> <span class="nn">.interval_exchange_transformation</span> <span class="kn">import</span> <span class="n">FlowPolygonMap</span>
        <span class="k">return</span> <span class="n">FlowPolygonMap</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">bot_labels</span><span class="p">,</span> <span class="n">bot_lengths</span><span class="p">,</span>
                                                    <span class="n">top_labels</span><span class="p">,</span> <span class="n">top_lengths</span><span class="p">)</span></div>

<div class="viewcode-block" id="ConvexPolygon.flow"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.ConvexPolygon.flow">[docs]</a>    <span class="k">def</span> <span class="nf">flow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">holonomy</span><span class="p">,</span> <span class="n">translation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flow a point in the direction of holonomy for the length of the</span>
<span class="sd">        holonomy, or until the point leaves the polygon.  Note that ValueErrors</span>
<span class="sd">        may be thrown if the point is not in the polygon, or if it is on the</span>
<span class="sd">        boundary and the holonomy does not point into the polygon.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``point`` -- a point in the closure of the polygon (vector over the underlying base_ring())</span>

<span class="sd">        - ``holonomy`` -- direction and magnitude of motion (vector over the underlying base_ring())</span>

<span class="sd">        - ``translation`` -- optional translation to applied to the polygon (vector over the underlying base_ring())</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        - The point within the polygon where the motion stops (or leaves the polygon)</span>

<span class="sd">        - The amount of holonomy left to flow</span>

<span class="sd">        - a PolygonPosition object representing the combinatorial position of the stopping point</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf.geometry.polygon import polygons</span>
<span class="sd">            sage: s = polygons.square()</span>
<span class="sd">            sage: V = s.parent().vector_space()</span>
<span class="sd">            sage: p = V((1/2,1/2))</span>
<span class="sd">            sage: w = V((2,0))</span>
<span class="sd">            sage: s.flow(p,w)</span>
<span class="sd">            ((1, 1/2), (3/2, 0), point positioned on interior of edge 1 of polygon)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">vector_space</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">holonomy</span> <span class="o">==</span> <span class="n">V</span><span class="o">.</span><span class="n">zero</span><span class="p">():</span>
            <span class="c1"># not flowing at all!</span>
            <span class="k">return</span> <span class="n">point</span><span class="p">,</span> <span class="n">V</span><span class="o">.</span><span class="n">zero</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_point_position</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="n">translation</span><span class="o">=</span><span class="n">translation</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">translation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">v0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">v0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="n">translation</span>
        <span class="n">w</span><span class="o">=</span><span class="n">holonomy</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()):</span>
            <span class="n">e</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">m</span><span class="o">=</span><span class="n">matrix</span><span class="p">([[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">holonomy</span><span class="p">[</span><span class="mi">0</span><span class="p">]],[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">holonomy</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">=</span><span class="n">m</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">point</span><span class="o">-</span><span class="n">v0</span><span class="p">)</span>
                <span class="n">s</span><span class="o">=</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">t</span><span class="o">=</span><span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># What if the matrix is non-invertible?</span>

                <span class="c1"># s is location it intersects on edge, t is the portion of the holonomy to reach this intersection</span>
                <span class="k">if</span> <span class="n">t</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">s</span> <span class="ow">and</span> <span class="n">s</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># The ray passes through edge i.</span>
                    <span class="k">if</span> <span class="n">t</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># the segment from point with the given holonomy stays within the polygon</span>
                        <span class="k">return</span> <span class="n">point</span><span class="o">+</span><span class="n">holonomy</span><span class="p">,</span> <span class="n">V</span><span class="o">.</span><span class="n">zero</span><span class="p">(),</span> <span class="n">PolygonPosition</span><span class="p">(</span><span class="n">PolygonPosition</span><span class="o">.</span><span class="n">INTERIOR</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">s</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># exits through vertex i+1</span>
                        <span class="n">v0</span><span class="o">=</span><span class="n">v0</span><span class="o">+</span><span class="n">e</span>
                        <span class="k">return</span> <span class="n">v0</span><span class="p">,</span> <span class="n">point</span><span class="o">+</span><span class="n">holonomy</span><span class="o">-</span><span class="n">v0</span><span class="p">,</span> <span class="n">PolygonPosition</span><span class="p">(</span><span class="n">PolygonPosition</span><span class="o">.</span><span class="n">VERTEX</span><span class="p">,</span> <span class="n">vertex</span><span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">())</span>
                    <span class="k">if</span> <span class="n">s</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># exits through vertex i</span>
                        <span class="k">return</span> <span class="n">v0</span><span class="p">,</span> <span class="n">point</span><span class="o">+</span><span class="n">holonomy</span><span class="o">-</span><span class="n">v0</span><span class="p">,</span> <span class="n">PolygonPosition</span><span class="p">(</span><span class="n">PolygonPosition</span><span class="o">.</span><span class="n">VERTEX</span><span class="p">,</span> <span class="n">vertex</span><span class="o">=</span> <span class="n">i</span><span class="p">)</span>
                        <span class="c1"># exits through vertex i</span>
                    <span class="c1"># exits through interior of edge i</span>
                    <span class="n">prod</span><span class="o">=</span><span class="n">t</span><span class="o">*</span><span class="n">holonomy</span>
                    <span class="k">return</span> <span class="n">point</span><span class="o">+</span><span class="n">prod</span><span class="p">,</span> <span class="n">holonomy</span><span class="o">-</span><span class="n">prod</span><span class="p">,</span> <span class="n">PolygonPosition</span><span class="p">(</span><span class="n">PolygonPosition</span><span class="o">.</span><span class="n">EDGE_INTERIOR</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
                <span class="c1"># can safely ignore this error. It means that the edge and the holonomy are parallel.</span>
                <span class="k">pass</span>
            <span class="n">v0</span><span class="o">=</span><span class="n">v0</span><span class="o">+</span><span class="n">e</span>
        <span class="c1"># Our loop has terminated. This can mean one of several errors...</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_point_position</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="n">translation</span><span class="o">=</span><span class="n">translation</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pos</span><span class="o">.</span><span class="n">is_outside</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Started with point outside polygon&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Point on boundary of polygon and holonomy not pointed into the polygon.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="ConvexPolygon.circumscribing_circle"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.ConvexPolygon.circumscribing_circle">[docs]</a>    <span class="k">def</span> <span class="nf">circumscribing_circle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the circle which circumscribes this polygon.</span>
<span class="sd">        Raises a ValueError if the polygon is not circumscribed by a circle.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: P = polygons(vertices=[(0,0),(1,0),(2,1),(-1,1)])</span>
<span class="sd">            sage: P.circumscribing_circle()</span>
<span class="sd">            Circle((1/2, 3/2), 5/2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.circle</span> <span class="kn">import</span> <span class="n">circle_from_three_points</span>
        <span class="n">circle</span> <span class="o">=</span> <span class="n">circle_from_three_points</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">circle</span><span class="o">.</span><span class="n">point_position</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Vertex &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; is not on the circle.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">circle</span></div></div>

<div class="viewcode-block" id="Polygons"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.Polygons">[docs]</a><span class="k">class</span> <span class="nc">Polygons</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">,</span> <span class="n">Parent</span><span class="p">):</span>
    <span class="n">Element</span> <span class="o">=</span> <span class="n">Polygon</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="p">):</span>
        <span class="n">Parent</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">Sets</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">ring</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Rings</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;ring&#39; must be a ring&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ring</span> <span class="o">=</span> <span class="n">ring</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_action</span><span class="p">(</span><span class="n">MatrixActionOnPolygons</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

<div class="viewcode-block" id="Polygons.base_ring"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.Polygons.base_ring">[docs]</a>    <span class="k">def</span> <span class="nf">base_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ring</span></div>

<div class="viewcode-block" id="Polygons.field"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.Polygons.field">[docs]</a>    <span class="k">def</span> <span class="nf">field</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the field over which this polygon is defined.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: P = polygons(vertices=[(0,0),(1,0),(2,1),(-1,1)])</span>
<span class="sd">            sage: P.field()</span>
<span class="sd">            Rational Field</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ring</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">()</span></div>

<div class="viewcode-block" id="Polygons.module"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.Polygons.module">[docs]</a>    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">module</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the free module of rank 2 in which these polygons embed.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import Polygons</span>
<span class="sd">            sage: C = Polygons(QQ)</span>
<span class="sd">            sage: C.module()</span>
<span class="sd">            Vector space of dimension 2 over Rational Field</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">FreeModule</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">(),</span> <span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="Polygons.vector_space"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.Polygons.vector_space">[docs]</a>    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">vector_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the vector space of dimension 2 in which these polygons embed.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import Polygons</span>
<span class="sd">            sage: C = Polygons(QQ)</span>
<span class="sd">            sage: C.vector_space()</span>
<span class="sd">            Vector space of dimension 2 over Rational Field</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">VectorSpace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">(),</span> <span class="mi">2</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Polygons(</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_element_constructor_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import Polygons, ConvexPolygons</span>

<span class="sd">            sage: C = Polygons(QQ)</span>
<span class="sd">            sage: p = C(vertices=[(0,0),(1,0),(2,0),(1,1)])</span>
<span class="sd">            sage: p</span>
<span class="sd">            Polygon: (0, 0), (1, 0), (2, 0), (1, 1)</span>
<span class="sd">            sage: C(p) is p</span>
<span class="sd">            True</span>
<span class="sd">            sage: C((1,0), (0,1), (-1, 1))</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: the polygon does not close up</span>

<span class="sd">            sage: D = ConvexPolygons(QQbar)</span>
<span class="sd">            sage: D(p)</span>
<span class="sd">            Polygon: (0, 0), (1, 0), (2, 0), (1, 1)</span>
<span class="sd">            sage: D(vertices=p.vertices())</span>
<span class="sd">            Polygon: (0, 0), (1, 0), (2, 0), (1, 1)</span>
<span class="sd">            sage: D(edges=p.edges())</span>
<span class="sd">            Polygon: (0, 0), (1, 0), (2, 0), (1, 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;check&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Polygon</span><span class="p">):</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vector_space</span><span class="p">(),</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;vertices&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;edges&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">base_point</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;base_point&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">vertices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">edges</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">args</span><span class="p">:</span>
                    <span class="n">edges</span> <span class="o">=</span> <span class="n">args</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;exactly one of &#39;vertices&#39; or &#39;edges&#39; must be provided&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">kwds</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid keyword </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">kwds</span><span class="p">))))</span>

            <span class="k">if</span> <span class="n">edges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector_space</span><span class="p">()(</span><span class="n">base_point</span><span class="p">)</span>
                <span class="n">vertices</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vector_space</span><span class="p">(),</span> <span class="n">edges</span><span class="p">):</span>
                    <span class="n">vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="n">v</span> <span class="o">+=</span> <span class="n">e</span>
                <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the polygon does not close up&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">check</span><span class="p">)</span></div>

<div class="viewcode-block" id="ConvexPolygons"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.ConvexPolygons">[docs]</a><span class="k">class</span> <span class="nc">ConvexPolygons</span><span class="p">(</span><span class="n">Polygons</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The set of convex polygons with a fixed base field.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import ConvexPolygons</span>
<span class="sd">        sage: C = ConvexPolygons(QQ)</span>
<span class="sd">        sage: C(vertices=[(0,0), (2,0), (1,1)])</span>
<span class="sd">        Polygon: (0, 0), (2, 0), (1, 1)</span>
<span class="sd">        sage: C(edges=[(1,0), (0,1), (-1,0), (0,-1)])</span>
<span class="sd">        Polygon: (0, 0), (1, 0), (1, 1), (0, 1)</span>

<span class="sd">    A set of polygons can also be created over non-fields::</span>

<span class="sd">        sage: ConvexPolygons(ZZ)</span>
<span class="sd">        ConvexPolygons(Integer Ring)</span>

<span class="sd">    TESTS::</span>

<span class="sd">        sage: ConvexPolygons(QQ) is ConvexPolygons(QQ)</span>
<span class="sd">        True</span>
<span class="sd">        sage: TestSuite(ConvexPolygons(QQ)).run()</span>
<span class="sd">        sage: TestSuite(ConvexPolygons(QQbar)).run()</span>
<span class="sd">        sage: TestSuite(ConvexPolygons(ZZ)).run()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Element</span> <span class="o">=</span> <span class="n">ConvexPolygon</span>

<div class="viewcode-block" id="ConvexPolygons.has_coerce_map_from"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.ConvexPolygons.has_coerce_map_from">[docs]</a>    <span class="k">def</span> <span class="nf">has_coerce_map_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import ConvexPolygons</span>
<span class="sd">            sage: C1 = ConvexPolygons(QQ)</span>
<span class="sd">            sage: C2 = ConvexPolygons(AA)</span>
<span class="sd">            sage: C2.has_coerce_map_from(C1)</span>
<span class="sd">            True</span>
<span class="sd">            sage: C1.has_coerce_map_from(C2)</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ConvexPolygons</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="p">()</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">field</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="nf">_an_element_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;ConvexPolygons(</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_element_constructor_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import ConvexPolygons</span>

<span class="sd">            sage: C = ConvexPolygons(QQ)</span>
<span class="sd">            sage: p = C(vertices=[(0,0),(1,0),(2,0),(1,1)])</span>
<span class="sd">            sage: p</span>
<span class="sd">            Polygon: (0, 0), (1, 0), (2, 0), (1, 1)</span>
<span class="sd">            sage: C(p) is p</span>
<span class="sd">            True</span>
<span class="sd">            sage: C((1,0), (0,1), (-1, 1))</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: the polygon does not close up</span>

<span class="sd">            sage: D = ConvexPolygons(QQbar)</span>
<span class="sd">            sage: D(p)</span>
<span class="sd">            Polygon: (0, 0), (1, 0), (2, 0), (1, 1)</span>
<span class="sd">            sage: D(vertices=p.vertices())</span>
<span class="sd">            Polygon: (0, 0), (1, 0), (2, 0), (1, 1)</span>
<span class="sd">            sage: D(edges=p.edges())</span>
<span class="sd">            Polygon: (0, 0), (1, 0), (2, 0), (1, 1)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;check&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Polygon</span><span class="p">):</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vector_space</span><span class="p">(),</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;vertices&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;edges&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">base_point</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;base_point&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">vertices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">edges</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">args</span><span class="p">:</span>
                    <span class="n">edges</span> <span class="o">=</span> <span class="n">args</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;exactly one of &#39;vertices&#39; or &#39;edges&#39; must be provided&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">kwds</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid keyword </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">kwds</span><span class="p">))))</span>

            <span class="k">if</span> <span class="n">edges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">module</span><span class="p">()(</span><span class="n">base_point</span><span class="p">)</span>
                <span class="n">vertices</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">module</span><span class="p">(),</span> <span class="n">edges</span><span class="p">):</span>
                    <span class="n">vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="n">v</span> <span class="o">+=</span> <span class="n">e</span>
                <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the polygon does not close up&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">check</span><span class="p">)</span></div>

<div class="viewcode-block" id="EquiangularPolygons"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.EquiangularPolygons">[docs]</a><span class="k">class</span> <span class="nc">EquiangularPolygons</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Polygons with fixed (rational) angles.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import EquiangularPolygons</span>

<span class="sd">    The polygons with inner angles `\pi/4`, `\pi/2`, `5\pi/4`::</span>

<span class="sd">        sage: P = EquiangularPolygons(1, 2, 5)</span>
<span class="sd">        sage: P</span>
<span class="sd">        EquiangularPolygons(1, 2, 5)</span>

<span class="sd">    Internally, polygons are given by their vertices&#39; coordinates over some</span>
<span class="sd">    number field, in this case a quadratic field::</span>

<span class="sd">        sage: P.base_ring()</span>
<span class="sd">        Number Field in c0 with defining polynomial x^2 - 2 with c0 = 1.414213562373095?</span>

<span class="sd">    Polygons can also be defined over other number field implementations::</span>

<span class="sd">        sage: from pyeantic import RealEmbeddedNumberField # optional: eantic</span>
<span class="sd">        sage: K = RealEmbeddedNumberField(P.base_ring()) # optional: eantic</span>
<span class="sd">        sage: P(K(1)) # optional: eantic</span>
<span class="sd">        Polygon: (0, 0), (1, 0), (1/2*c0, -1/2*c0 + 1)</span>
<span class="sd">        sage: _.base_ring() # optional: eantic</span>
<span class="sd">        Number Field in c0 with defining polynomial x^2 - 2 with c0 = 1.414213562373095?</span>

<span class="sd">    However, specific instances of such polygons might be defined over another ring::</span>

<span class="sd">        sage: P(1)</span>
<span class="sd">        Polygon: (0, 0), (1, 0), (1/2*c0, -1/2*c0 + 1)</span>
<span class="sd">        sage: _.base_ring()</span>
<span class="sd">        Number Field in c0 with defining polynomial x^2 - 2 with c0 = 1.414213562373095?</span>

<span class="sd">        sage: P(AA(1))</span>
<span class="sd">        Polygon: (0, 0), (1, 0), (0.7071067811865475?, 0.2928932188134525?)</span>
<span class="sd">        sage: _.base_ring()</span>
<span class="sd">        Algebraic Real Field</span>

<span class="sd">    Polygons can also be defined over a module containing transcendent parameters::</span>

<span class="sd">        sage: from pyexactreal import ExactReals # optional: exactreal</span>
<span class="sd">        sage: R = ExactReals(P.base_ring()) # optional: exactreal</span>
<span class="sd">        sage: P(R(1)) # optional: exactreal</span>
<span class="sd">        Polygon: (0, 0), (1, 0), ((1/2*c0 ~ 0.70710678), (-1/2*c0+1 ~ 0.29289322))</span>
<span class="sd">        sage: P(R(R.random_element([0.2, 0.3]))) # random output, optional: exactreal</span>
<span class="sd">        Polygon: (0, 0), (â(0.287373=2588422249976937p-53 + â(0.120809â¦)p-54), 0), (((12*c0+17 ~ 33.970563)*â(0.287373=2588422249976937p-53 + â(0.120809â¦)p-54))/((17*c0+24 ~ 48.041631)), ((5*c0+7 ~ 14.071068)*â(0.287373=2588422249976937p-53 + â(0.120809â¦)p-54))/((17*c0+24 ~ 48.041631)))</span>
<span class="sd">        sage: _.base_ring() # optional: exactreal</span>
<span class="sd">        Real Numbers as (Real Embedded Number Field in c0 with defining polynomial x^2 - 2 with c0 = 1.414213562373095?)-Module</span>

<span class="sd">    ::</span>

<span class="sd">        sage: L = P.lengths_polytope()    # polytope of admissible lengths for edges</span>
<span class="sd">        sage: L</span>
<span class="sd">        A 1-dimensional polyhedron in (Number Field in c0 with defining polynomial x^2 - 2 with c0 = 1.414213562373095?)^3 defined as the convex hull of 1 vertex and 1 ray</span>
<span class="sd">        sage: lengths = L.rays()[0].vector()</span>
<span class="sd">        sage: lengths</span>
<span class="sd">        (1, -1/2*c0 + 1, -1/2*c0 + 1)</span>
<span class="sd">        sage: p = P(*lengths)    # build one polygon with the given lengths</span>
<span class="sd">        sage: p</span>
<span class="sd">        Polygon: (0, 0), (1, 0), (1/2*c0, -1/2*c0 + 1)</span>
<span class="sd">        sage: p.angles()</span>
<span class="sd">        [1/16, 1/8, 5/16]</span>
<span class="sd">        sage: P.angles(integral=False)</span>
<span class="sd">        [1/16, 1/8, 5/16]</span>

<span class="sd">        sage: P = EquiangularPolygons(1, 2, 1, 2, 2, 1)</span>
<span class="sd">        sage: L = P.lengths_polytope()</span>
<span class="sd">        sage: L</span>
<span class="sd">        A 4-dimensional polyhedron in (Number Field in c with defining polynomial x^6 - 6*x^4 + 9*x^2 - 3 with c = 1.969615506024417?)^6 defined as the convex hull of 1 vertex and 6 rays</span>
<span class="sd">        sage: rays = [r.vector() for r in L.rays()]</span>
<span class="sd">        sage: rays</span>
<span class="sd">        [(1, 0, 0, 0, -1/6*c^5 + 5/6*c^3 - 2/3*c, -1/6*c^5 + 5/6*c^3 - 2/3*c),</span>
<span class="sd">         (0, 1, 0, 0, c^2 - 3, c^2 - 2),</span>
<span class="sd">         (1/3*c^4 - 2*c^2 + 3, 0, -1/6*c^5 + 5/6*c^3 - 2/3*c, 0, 0, -1/6*c^5 + 5/6*c^3 - 2/3*c),</span>
<span class="sd">         (-c^4 + 4*c^2, 0, 0, -1/6*c^5 + 5/6*c^3 - 2/3*c, 0, -1/6*c^5 + 5/6*c^3 - 2/3*c),</span>
<span class="sd">         (0, 1/3*c^4 - 2*c^2 + 3, c^2 - 3, 0, 0, 1/3*c^4 - c^2),</span>
<span class="sd">         (0, -c^4 + 4*c^2, 0, c^2 - 3, 0, -c^4 + 5*c^2 - 3)]</span>
<span class="sd">        sage: lengths = 3*rays[0] + rays[2] + 2*rays[3] + rays[4]</span>
<span class="sd">        sage: p = P(*lengths)</span>
<span class="sd">        sage: p</span>
<span class="sd">        Polygon: (0, 0), (-5/3*c^4 + 6*c^2 + 6, 0), (3*c^5 - 5/3*c^4 - 16*c^3 + 6*c^2 + 18*c + 6, c^4 - 6*c^2 + 9), (2*c^5 - 2*c^4 - 10*c^3 + 15/2*c^2 + 9*c + 5, -1/2*c^5 + c^4 + 5/2*c^3 - 3*c^2 - 2*c), (2*c^5 - 10*c^3 - 3/2*c^2 + 9*c + 9, -3/2*c^5 + c^4 + 15/2*c^3 - 3*c^2 - 6*c), (2*c^5 - 10*c^3 - 3*c^2 + 9*c + 12, -3*c^5 + c^4 + 15*c^3 - 3*c^2 - 12*c)</span>

<span class="sd">        sage: p.angles()</span>
<span class="sd">        [2/9, 4/9, 2/9, 4/9, 4/9, 2/9]</span>

<span class="sd">        sage: EquiangularPolygons(1, 2, 1, 2, 1, 2, 1, 2, 2, 2, 2, 1, 1, 2, 1)</span>
<span class="sd">        EquiangularPolygons(1, 2, 1, 2, 1, 2, 1, 2, 2, 2, 2, 1, 1, 2, 1)</span>

<span class="sd">    A regular pentagon::</span>

<span class="sd">        sage: E = EquiangularPolygons(1, 1, 1, 1, 1)</span>
<span class="sd">        sage: E(1, 1, 1, 1, 1, normalized=True)</span>
<span class="sd">        Polygon: (0, 0), (1, 0), (1/2*c^2 - 1/2, 1/2*c), (1/2, 1/2*c^3 - c), (-1/2*c^2 + 3/2, 1/2*c)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">angles</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;number_field&#39;</span> <span class="ow">in</span> <span class="n">kwds</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The number_field parameter has been removed in this release of sage-flatsurf. To create an equiangular polygon over a number field, do not pass this parameter; to create an equiangular polygon over the algebraic numbers, do not pass this parameter but call the returned object with algebraic lengths.&quot;</span><span class="p">)</span>
            <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;number_field&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwds</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid keyword </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">kwds</span><span class="p">))))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;angles&#39; should be a list of at least 3 numbers&quot;</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="p">[</span><span class="n">QQ</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">angle</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">angle</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;angles&#39; must be positive rational numbers&quot;</span><span class="p">)</span>

        <span class="c1"># Store each angle as a multiple of 2Ï, i.e., normalize them such their sum is (n - 2)/2.</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">]</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="o">*</span> <span class="n">ZZ</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">angle</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">angle</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">angle</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;each angle must be &gt; 0 and &lt; 2 pi&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_angles</span> <span class="o">=</span> <span class="n">angles</span>
        <span class="k">assert</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_angles</span><span class="p">)</span> <span class="o">==</span> <span class="n">ZZ</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="c1"># We determine the number field that contains the slopes of the sides,</span>
        <span class="c1"># i.e., the cosines and sines of the inner angles of the polygon.</span>
        <span class="c1"># Let us first write all angles as multiples of 2Ï/N with the smallest</span>
        <span class="c1"># possible common N.</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">lcm</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">)</span>
        <span class="c1"># The field containing the cosine and sine of 2Ï/N might be too small</span>
        <span class="c1"># to write down all the slopes when N is not divisible by 4.</span>
        <span class="k">assert</span> <span class="n">N</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;there cannot be a polygon with all angles multiples of 2Ï&quot;</span>
        <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">N</span> <span class="o">%</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">N</span> <span class="o">%</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">N</span> <span class="o">*=</span> <span class="mi">2</span>

        <span class="n">angles</span> <span class="o">=</span> <span class="p">[</span><span class="n">ZZ</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_base_ring</span> <span class="o">=</span> <span class="n">QQ</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">QQ</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Construct the minimal polynomial f(x) of c = 2 cos(2Ï / N)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">cos_minpoly</span><span class="p">(</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">emb</span> <span class="o">=</span> <span class="n">AA</span><span class="o">.</span><span class="n">polynomial_root</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">RIF</span><span class="o">.</span><span class="n">pi</span><span class="p">()</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">cos</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_base_ring</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">embedding</span><span class="o">=</span><span class="n">emb</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_ring</span><span class="o">.</span><span class="n">gen</span><span class="p">()</span>

        <span class="c1"># Construct the cosine and sine of each angle as an element of our number field.</span>
        <span class="k">def</span> <span class="nf">cosine</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">chebyshev_T</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">def</span> <span class="nf">sine</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="c1"># Use sin(x) = cos(Ï/2 - x)</span>
            <span class="k">return</span> <span class="n">cosine</span><span class="p">(</span><span class="n">N</span><span class="o">//</span><span class="mi">4</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
        <span class="n">slopes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">cosine</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">sine</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">((</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">is_one</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">slopes</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_slopes</span> <span class="o">=</span> <span class="p">[</span><span class="n">projectivization</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">slopes</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cosines_ring</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_ring</span>

        <span class="c1"># TODO: It might be the case that the slopes generate a smaller</span>
        <span class="c1"># field. For now we use an ugly workaround via subfield_from_elements.</span>
        <span class="n">old_slopes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slopes</span><span class="p">:</span>
            <span class="n">old_slopes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">L</span><span class="p">,</span> <span class="n">new_slopes</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">subfield_from_elements</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_base_ring</span><span class="p">,</span> <span class="n">old_slopes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">L</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_ring</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_slopes</span> <span class="o">=</span> <span class="p">[</span><span class="n">projectivization</span><span class="p">(</span><span class="o">*</span><span class="n">new_slopes</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">old_slopes</span><span class="p">),</span> <span class="mi">2</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_base_ring</span> <span class="o">=</span> <span class="n">L</span>

<div class="viewcode-block" id="EquiangularPolygons.convexity"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.EquiangularPolygons.convexity">[docs]</a>    <span class="k">def</span> <span class="nf">convexity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import EquiangularPolygons</span>
<span class="sd">            sage: EquiangularPolygons(1, 2, 5).convexity()</span>
<span class="sd">            True</span>
<span class="sd">            sage: EquiangularPolygons(2, 2, 3, 13).convexity()</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_angles</span><span class="p">)</span></div>

<div class="viewcode-block" id="EquiangularPolygons.base_ring"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.EquiangularPolygons.base_ring">[docs]</a>    <span class="k">def</span> <span class="nf">base_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number field over which the coordinates of the vertices of</span>
<span class="sd">        this family of polygons are represented internally.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import EquiangularPolygons</span>
<span class="sd">            sage: EquiangularPolygons(1, 2, 5).base_ring()</span>
<span class="sd">            Number Field in c0 with defining polynomial x^2 - 2 with c0 = 1.414213562373095?</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_ring</span></div>

<div class="viewcode-block" id="EquiangularPolygons.strict_convexity"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.EquiangularPolygons.strict_convexity">[docs]</a>    <span class="k">def</span> <span class="nf">strict_convexity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import EquiangularPolygons</span>
<span class="sd">            sage: E = EquiangularPolygons([1, 1, 1, 1, 2])</span>
<span class="sd">            sage: E.angles()</span>
<span class="sd">            [1/4, 1/4, 1/4, 1/4, 1/2]</span>
<span class="sd">            sage: E.convexity()</span>
<span class="sd">            True</span>
<span class="sd">            sage: E.strict_convexity()</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_angles</span><span class="p">)</span></div>

<div class="viewcode-block" id="EquiangularPolygons.angles"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.EquiangularPolygons.angles">[docs]</a>    <span class="k">def</span> <span class="nf">angles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">integral</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the interior angles of this polygon as multiples 2Ï.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import EquiangularPolygons</span>
<span class="sd">            sage: E = EquiangularPolygons(1, 1, 1, 2, 6)</span>
<span class="sd">            sage: E.angles()</span>
<span class="sd">            [3/22, 3/22, 3/22, 3/11, 9/11]</span>

<span class="sd">        When ``integral`` is set, the output is scaled to eliminate</span>
<span class="sd">        denominators::</span>

<span class="sd">            sage: E.angles(integral=True)</span>
<span class="sd">            [1, 1, 1, 2, 6]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_angles</span>
        <span class="k">if</span> <span class="n">integral</span><span class="p">:</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">lcm</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_angles</span><span class="p">])</span> <span class="o">/</span> <span class="n">gcd</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">numerator</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_angles</span><span class="p">])</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="p">[</span><span class="n">ZZ</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">angles</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import EquiangularPolygons</span>
<span class="sd">            sage: EquiangularPolygons(1, 2, 3)</span>
<span class="sd">            EquiangularPolygons(1, 2, 3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;EquiangularPolygons(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">(</span><span class="kc">True</span><span class="p">))))</span>

<div class="viewcode-block" id="EquiangularPolygons.module"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.EquiangularPolygons.module">[docs]</a>    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">module</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the free module of rank 2 in which these polygons embed.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import EquiangularPolygons</span>
<span class="sd">            sage: C = EquiangularPolygons(1, 2, 3)</span>
<span class="sd">            sage: C.module()</span>
<span class="sd">            Vector space of dimension 2 over Number Field in c with defining polynomial x^2 - 3 with c = 1.732050807568878?</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">FreeModule</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_base_ring</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="EquiangularPolygons.vector_space"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.EquiangularPolygons.vector_space">[docs]</a>    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">vector_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the vector space of dimension 2 in which these polygons embed.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import EquiangularPolygons</span>
<span class="sd">            sage: C = EquiangularPolygons(1, 2, 3)</span>
<span class="sd">            sage: C.vector_space()</span>
<span class="sd">            Vector space of dimension 2 over Number Field in c with defining polynomial x^2 - 3 with c = 1.732050807568878?</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">VectorSpace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_base_ring</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">(),</span> <span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="EquiangularPolygons.slopes"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.EquiangularPolygons.slopes">[docs]</a>    <span class="k">def</span> <span class="nf">slopes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e0</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        List of slopes of the edges as a list of vectors.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import EquiangularPolygons</span>
<span class="sd">            sage: EquiangularPolygons(1, 2, 1, 2).slopes()</span>
<span class="sd">            [(1, 0), (c, 3), (-1, 0), (-c, -3)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">module</span><span class="p">()</span>
        <span class="n">slopes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slopes</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">slopes</span><span class="p">)</span>
        <span class="n">cosines</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">slopes</span><span class="p">]</span>
        <span class="n">sines</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">slopes</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">V</span><span class="p">(</span><span class="n">e0</span><span class="p">)</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">cosines</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">sines</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sines</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">cosines</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">projectivization</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span>
            <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">V</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">edges</span></div>

    <span class="c1"># TODO: rather than lengths, it would be more convenient to have access</span>
    <span class="c1"># to the tangent space (that is the space of possible holonomies). However,</span>
    <span class="c1"># since it is not defined over the real numbers, there are several possible ways</span>
    <span class="c1"># to handle the data.</span>
    <span class="c1"># TODO: here we ignored the direction SO(2) which provides additional symmetry</span>
    <span class="c1"># in the tangent space</span>
<div class="viewcode-block" id="EquiangularPolygons.lengths_polytope"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.EquiangularPolygons.lengths_polytope">[docs]</a>    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">lengths_polytope</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the polytope parametrizing the admissible vectors data.</span>

<span class="sd">        This polytope parametrizes the tangent space to the set of these</span>
<span class="sd">        equiangular polygons. Be careful that even though the lengths are</span>
<span class="sd">        admissible, they may not define a polygon without intersection.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import EquiangularPolygons</span>
<span class="sd">            sage: EquiangularPolygons(1, 2, 1, 2).lengths_polytope()</span>
<span class="sd">            A 2-dimensional polyhedron in (Number Field in c with defining polynomial x^2 - 3 with c = 1.732050807568878?)^4 defined as the convex hull of 1 vertex and 2 rays</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_angles</span><span class="p">)</span>
        <span class="n">slopes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slopes</span><span class="p">()</span>
        <span class="n">eqns</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">slopes</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">slopes</span><span class="p">]]</span>
        <span class="n">ieqs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">ieq</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ieq</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">ieqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ieq</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">sage.geometry.polyhedron.constructor</span> <span class="kn">import</span> <span class="n">Polyhedron</span>
        <span class="k">return</span> <span class="n">Polyhedron</span><span class="p">(</span><span class="n">eqns</span><span class="o">=</span><span class="n">eqns</span><span class="p">,</span> <span class="n">ieqs</span><span class="o">=</span><span class="n">ieqs</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_base_ring</span><span class="p">)</span></div>

<div class="viewcode-block" id="EquiangularPolygons.an_element"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.EquiangularPolygons.an_element">[docs]</a>    <span class="k">def</span> <span class="nf">an_element</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a polygon in this family.</span>

<span class="sd">        Note that this might fail due to intersection.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import EquiangularPolygons</span>
<span class="sd">            sage: EquiangularPolygons(4, 3, 4, 4, 3, 4).an_element()</span>
<span class="sd">            Polygon: (0, 0), (1/22*c + 1, 0), (9*c^9 + 1/2*c^8 - 88*c^7 - 9/2*c^6 + 297*c^5 + 27/2*c^4 - 396*c^3 - 15*c^2 + 3631/22*c + 11/2, 1/2*c + 11), (16*c^9 + c^8 - 154*c^7 - 9*c^6 + 506*c^5 + 27*c^4 - 638*c^3 - 30*c^2 + 4841/22*c + 9, c + 22), (16*c^9 + c^8 - 154*c^7 - 9*c^6 + 506*c^5 + 27*c^4 - 638*c^3 - 30*c^2 + 220*c + 8, c + 22), (7*c^9 + 1/2*c^8 - 66*c^7 - 9/2*c^6 + 209*c^5 + 27/2*c^4 - 242*c^3 - 15*c^2 + 55*c + 7/2, 1/2*c + 11)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lengths_polytope</span><span class="p">()</span><span class="o">.</span><span class="n">rays</span><span class="p">()))</span></div>

<div class="viewcode-block" id="EquiangularPolygons.random_element"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.EquiangularPolygons.random_element">[docs]</a>    <span class="k">def</span> <span class="nf">random_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a random polygon.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import EquiangularPolygons</span>
<span class="sd">            sage: EquiangularPolygons(1, 1, 1, 2, 5).random_element()</span>
<span class="sd">            Polygon: (0, 0), ...</span>
<span class="sd">            sage: EquiangularPolygons(1,1,1,15,15,15).random_element()</span>
<span class="sd">            Polygon: (0, 0), ...</span>
<span class="sd">            sage: EquiangularPolygons(1,15,1,15,1,15).random_element()</span>
<span class="sd">            Polygon: (0, 0), ...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ring</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ring</span> <span class="o">=</span> <span class="n">QQ</span>

        <span class="n">rays</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lengths_polytope</span><span class="p">()</span><span class="o">.</span><span class="n">rays</span><span class="p">()]</span>
        <span class="k">def</span> <span class="nf">random_element</span><span class="p">():</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">rays</span><span class="p">):</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">random_element</span><span class="p">(</span><span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
                    <span class="k">while</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">random_element</span><span class="p">(</span><span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
                    <span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

                <span class="n">sol</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">r</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">rays</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sol</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">sol</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">coeffs</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">random_element</span><span class="p">()</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="o">*</span><span class="n">r</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;edge &#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;intersect&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39; and edge &#39;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;unexpected error with coeffs </span><span class="si">{!r}</span><span class="s2"> ~ </span><span class="si">{!r}</span><span class="s2">: </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="p">[</span><span class="n">numerical_approx</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">coeffs</span><span class="p">],</span> <span class="n">e</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">lengths</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import EquiangularPolygons</span>
<span class="sd">            sage: P = EquiangularPolygons(1, 2, 1, 2)</span>
<span class="sd">            sage: L = P.lengths_polytope()</span>
<span class="sd">            sage: r0, r1 = [r.vector() for r in L.rays()]</span>
<span class="sd">            sage: lengths = r0 + r1</span>
<span class="sd">            sage: P(*lengths[:-2])</span>
<span class="sd">            Polygon: (0, 0), (1, 0), (c + 1, 3), (c, 3)</span>

<span class="sd">            sage: P = EquiangularPolygons(2, 2, 3, 13)</span>
<span class="sd">            sage: r0, r1 = [r.vector() for r in P.lengths_polytope().rays()]</span>
<span class="sd">            sage: P(r0 + r1)</span>
<span class="sd">            Polygon: (0, 0), (20, 0), (5, -15*c^3 + 60*c), (5, -5*c^3 + 20*c)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">Vector</span><span class="p">)):</span>
            <span class="n">lengths</span> <span class="o">=</span> <span class="n">lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_angles</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;must provide </span><span class="si">%d</span><span class="s2"> or </span><span class="si">%d</span><span class="s2"> lengths but provided </span><span class="si">%d</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lengths</span><span class="p">)))</span>

        <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">module</span><span class="p">()</span>
        <span class="n">slopes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slopes</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">normalized</span><span class="p">:</span>
            <span class="n">V</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cosines_ring</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slopes</span><span class="p">):</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cosines_ring</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
                <span class="n">norm2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
                <span class="n">slopes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">V</span><span class="p">((</span><span class="n">x</span><span class="o">/</span><span class="n">norm2</span><span class="p">,</span> <span class="n">y</span><span class="o">/</span><span class="n">norm2</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">base_ring</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">Sequence</span>
            <span class="n">base_ring</span> <span class="o">=</span> <span class="n">Sequence</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span><span class="o">.</span><span class="n">universe</span><span class="p">()</span>

            <span class="kn">from</span> <span class="nn">sage.categories.pushout</span> <span class="kn">import</span> <span class="n">pushout</span>
            <span class="k">if</span> <span class="n">normalized</span><span class="p">:</span>
                <span class="n">base_ring</span> <span class="o">=</span> <span class="n">pushout</span><span class="p">(</span><span class="n">base_ring</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cosines_ring</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">base_ring</span> <span class="o">=</span> <span class="n">pushout</span><span class="p">(</span><span class="n">base_ring</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_ring</span><span class="p">)</span>

        <span class="n">v</span> <span class="o">=</span> <span class="n">V</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">+=</span> <span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">slopes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">vertices</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">matrix</span><span class="p">([</span><span class="n">slopes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">slopes</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]])</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span>
            <span class="k">assert</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">s</span> <span class="o">*</span> <span class="n">slopes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">vertices</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">slopes</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the provided lengths do not give rise to a polygon&quot;</span><span class="p">)</span>
            <span class="n">vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">s</span> <span class="o">*</span> <span class="n">slopes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">+=</span> <span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">slopes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">vertices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_zero</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the provided lengths do not give rise to a polygon&quot;</span><span class="p">)</span>
            <span class="n">vertices</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">convexity</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">ConvexPolygons</span><span class="p">(</span><span class="n">base_ring</span><span class="p">)(</span><span class="n">vertices</span><span class="o">=</span><span class="n">vertices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Polygons</span><span class="p">(</span><span class="n">base_ring</span><span class="p">)(</span><span class="n">vertices</span><span class="o">=</span><span class="n">vertices</span><span class="p">)</span>

<div class="viewcode-block" id="EquiangularPolygons.billiard_unfolding_angles"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.EquiangularPolygons.billiard_unfolding_angles">[docs]</a>    <span class="k">def</span> <span class="nf">billiard_unfolding_angles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cover_type</span><span class="o">=</span><span class="s2">&quot;translation&quot;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the angles of the unfolding rational, half-translation or translation surface.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``cover_type`` (optional, default ``&quot;translation&quot;``) - either ``&quot;rational&quot;``,</span>
<span class="sd">          ``&quot;half-translation&quot;`` or ``&quot;translation&quot;``</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import EquiangularPolygons</span>

<span class="sd">            sage: E = EquiangularPolygons(1, 2, 5)</span>
<span class="sd">            sage: E.billiard_unfolding_angles(cover_type=&quot;rational&quot;)</span>
<span class="sd">            {1/8: 1, 1/4: 1, 5/8: 1}</span>
<span class="sd">            sage: (1/8 - 1) + (1/4 - 1) + (5/8 - 1)  # Euler characteristic (of the sphere)</span>
<span class="sd">            -2</span>
<span class="sd">            sage: E.billiard_unfolding_angles(cover_type=&quot;half-translation&quot;)</span>
<span class="sd">            {1/2: 3, 5/2: 1}</span>
<span class="sd">            sage: E.billiard_unfolding_angles(cover_type=&quot;translation&quot;)</span>
<span class="sd">            {1: 3, 5: 1}</span>

<span class="sd">            sage: E = EquiangularPolygons(1, 3, 1, 7)</span>
<span class="sd">            sage: E.billiard_unfolding_angles(cover_type=&quot;rational&quot;)</span>
<span class="sd">            {1/6: 2, 1/2: 1, 7/6: 1}</span>
<span class="sd">            sage: 2 * (1/6 - 1) + (1/2 - 1) + (7/6 - 1) # Euler characteristic</span>
<span class="sd">            -2</span>
<span class="sd">            sage: E.billiard_unfolding_angles(cover_type=&quot;half-translation&quot;)</span>
<span class="sd">            {1/2: 5, 7/2: 1}</span>
<span class="sd">            sage: E.billiard_unfolding_angles(cover_type=&quot;translation&quot;)</span>
<span class="sd">            {1: 5, 7: 1}</span>

<span class="sd">            sage: E = EquiangularPolygons(1, 3, 5, 7)</span>
<span class="sd">            sage: E.billiard_unfolding_angles(cover_type=&quot;rational&quot;)</span>
<span class="sd">            {1/8: 1, 3/8: 1, 5/8: 1, 7/8: 1}</span>
<span class="sd">            sage: (1/8 - 1) + (3/8 - 1) + (5/8 - 1) + (7/8 - 1) # Euler characteristic</span>
<span class="sd">            -2</span>
<span class="sd">            sage: E.billiard_unfolding_angles(cover_type=&quot;half-translation&quot;)</span>
<span class="sd">            {1/2: 1, 3/2: 1, 5/2: 1, 7/2: 1}</span>
<span class="sd">            sage: E.billiard_unfolding_angles(cover_type=&quot;translation&quot;)</span>
<span class="sd">            {1: 1, 3: 1, 5: 1, 7: 1}</span>

<span class="sd">            sage: E = EquiangularPolygons(1, 2, 8)</span>
<span class="sd">            sage: E.billiard_unfolding_angles(cover_type=&quot;rational&quot;)</span>
<span class="sd">            {1/11: 1, 2/11: 1, 8/11: 1}</span>
<span class="sd">            sage: (1/11 - 1) + (2/11 - 1) + (8/11 - 1) # Euler characteristic</span>
<span class="sd">            -2</span>
<span class="sd">            sage: E.billiard_unfolding_angles(cover_type=&quot;half-translation&quot;)</span>
<span class="sd">            {1: 1, 2: 1, 8: 1}</span>
<span class="sd">            sage: E.billiard_unfolding_angles(cover_type=&quot;translation&quot;)</span>
<span class="sd">            {1: 1, 2: 1, 8: 1}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rat_angles</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">():</span>
            <span class="k">if</span> <span class="mi">2</span><span class="o">*</span><span class="n">a</span> <span class="ow">in</span> <span class="n">rat_angles</span><span class="p">:</span>
                <span class="n">rat_angles</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rat_angles</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">cover_type</span> <span class="o">==</span> <span class="s2">&quot;rational&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rat_angles</span>

        <span class="n">N</span> <span class="o">=</span> <span class="n">lcm</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">rat_angles</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">N</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">*=</span> <span class="mi">2</span>

        <span class="n">cov_angles</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">mult</span> <span class="ow">in</span> <span class="n">rat_angles</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">numerator</span><span class="p">()</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">%</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">*=</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">/</span><span class="mi">2</span>
            <span class="k">assert</span> <span class="n">N</span> <span class="o">%</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">cov_angles</span><span class="p">:</span>
                <span class="n">cov_angles</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">+=</span> <span class="n">mult</span> <span class="o">*</span> <span class="n">N</span><span class="o">//</span><span class="n">d</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cov_angles</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">mult</span> <span class="o">*</span> <span class="n">N</span><span class="o">//</span><span class="n">d</span>

        <span class="k">if</span> <span class="n">cover_type</span> <span class="o">==</span> <span class="s2">&quot;translation&quot;</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">cov_angles</span><span class="p">):</span>
            <span class="n">covcov_angles</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">y</span><span class="p">,</span><span class="n">mult</span> <span class="ow">in</span> <span class="n">cov_angles</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">yy</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">numerator</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">yy</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">covcov_angles</span><span class="p">:</span>
                    <span class="n">covcov_angles</span><span class="p">[</span><span class="n">yy</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">covcov_angles</span><span class="p">[</span><span class="n">yy</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">//</span><span class="n">y</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span> <span class="o">*</span> <span class="n">mult</span>
            <span class="k">return</span> <span class="n">covcov_angles</span>
        <span class="k">elif</span> <span class="n">cover_type</span> <span class="o">==</span> <span class="s2">&quot;half-translation&quot;</span> <span class="ow">or</span> <span class="n">cover_type</span> <span class="o">==</span> <span class="s2">&quot;translation&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cov_angles</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unknown &#39;cover_type&#39; </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cover_type</span><span class="p">))</span></div>

<div class="viewcode-block" id="EquiangularPolygons.billiard_unfolding_stratum"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.EquiangularPolygons.billiard_unfolding_stratum">[docs]</a>    <span class="k">def</span> <span class="nf">billiard_unfolding_stratum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cover_type</span><span class="o">=</span><span class="s2">&quot;translation&quot;</span><span class="p">,</span> <span class="n">marked_points</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the stratum of quadratic or Abelian differential obtained by</span>
<span class="sd">        unfolding a billiard in a polygon of this equiangular family.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``cover_type`` (optional, default ``&quot;translation&quot;``) - either ``&quot;rational&quot;``,</span>
<span class="sd">          ``&quot;half-translation&quot;`` or ``&quot;translation&quot;``</span>

<span class="sd">        - ``marked_poins`` (optional, default ``False``) - whether the stratum should</span>
<span class="sd">          have regular marked points</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import EquiangularPolygons, similarity_surfaces</span>

<span class="sd">            sage: E = EquiangularPolygons(1, 2, 5)</span>
<span class="sd">            sage: E.billiard_unfolding_stratum(&quot;half-translation&quot;)</span>
<span class="sd">            Q_1(3, -1^3)</span>
<span class="sd">            sage: E.billiard_unfolding_stratum(&quot;translation&quot;)</span>
<span class="sd">            H_3(4)</span>
<span class="sd">            sage: E.billiard_unfolding_stratum(&quot;half-translation&quot;, True)</span>
<span class="sd">            Q_1(3, -1^3)</span>
<span class="sd">            sage: E.billiard_unfolding_stratum(&quot;translation&quot;, True)</span>
<span class="sd">            H_3(4, 0^3)</span>

<span class="sd">            sage: E = EquiangularPolygons(1, 3, 1, 7)</span>
<span class="sd">            sage: E.billiard_unfolding_stratum(&quot;half-translation&quot;)</span>
<span class="sd">            Q_1(5, -1^5)</span>
<span class="sd">            sage: E.billiard_unfolding_stratum(&quot;translation&quot;)</span>
<span class="sd">            H_4(6)</span>
<span class="sd">            sage: E.billiard_unfolding_stratum(&quot;half-translation&quot;, True)</span>
<span class="sd">            Q_1(5, -1^5)</span>
<span class="sd">            sage: E.billiard_unfolding_stratum(&quot;translation&quot;, True)</span>
<span class="sd">            H_4(6, 0^5)</span>

<span class="sd">            sage: P = E.an_element()</span>
<span class="sd">            sage: S = similarity_surfaces.billiard(P)</span>
<span class="sd">            sage: S.minimal_cover(&quot;half-translation&quot;).stratum()</span>
<span class="sd">            Q_1(5, -1^5)</span>
<span class="sd">            sage: S.minimal_cover(&quot;translation&quot;).stratum()</span>
<span class="sd">            H_4(6, 0^5)</span>

<span class="sd">            sage: E = EquiangularPolygons(1, 3, 5, 7)</span>
<span class="sd">            sage: E.billiard_unfolding_stratum(&quot;half-translation&quot;)</span>
<span class="sd">            Q_3(5, 3, 1, -1)</span>
<span class="sd">            sage: E.billiard_unfolding_stratum(&quot;translation&quot;)</span>
<span class="sd">            H_7(6, 4, 2)</span>

<span class="sd">            sage: P = E.an_element()</span>
<span class="sd">            sage: S = similarity_surfaces.billiard(P)</span>
<span class="sd">            sage: S.minimal_cover(&quot;half-translation&quot;).stratum()</span>
<span class="sd">            Q_3(5, 3, 1, -1)</span>
<span class="sd">            sage: S.minimal_cover(&quot;translation&quot;).stratum()</span>
<span class="sd">            H_7(6, 4, 2, 0)</span>

<span class="sd">            sage: E = EquiangularPolygons(1, 2, 8)</span>
<span class="sd">            sage: E.billiard_unfolding_stratum(&quot;half-translation&quot;)</span>
<span class="sd">            H_5(7, 1)</span>
<span class="sd">            sage: E.billiard_unfolding_stratum(&quot;translation&quot;)</span>
<span class="sd">            H_5(7, 1)</span>

<span class="sd">            sage: E.billiard_unfolding_stratum(&quot;half-translation&quot;, True)</span>
<span class="sd">            H_5(7, 1, 0)</span>
<span class="sd">            sage: E.billiard_unfolding_stratum(&quot;translation&quot;, True)</span>
<span class="sd">            H_5(7, 1, 0)</span>

<span class="sd">            sage: E = EquiangularPolygons(9, 6, 3, 2)</span>
<span class="sd">            sage: p = E.an_element()</span>
<span class="sd">            sage: B = similarity_surfaces.billiard(p)</span>
<span class="sd">            sage: B.minimal_cover(&quot;half-translation&quot;).stratum()</span>
<span class="sd">            Q_4(7, 4, 1, 0)</span>
<span class="sd">            sage: E.billiard_unfolding_stratum(&quot;half-translation&quot;, True)</span>
<span class="sd">            Q_4(7, 4, 1, 0)</span>
<span class="sd">            sage: B.minimal_cover(&quot;translation&quot;).stratum()</span>
<span class="sd">            H_8(8, 2^3, 0^2)</span>
<span class="sd">            sage: E.billiard_unfolding_stratum(&quot;translation&quot;, True)</span>
<span class="sd">            H_8(8, 2^3, 0^2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">billiard_unfolding_angles</span><span class="p">(</span><span class="n">cover_type</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">surface_dynamics</span> <span class="kn">import</span> <span class="n">AbelianStratum</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">marked_points</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">AbelianStratum</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">AbelianStratum</span><span class="p">({</span><span class="n">ZZ</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="n">mult</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">mult</span> <span class="ow">in</span> <span class="n">angles</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">marked_points</span> <span class="ow">or</span> <span class="n">a</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">surface_dynamics</span> <span class="kn">import</span> <span class="n">QuadraticStratum</span>
            <span class="k">return</span> <span class="n">QuadraticStratum</span><span class="p">({</span><span class="n">ZZ</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span> <span class="n">mult</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">mult</span> <span class="ow">in</span> <span class="n">angles</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">marked_points</span> <span class="ow">or</span> <span class="n">a</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">})</span></div>

<div class="viewcode-block" id="EquiangularPolygons.billiard_unfolding_stratum_dimension"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.EquiangularPolygons.billiard_unfolding_stratum_dimension">[docs]</a>    <span class="k">def</span> <span class="nf">billiard_unfolding_stratum_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cover_type</span><span class="o">=</span><span class="s2">&quot;translation&quot;</span><span class="p">,</span> <span class="n">marked_points</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the dimension of the stratum of quadratic or Abelian differential</span>
<span class="sd">        obtained by unfolding a billiard in a polygon of this equiangular family.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``cover_type`` (optional, default ``&quot;translation&quot;``) - either ``&quot;rational&quot;``,</span>
<span class="sd">          ``&quot;half-translation&quot;`` or ``&quot;translation&quot;``</span>

<span class="sd">        - ``marked_poins`` (optional, default ``False``) - whether the stratum should</span>
<span class="sd">          have marked regular points</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import EquiangularPolygons</span>

<span class="sd">            sage: E = EquiangularPolygons(1, 1, 1)</span>
<span class="sd">            sage: E.billiard_unfolding_stratum_dimension(&quot;half-translation&quot;)</span>
<span class="sd">            2</span>
<span class="sd">            sage: E.billiard_unfolding_stratum_dimension(&quot;translation&quot;)</span>
<span class="sd">            2</span>
<span class="sd">            sage: E.billiard_unfolding_stratum_dimension(&quot;half-translation&quot;, True)</span>
<span class="sd">            4</span>
<span class="sd">            sage: E.billiard_unfolding_stratum_dimension(&quot;translation&quot;, True)</span>
<span class="sd">            4</span>

<span class="sd">            sage: E = EquiangularPolygons(1, 2, 5)</span>
<span class="sd">            sage: E.billiard_unfolding_stratum_dimension(&quot;half-translation&quot;)</span>
<span class="sd">            4</span>
<span class="sd">            sage: E.billiard_unfolding_stratum(&quot;half-translation&quot;).dimension()</span>
<span class="sd">            4</span>
<span class="sd">            sage: E.billiard_unfolding_stratum_dimension(cover_type=&quot;translation&quot;)</span>
<span class="sd">            6</span>
<span class="sd">            sage: E.billiard_unfolding_stratum(&quot;translation&quot;).dimension()</span>
<span class="sd">            6</span>
<span class="sd">            sage: E.billiard_unfolding_stratum_dimension(&quot;translation&quot;, True)</span>
<span class="sd">            9</span>
<span class="sd">            sage: E.billiard_unfolding_stratum(&quot;translation&quot;, True).dimension()</span>
<span class="sd">            9</span>

<span class="sd">            sage: E = EquiangularPolygons(1, 3, 5)</span>
<span class="sd">            sage: E.billiard_unfolding_stratum_dimension(&quot;half-translation&quot;)</span>
<span class="sd">            6</span>
<span class="sd">            sage: E.billiard_unfolding_stratum(&quot;half-translation&quot;).dimension()</span>
<span class="sd">            6</span>
<span class="sd">            sage: E.billiard_unfolding_stratum_dimension(&quot;translation&quot;)</span>
<span class="sd">            6</span>
<span class="sd">            sage: E.billiard_unfolding_stratum(&quot;translation&quot;).dimension()</span>
<span class="sd">            6</span>

<span class="sd">            sage: E = EquiangularPolygons(1, 3, 1, 7)</span>
<span class="sd">            sage: E.billiard_unfolding_stratum_dimension(&quot;half-translation&quot;)</span>
<span class="sd">            6</span>

<span class="sd">            sage: E = EquiangularPolygons(1, 3, 5, 7)</span>
<span class="sd">            sage: E.billiard_unfolding_stratum_dimension(&quot;half-translation&quot;)</span>
<span class="sd">            8</span>

<span class="sd">            sage: E = EquiangularPolygons(1, 2, 8)</span>
<span class="sd">            sage: E.billiard_unfolding_stratum_dimension()</span>
<span class="sd">            11</span>
<span class="sd">            sage: E.billiard_unfolding_stratum().dimension()</span>
<span class="sd">            11</span>
<span class="sd">            sage: E.billiard_unfolding_stratum_dimension(marked_points=True)</span>
<span class="sd">            12</span>
<span class="sd">            sage: E.billiard_unfolding_stratum(marked_points=True).dimension()</span>
<span class="sd">            12</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cover_type</span> <span class="o">==</span> <span class="s2">&quot;rational&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">if</span> <span class="n">cover_type</span> <span class="o">!=</span> <span class="s2">&quot;translation&quot;</span> <span class="ow">and</span> <span class="n">cover_type</span> <span class="o">!=</span> <span class="s2">&quot;half-translation&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span>

        <span class="n">angles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">billiard_unfolding_angles</span><span class="p">(</span><span class="n">cover_type</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">marked_points</span><span class="p">:</span>
            <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">angles</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">angles</span><span class="p">:</span>
                <span class="n">angles</span><span class="p">[</span><span class="n">ZZ</span><span class="o">.</span><span class="n">one</span><span class="p">()]</span> <span class="o">=</span> <span class="n">ZZ</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>

        <span class="n">abelian</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">angles</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">chi</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">mult</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">mult</span> <span class="ow">in</span> <span class="n">angles</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="k">assert</span> <span class="n">chi</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">chi</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">(</span><span class="n">chi</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">chi</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">chi</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">g</span> <span class="o">+</span> <span class="n">s</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">abelian</span> <span class="k">else</span> <span class="mi">2</span><span class="o">*</span><span class="n">g</span> <span class="o">+</span> <span class="n">s</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="PolygonsConstructor"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.PolygonsConstructor">[docs]</a><span class="k">class</span> <span class="nc">PolygonsConstructor</span><span class="p">:</span>
<div class="viewcode-block" id="PolygonsConstructor.square"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.PolygonsConstructor.square">[docs]</a>    <span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf.geometry.polygon import polygons</span>

<span class="sd">            sage: polygons.square()</span>
<span class="sd">            Polygon: (0, 0), (1, 0), (1, 1), (0, 1)</span>
<span class="sd">            sage: polygons.square(field=QQbar).parent()</span>
<span class="sd">            ConvexPolygons(Algebraic Field)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rectangle</span><span class="p">(</span><span class="n">side</span><span class="p">,</span><span class="n">side</span><span class="p">,</span><span class="o">**</span><span class="n">kwds</span><span class="p">)</span></div>

<div class="viewcode-block" id="PolygonsConstructor.rectangle"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.PolygonsConstructor.rectangle">[docs]</a>    <span class="k">def</span> <span class="nf">rectangle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf.geometry.polygon import polygons</span>

<span class="sd">            sage: polygons.rectangle(1,2)</span>
<span class="sd">            Polygon: (0, 0), (1, 0), (1, 2), (0, 2)</span>

<span class="sd">            sage: K.&lt;sqrt2&gt; = QuadraticField(2)</span>
<span class="sd">            sage: polygons.rectangle(1,sqrt2)</span>
<span class="sd">            Polygon: (0, 0), (1, 0), (1, sqrt2), (0, sqrt2)</span>
<span class="sd">            sage: _.parent()</span>
<span class="sd">            ConvexPolygons(Number Field in sqrt2 with defining polynomial x^2 - 2 with sqrt2 = 1.414213562373095?)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">((</span><span class="n">width</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="n">height</span><span class="p">),(</span><span class="o">-</span><span class="n">width</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="n">height</span><span class="p">),</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span></div>

<div class="viewcode-block" id="PolygonsConstructor.triangle"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.PolygonsConstructor.triangle">[docs]</a>    <span class="k">def</span> <span class="nf">triangle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the triangle with angles a*pi/N,b*pi/N,c*pi/N where N=a+b+c.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``a``, ``b``, ``c`` -- integers</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf.geometry.polygon import polygons</span>
<span class="sd">            sage: T = polygons.triangle(3,4,5)</span>
<span class="sd">            sage: T</span>
<span class="sd">            Polygon: (0, 0), (1, 0), (-1/2*c0 + 3/2, -1/2*c0 + 3/2)</span>
<span class="sd">            sage: T.base_ring()</span>
<span class="sd">            Number Field in c0 with defining polynomial x^2 - 3 with c0 = 1.732050807568878?</span>

<span class="sd">            sage: polygons.triangle(1,2,3).angles()</span>
<span class="sd">            [1/12, 1/6, 1/4]</span>

<span class="sd">        Some fairly complicated examples::</span>

<span class="sd">            sage: polygons.triangle(1, 15, 21)</span>
<span class="sd">            Polygon: (0, 0), (1, 0), (1/2*c^34 - 17*c^32 + 264*c^30 - 2480*c^28 + 15732*c^26 - 142481/2*c^24 + 237372*c^22 - 1182269/2*c^20 + 1106380*c^18 - 1552100*c^16 + 3229985/2*c^14 - 2445665/2*c^12 + 654017*c^10 - 472615/2*c^8 + 107809/2*c^6 - 13923/2*c^4 + 416*c^2 - 6, -1/2*c^27 + 27/2*c^25 - 323/2*c^23 + 1127*c^21 - 10165/2*c^19 + 31009/2*c^17 - 65093/2*c^15 + 46911*c^13 - 91091/2*c^11 + 57355/2*c^9 - 10994*c^7 + 4621/2*c^5 - 439/2*c^3 + 6*c)</span>

<span class="sd">            sage: polygons.triangle(2, 13, 26)</span>
<span class="sd">            Polygon: (0, 0), (1, 0), (1/2*c^30 - 15*c^28 + 405/2*c^26 - 1625*c^24 + 8625*c^22 - 31878*c^20 + 168245/2*c^18 - 159885*c^16 + 218025*c^14 - 209950*c^12 + 138567*c^10 - 59670*c^8 + 15470*c^6 - 2100*c^4 + 225/2*c^2 - 1/2, -1/2*c^39 + 19*c^37 - 333*c^35 + 3571*c^33 - 26212*c^31 + 139593*c^29 - 557844*c^27 + 1706678*c^25 - 8085237/2*c^23 + 7449332*c^21 - 10671265*c^19 + 11812681*c^17 - 9983946*c^15 + 6317339*c^13 - 5805345/2*c^11 + 1848183/2*c^9 - 378929/2*c^7 + 44543/2*c^5 - 2487/2*c^3 + 43/2*c)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">EquiangularPolygons</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)([</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="PolygonsConstructor.regular_ngon"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.PolygonsConstructor.regular_ngon">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">regular_ngon</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a regular n-gon with unit length edges, first edge horizontal, and other vertices lying above this edge.</span>

<span class="sd">        Assuming field is None (by default) the polygon is defined over a NumberField (the minimal number field determined by n).</span>
<span class="sd">        Otherwise you can set field equal to AA to define the polygon over the Algebraic Reals. Other values for the field</span>
<span class="sd">        parameter will result in a ValueError.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf.geometry.polygon import polygons</span>

<span class="sd">            sage: p = polygons.regular_ngon(17)</span>
<span class="sd">            sage: p</span>
<span class="sd">            Polygon: (0, 0), (1, 0), ..., (-1/2*a^14 + 15/2*a^12 - 45*a^10 + 275/2*a^8 - 225*a^6 + 189*a^4 - 70*a^2 + 15/2, 1/2*a)</span>

<span class="sd">            sage: polygons.regular_ngon(3,field=AA)</span>
<span class="sd">            Polygon: (0, 0), (1, 0), (1/2, 0.866025403784439?)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The code below crashes for n=4!</span>
        <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">polygons</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">QQ</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">field</span><span class="o">=</span><span class="n">field</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">sage.rings.qqbar</span> <span class="kn">import</span> <span class="n">QQbar</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">QQbar</span><span class="o">.</span><span class="n">zeta</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">real</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">QQbar</span><span class="o">.</span><span class="n">zeta</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">imag</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">field</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="n">number_field_elements_from_algebraics</span><span class="p">((</span><span class="n">c</span><span class="p">,</span><span class="n">s</span><span class="p">))</span>
        <span class="n">cn</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
        <span class="n">sn</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">cn</span><span class="p">,</span><span class="n">sn</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">cn</span><span class="p">,</span><span class="n">sn</span> <span class="o">=</span> <span class="n">c</span><span class="o">*</span><span class="n">cn</span> <span class="o">-</span> <span class="n">s</span><span class="o">*</span><span class="n">sn</span><span class="p">,</span> <span class="n">c</span><span class="o">*</span><span class="n">sn</span> <span class="o">+</span> <span class="n">s</span><span class="o">*</span><span class="n">cn</span>
            <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cn</span><span class="p">,</span><span class="n">sn</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">ConvexPolygons</span><span class="p">(</span><span class="n">field</span><span class="p">)(</span><span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">)</span></div>

<div class="viewcode-block" id="PolygonsConstructor.right_triangle"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.PolygonsConstructor.right_triangle">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">right_triangle</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">leg0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">leg1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hypotenuse</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a right triangle in a number field with an angle of pi*angle.</span>

<span class="sd">        You can specify the length of the first leg (``leg0``), the second leg (``leg1``),</span>
<span class="sd">        or the ``hypotenuse``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import *</span>

<span class="sd">            sage: P = polygons.right_triangle(1/3, 1)</span>
<span class="sd">            sage: P</span>
<span class="sd">            Polygon: (0, 0), (1, 0), (1, a)</span>
<span class="sd">            sage: P.base_ring()</span>
<span class="sd">            Number Field in a with defining polynomial y^2 - 3 with a = 1.732050807568878?</span>

<span class="sd">            sage: polygons.right_triangle(1/4,1)</span>
<span class="sd">            Polygon: (0, 0), (1, 0), (1, 1)</span>
<span class="sd">            sage: polygons.right_triangle(1/4,1).field()</span>
<span class="sd">            Rational Field</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.rings.qqbar</span> <span class="kn">import</span> <span class="n">QQbar</span>

        <span class="n">angle</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">angle</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">angle</span> <span class="o">&gt;</span> <span class="n">QQ</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;angle must be in ]0,1/2]&#39;</span><span class="p">)</span>

        <span class="n">z</span> <span class="o">=</span> <span class="n">QQbar</span><span class="o">.</span><span class="n">zeta</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">angle</span><span class="o">.</span><span class="n">denom</span><span class="p">())</span><span class="o">**</span><span class="n">angle</span><span class="o">.</span><span class="n">numer</span><span class="p">()</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">real</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">imag</span><span class="p">()</span>

        <span class="n">nargs</span> <span class="o">=</span> <span class="p">(</span><span class="n">leg0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">leg1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">hypotenuse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nargs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">leg0</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">nargs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;only one length can be specified&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">leg0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">c</span><span class="p">,</span><span class="n">s</span> <span class="o">=</span> <span class="n">leg0</span><span class="o">*</span><span class="n">c</span><span class="o">/</span><span class="n">c</span><span class="p">,</span> <span class="n">leg0</span><span class="o">*</span><span class="n">s</span><span class="o">/</span><span class="n">c</span>
        <span class="k">elif</span> <span class="n">leg1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">c</span><span class="p">,</span><span class="n">s</span> <span class="o">=</span> <span class="n">leg1</span><span class="o">*</span><span class="n">c</span><span class="o">/</span><span class="n">s</span><span class="p">,</span> <span class="n">leg1</span><span class="o">*</span><span class="n">s</span><span class="o">/</span><span class="n">s</span>
        <span class="k">elif</span> <span class="n">hypotenuse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">c</span><span class="p">,</span><span class="n">s</span> <span class="o">=</span> <span class="n">hypotenuse</span><span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">hypotenuse</span><span class="o">*</span><span class="n">s</span>

        <span class="n">field</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="n">number_field_elements_from_algebraics</span><span class="p">((</span><span class="n">c</span><span class="p">,</span><span class="n">s</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ConvexPolygons</span><span class="p">(</span><span class="n">field</span><span class="p">)(</span><span class="n">edges</span><span class="o">=</span><span class="p">[(</span><span class="n">c</span><span class="p">,</span><span class="n">field</span><span class="o">.</span><span class="n">zero</span><span class="p">()),(</span><span class="n">field</span><span class="o">.</span><span class="n">zero</span><span class="p">(),</span><span class="n">s</span><span class="p">),(</span><span class="o">-</span><span class="n">c</span><span class="p">,</span><span class="o">-</span><span class="n">s</span><span class="p">)])</span></div>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import *</span>

<span class="sd">            sage: polygons((1,0),(0,1),(-1,0),(0,-1))</span>
<span class="sd">            Polygon: (0, 0), (1, 0), (1, 1), (0, 1)</span>
<span class="sd">            sage: polygons((1,0),(0,1),(-1,0),(0,-1), ring=QQbar)</span>
<span class="sd">            Polygon: (0, 0), (1, 0), (1, 1), (0, 1)</span>
<span class="sd">            sage: _.parent()</span>
<span class="sd">            ConvexPolygons(Algebraic Field)</span>

<span class="sd">            sage: polygons(vertices=[(0,0), (1,0), (0,1)])</span>
<span class="sd">            Polygon: (0, 0), (1, 0), (0, 1)</span>

<span class="sd">            sage: polygons(edges=[(2,0),(-1,1),(-1,-1)], base_point=(3,3))</span>
<span class="sd">            Polygon: (3, 3), (5, 3), (4, 4)</span>
<span class="sd">            sage: polygons(vertices=[(0,0),(2,0),(1,1)], base_point=(3,3))</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: invalid keyword &#39;base_point&#39;</span>


<span class="sd">            sage: polygons(angles=[1,1,1,2], length=1)</span>
<span class="sd">            Polygon: (0, 0), (1, 0), (-1/2*c^2 + 5/2, 1/2*c), (-1/2*c^2 + 2, 1/2*c^3 - 3/2*c)</span>
<span class="sd">            sage: polygons(angles=[1,1,1,2], length=2)</span>
<span class="sd">            Polygon: (0, 0), (2, 0), (-c^2 + 5, c), (-c^2 + 4, c^3 - 3*c)</span>
<span class="sd">            sage: polygons(angles=[1,1,1,2], length=AA(2)**(1/2))</span>
<span class="sd">            Polygon: (0, 0), (1.414213562373095?, 0), (0.9771975379242739?, 1.344997023927915?), (0.2700907567377265?, 0.8312538755549069?)</span>

<span class="sd">            sage: polygons(angles=[1]*5).angles()</span>
<span class="sd">            [3/10, 3/10, 3/10, 3/10, 3/10]</span>
<span class="sd">            sage: polygons(angles=[1]*8).angles()</span>
<span class="sd">            [3/8, 3/8, 3/8, 3/8, 3/8, 3/8, 3/8, 3/8]</span>

<span class="sd">            sage: P = polygons(angles=[1,1,3,3], lengths=[3,1])</span>
<span class="sd">            sage: P.angles()</span>
<span class="sd">            [1/8, 1/8, 3/8, 3/8]</span>
<span class="sd">            sage: e0 = P.edge(0); assert e0[0]**2 + e0[1]**2 == 3**2</span>
<span class="sd">            sage: e1 = P.edge(1); assert e1[0]**2 + e1[1]**2 == 1</span>

<span class="sd">            sage: polygons(angles=[1,1,1,2])</span>
<span class="sd">            Polygon: (0, 0), (1, 0), (-1/2*c^2 + 5/2, 1/2*c), (-1/2*c^2 + 2, 1/2*c^3 - 3/2*c)</span>

<span class="sd">            sage: polygons(angles=[1,1,1,8])</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: &#39;angles&#39; do not determine convex polygon; you might want to set the option &#39;convex=False&#39;</span>
<span class="sd">            sage: polygons(angles=[1,1,1,8], convex=False)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: non-convex equiangular polygon; lengths must be provided</span>
<span class="sd">            sage: polygons(angles=[1,1,1,8], lengths=[1,1], convex=False)</span>
<span class="sd">            Polygon: (0, 0), (1, 0), (-1/2*c^4 + 2*c^2, 1/2*c^7 - 7/2*c^5 + 7*c^3 - 7/2*c), (1/2*c^6 - 7/2*c^4 + 13/2*c^2 - 3/2, 1/2*c^9 - 9/2*c^7 + 27/2*c^5 - 29/2*c^3 + 5/2*c)</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from itertools import product</span>
<span class="sd">            sage: for a,b,c in product(range(1,5), repeat=3):</span>
<span class="sd">            ....:     if gcd([a,b,c]) != 1:</span>
<span class="sd">            ....:         continue</span>
<span class="sd">            ....:     T = polygons(angles=[a,b,c])</span>
<span class="sd">            ....:     D = 2*(a+b+c)</span>
<span class="sd">            ....:     assert T.angles() == [a/D, b/D, c/D]</span>
<span class="sd">            ....:     assert T.edge(0) == T.vector_space()((1,0))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">base_ring</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s1">&#39;ring&#39;</span> <span class="ow">in</span> <span class="n">kwds</span><span class="p">:</span>
            <span class="n">base_ring</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;ring&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s1">&#39;base_ring&#39;</span> <span class="ow">in</span> <span class="n">kwds</span><span class="p">:</span>
            <span class="n">base_ring</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;base_ring&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s1">&#39;field&#39;</span> <span class="ow">in</span> <span class="n">kwds</span><span class="p">:</span>
            <span class="n">base_ring</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;field&#39;</span><span class="p">)</span>

        <span class="n">convex</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;convex&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="n">vertices</span> <span class="o">=</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">angles</span> <span class="o">=</span> <span class="n">base_point</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s1">&#39;edges&#39;</span> <span class="ow">in</span> <span class="n">kwds</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;edges&#39;</span><span class="p">)</span>
            <span class="n">base_point</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;base_point&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">elif</span> <span class="s1">&#39;vertices&#39;</span> <span class="ow">in</span> <span class="n">kwds</span><span class="p">:</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;vertices&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s1">&#39;angles&#39;</span> <span class="ow">in</span> <span class="n">kwds</span><span class="p">:</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;angles&#39;</span><span class="p">)</span>
            <span class="n">lengths</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;lengths&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;length&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">base_point</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;base_point&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">number_field</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;number_field&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">args</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">()</span>
            <span class="n">base_point</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;base_point&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">vertices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">edges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">angles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;exactly one of &#39;vertices&#39;, &#39;edges&#39; or &#39;angles&#39; should be provided&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">vertices</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">edges</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">angles</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">lengths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;either vertices, edges or angles should be provided&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid argument </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">kwds</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid keyword </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">kwds</span><span class="p">))))</span>

        <span class="k">if</span> <span class="n">vertices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">vertices</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">base_ring</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">base_ring</span> <span class="o">=</span> <span class="n">Sequence</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">y</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">])</span><span class="o">.</span><span class="n">universe</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base_ring</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
                    <span class="n">base_ring</span> <span class="o">=</span> <span class="n">py_scalar_parent</span><span class="p">(</span><span class="n">base_ring</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">edges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">edges</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">base_ring</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">base_ring</span> <span class="o">=</span> <span class="n">Sequence</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">y</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">base_point</span><span class="p">))</span><span class="o">.</span><span class="n">universe</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base_ring</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
                    <span class="n">base_ring</span> <span class="o">=</span> <span class="n">py_scalar_parent</span><span class="p">(</span><span class="n">base_ring</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">angles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">EquiangularPolygons</span><span class="p">(</span><span class="o">*</span><span class="n">angles</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">convex</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">E</span><span class="o">.</span><span class="n">convexity</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;angles&#39; do not determine convex polygon; you might want to set the option &#39;convex=False&#39;&quot;</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">lengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;only one of &#39;length&#39; or &#39;lengths&#39; can be set together with &#39;angles&#39;&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lengths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">E</span><span class="o">.</span><span class="n">convexity</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;non-convex equiangular polygon; lengths must be provided&quot;</span><span class="p">)</span>
                <span class="n">lengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">length</span> <span class="ow">or</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;lengths&#39; must be a list of n-2 numbers (one less than &#39;angles&#39;)&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">E</span><span class="p">(</span><span class="n">lengths</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">base_ring</span> <span class="ow">is</span> <span class="n">ZZ</span><span class="p">:</span>
            <span class="c1"># Typically, we do not want to go to the fraction field of the base</span>
            <span class="c1"># ring, e.g., we do not want to go to FractionField(ExactReals()).</span>
            <span class="c1"># However, manual input of parameters often leads to the</span>
            <span class="c1"># automatically detected base ring ZZ which is essentially never</span>
            <span class="c1"># what the user wanted.</span>
            <span class="n">base_ring</span> <span class="o">=</span> <span class="n">QQ</span>

        <span class="k">if</span> <span class="n">convex</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ConvexPolygons</span><span class="p">(</span><span class="n">base_ring</span><span class="p">)(</span><span class="n">vertices</span><span class="o">=</span><span class="n">vertices</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span> <span class="n">base_point</span><span class="o">=</span><span class="n">base_point</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Polygons</span><span class="p">(</span><span class="n">base_ring</span><span class="p">)(</span><span class="n">vertices</span><span class="o">=</span><span class="n">vertices</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span> <span class="n">base_point</span><span class="o">=</span><span class="n">base_point</span><span class="p">)</span></div>

<span class="n">polygons</span> <span class="o">=</span> <span class="n">PolygonsConstructor</span><span class="p">()</span>

<div class="viewcode-block" id="regular_octagon"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.regular_octagon">[docs]</a><span class="k">def</span> <span class="nf">regular_octagon</span><span class="p">(</span><span class="n">field</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">sage.misc.superseded</span> <span class="kn">import</span> <span class="n">deprecation</span>
    <span class="n">deprecation</span><span class="p">(</span><span class="mi">33</span><span class="p">,</span> <span class="s2">&quot;Do not use this function anymore but regular_ngon(8)&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">polygons</span><span class="o">.</span><span class="n">regular_ngon</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span></div>

<div class="viewcode-block" id="PolygonCreator"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.PolygonCreator">[docs]</a><span class="k">class</span> <span class="nc">PolygonCreator</span><span class="p">():</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for iteratively constructing a polygon over the field.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Create a polygon in the provided field.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="o">=</span><span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">Fields</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;field must be a field&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_field</span><span class="o">=</span><span class="n">field</span>

<div class="viewcode-block" id="PolygonCreator.vector_space"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.PolygonCreator.vector_space">[docs]</a>    <span class="k">def</span> <span class="nf">vector_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the vector space in which self naturally embeds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">VectorSpace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_field</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="PolygonCreator.add_vertex"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.PolygonCreator.add_vertex">[docs]</a>    <span class="k">def</span> <span class="nf">add_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_vertex</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a vertex to the polygon.</span>
<span class="sd">        Returns 1 if successful and 0 if not, in which case the resulting</span>
<span class="sd">        polygon would not have been convex.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">V</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vector_space</span><span class="p">()</span>
        <span class="n">newv</span><span class="o">=</span><span class="n">V</span><span class="p">(</span><span class="n">new_vertex</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newv</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">zero</span><span class="p">())</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">newv</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">newv</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">newv</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newv</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">neww1</span><span class="o">=</span><span class="n">newv</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">wedge_product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">neww1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="n">neww2</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">newv</span>
            <span class="k">if</span> <span class="n">wedge_product</span><span class="p">(</span><span class="n">neww1</span><span class="p">,</span><span class="n">neww2</span><span class="p">)</span><span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">wedge_product</span><span class="p">(</span><span class="n">neww2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">newv</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">newv</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newv</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="PolygonCreator.get_polygon"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.polygon.PolygonCreator.get_polygon">[docs]</a>    <span class="k">def</span> <span class="nf">get_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the polygon.</span>
<span class="sd">        Raises a ValueError if less than three vertices have been accepted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not enough vertices!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ConvexPolygons</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_field</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">)</span></div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">sage-flatsurf 0.4.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">flatsurf.geometry.polygon</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2021, Vincent Delecroix and Pat Hooper.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.4.
    </div>
  </body>
</html>