
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>flatsurf.geometry.surface &#8212; sage-flatsurf 0.4.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.css" />
    
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/togglebutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">sage-flatsurf 0.4.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">flatsurf.geometry.surface</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for flatsurf.geometry.surface</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">#*********************************************************************</span>
<span class="c1">#  This file is part of sage-flatsurf.</span>
<span class="c1">#</span>
<span class="c1">#        Copyright (C) 2016-2020 Pat Hooper</span>
<span class="c1">#                      2019-2020 Vincent Delecroix</span>
<span class="c1">#                      2020      Julian RÃ¼th</span>
<span class="c1">#</span>
<span class="c1">#  sage-flatsurf is free software: you can redistribute it and/or modify</span>
<span class="c1">#  it under the terms of the GNU General Public License as published by</span>
<span class="c1">#  the Free Software Foundation, either version 2 of the License, or</span>
<span class="c1">#  (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1">#  sage-flatsurf is distributed in the hope that it will be useful,</span>
<span class="c1">#  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1">#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1">#  GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1">#  You should have received a copy of the GNU General Public License</span>
<span class="c1">#  along with sage-flatsurf. If not, see &lt;https://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#*********************************************************************</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="kn">import</span> <span class="nb">range</span><span class="p">,</span> <span class="nb">map</span><span class="p">,</span> <span class="nb">filter</span><span class="p">,</span> <span class="nb">zip</span>
<span class="kn">from</span> <span class="nn">six</span> <span class="kn">import</span> <span class="n">iteritems</span>

<span class="kn">from</span> <span class="nn">sage.structure.sage_object</span> <span class="kn">import</span> <span class="n">SageObject</span>
<span class="kn">from</span> <span class="nn">sage.sets.family</span> <span class="kn">import</span> <span class="n">Family</span>

<div class="viewcode-block" id="Surface"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface">[docs]</a><span class="k">class</span> <span class="nc">Surface</span><span class="p">(</span><span class="n">SageObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An oriented surface built from a set of polygons and edges identified with</span>
<span class="sd">    similarities (i.e. composition of homothety, rotations and translations).</span>

<span class="sd">    Each polygon is identified with a unique key (its label). The choice of the</span>
<span class="sd">    label of the polygons is done at startup. If the set is finite then by</span>
<span class="sd">    default the labels are the first non-negative integers 0,1,...</span>

<span class="sd">    The edge are identified by a couple (polygon label, edge number).</span>

<span class="sd">    .. NOTE::</span>

<span class="sd">        This class is abstract and should not be called directly. Instead you</span>
<span class="sd">        can either use Surface_list or Surface_dict. Another option is to</span>
<span class="sd">        inherit from Surface and implement the two methods:</span>

<span class="sd">        - polygon(self, label): the polygon associated to the provided label</span>
<span class="sd">        - opposite_edge(self, label, edge): a couple (``other_label``, ``other_edge``)</span>
<span class="sd">          representing the edge being glued</span>

<span class="sd">        If you want the surface to be mutable, you should override the methods:</span>
<span class="sd">        - _change_polygon(self, label, new_polygon, gluing_list=None)</span>
<span class="sd">        - _set_edge_pairing(self, label1, edge1, label2, edge2)</span>
<span class="sd">        - _add_polygon(self, new_polygon, gluing_list=None, label=None)</span>
<span class="sd">        - _remove_polygon(self, label)</span>
<span class="sd">        See the documentation of those methods for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_ring</span><span class="p">,</span> <span class="n">base_label</span><span class="p">,</span> <span class="n">finite</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mutable</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Represents a surface defined using polygons whose vertices lie</span>
<span class="sd">        in the provided base_ring.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        base_ring : field</span>
<span class="sd">            Field containing the vertices of the polygons.</span>
<span class="sd">        base_label :</span>
<span class="sd">            A preferred label for a polygon in the surface.</span>
<span class="sd">        finite : boolean</span>
<span class="sd">            The truth value of the statement &quot;The surface is finite.&quot;</span>
<span class="sd">        mutable : boolean</span>
<span class="sd">            If mutable is true, the resulting surface will be mutable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">finite</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;finite must be either True or False&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base_ring</span> <span class="o">=</span> <span class="n">base_ring</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base_label</span> <span class="o">=</span> <span class="n">base_label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finite</span><span class="o">=</span><span class="n">finite</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mutable</span> <span class="o">=</span> <span class="n">mutable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="Surface.is_triangulated"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface.is_triangulated">[docs]</a>    <span class="k">def</span> <span class="nf">is_triangulated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: import flatsurf</span>
<span class="sd">            sage: G = SymmetricGroup(4)</span>
<span class="sd">            sage: S = flatsurf.translation_surfaces.origami(G(&#39;(1,2,3,4)&#39;), G(&#39;(1,4,2,3)&#39;))</span>
<span class="sd">            sage: S.is_triangulated()</span>
<span class="sd">            False</span>
<span class="sd">            sage: S.triangulate().is_triangulated()</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">it</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_iterator</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;for infinite polygon, &#39;limit&#39; must be set to a positive integer&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span>
                <span class="n">it</span> <span class="o">=</span> <span class="n">islice</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Surface.polygon"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface.polygon">[docs]</a>    <span class="k">def</span> <span class="nf">polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the polygon with the provided label.</span>

<span class="sd">        This method must be overriden in subclasses.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="Surface.opposite_edge"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface.opposite_edge">[docs]</a>    <span class="k">def</span> <span class="nf">opposite_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the label ``l`` of a polygon and an edge ``e`` in that polygon</span>
<span class="sd">        returns the pair (``ll``, ``ee``) to which this edge is glued.</span>

<span class="sd">        This method must be overriden in subclasses.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

    <span class="c1">#</span>
    <span class="c1"># If the surface can be changed, implement the following methods:</span>
    <span class="c1">#</span>

    <span class="k">def</span> <span class="nf">_change_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">new_polygon</span><span class="p">,</span> <span class="n">gluing_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal method used by change_polygon(). Should not be called directly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_set_edge_pairing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label1</span><span class="p">,</span> <span class="n">edge1</span><span class="p">,</span> <span class="n">label2</span><span class="p">,</span> <span class="n">edge2</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal method used by change_edge_gluing(). Should not be called directly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_add_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_polygon</span><span class="p">,</span> <span class="n">gluing_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal method used by add_polygon(). Should not be called directly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_remove_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal method used by remove_polygon(). Should not be called directly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="c1">#</span>
    <span class="c1"># generic methods: override these for speed if possible</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="Surface.num_polygons"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface.num_polygons">[docs]</a>    <span class="k">def</span> <span class="nf">num_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of polygons making up the surface, or sage.rings.infinity.Infinity if the surface is infinite.</span>

<span class="sd">        This is a generic method. On a finite surface it will be linear time in the edges the first time it is run, then constant time (assuming not mutation occurs).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
            <span class="n">lw</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">walker</span><span class="p">()</span>
            <span class="n">lw</span><span class="o">.</span><span class="n">find_all_labels</span><span class="p">()</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">lw</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">sage.rings.infinity</span> <span class="kn">import</span> <span class="n">Infinity</span>
            <span class="k">return</span> <span class="n">Infinity</span></div>

<div class="viewcode-block" id="Surface.label_iterator"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface.label_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">label_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator over all polygon labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">walker</span><span class="p">())</span></div>

<div class="viewcode-block" id="Surface.label_polygon_iterator"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface.label_polygon_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">label_polygon_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over pairs (label,polygon).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_iterator</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span></div>

    <span class="c1">#</span>
    <span class="c1"># Methods which you probably do not want to override.</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="Surface.num_edges"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface.num_edges">[docs]</a>    <span class="k">def</span> <span class="nf">num_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the total number of edges of all polygons used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s2">&quot;num_edges&quot;</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">num_edges</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span><span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_polygon_iterator</span><span class="p">())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s2">&quot;num_edges&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_edges</span>
                <span class="k">return</span> <span class="n">num_edges</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">sage.rings.infinity</span> <span class="kn">import</span> <span class="n">Infinity</span>
            <span class="k">return</span> <span class="n">Infinity</span></div>

<div class="viewcode-block" id="Surface.area"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface.area">[docs]</a>    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the area of this surface.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">area</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">area</span><span class="p">()</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span><span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_polygon_iterator</span><span class="p">())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">area</span>
                <span class="k">return</span> <span class="n">area</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;area is not implemented for surfaces built from an infinite number of polygons&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Surface.edge_iterator"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface.edge_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">edge_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over the edges of polygons, which are pairs (l,e) where l is a polygon label, 0 &lt;= e &lt; N and N is the number of edges of the polygon with label l.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span><span class="n">polygon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_polygon_iterator</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()):</span>
                <span class="k">yield</span> <span class="n">label</span><span class="p">,</span> <span class="n">edge</span></div>

<div class="viewcode-block" id="Surface.edge_gluing_iterator"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface.edge_gluing_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">edge_gluing_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over the ordered pairs of edges being glued.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">label_edge_pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">():</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">label_edge_pair</span><span class="p">,</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">label_edge_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">label_edge_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span></div>

    <span class="c1">#</span>
    <span class="c1"># Methods which should not be overriden</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="Surface.base_ring"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface.base_ring">[docs]</a>    <span class="k">def</span> <span class="nf">base_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The field on which the coordinates of ``self`` live.</span>

<span class="sd">        This method must be overriden in subclasses!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_ring</span></div>

<div class="viewcode-block" id="Surface.base_label"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface.base_label">[docs]</a>    <span class="k">def</span> <span class="nf">base_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Always returns the same label.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_label</span></div>

<div class="viewcode-block" id="Surface.is_finite"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface.is_finite">[docs]</a>    <span class="k">def</span> <span class="nf">is_finite</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether or not the surface is finite.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finite</span></div>

<div class="viewcode-block" id="Surface.is_mutable"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface.is_mutable">[docs]</a>    <span class="k">def</span> <span class="nf">is_mutable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return if this surface is mutable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mutable</span></div>

<div class="viewcode-block" id="Surface.set_immutable"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface.set_immutable">[docs]</a>    <span class="k">def</span> <span class="nf">set_immutable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mark this surface as immutable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mutable</span> <span class="o">=</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="Surface.make_immutable"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface.make_immutable">[docs]</a>    <span class="k">def</span> <span class="nf">make_immutable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mark this surface as immutable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.misc.superseded</span> <span class="kn">import</span> <span class="n">deprecation</span>
        <span class="n">deprecation</span><span class="p">(</span><span class="mi">13109</span><span class="p">,</span> <span class="s2">&quot;Do not use .make_immutable(). Use .set_immutable() instead.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mutable</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Surface.walker"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface.walker">[docs]</a>    <span class="k">def</span> <span class="nf">walker</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a LabelWalker which walks over the surface in a canonical way.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s2">&quot;lw&quot;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">lw</span> <span class="o">=</span> <span class="n">LabelWalker</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s2">&quot;lw&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lw</span>
            <span class="k">return</span> <span class="n">lw</span></div>

    <span class="k">def</span> <span class="nf">__mutate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called before a mutation occurs. Do not call directly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">())</span>
        <span class="c1"># Remove the cache which will likely be invalidated.</span>
        <span class="c1">#self._cache=CachedData()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="Surface.change_polygon"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface.change_polygon">[docs]</a>    <span class="k">def</span> <span class="nf">change_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">new_polygon</span><span class="p">,</span> <span class="n">gluing_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assuming label is currently in the list of labels, change the</span>
<span class="sd">        poygon assigned to the provided label to new_polygon, and</span>
<span class="sd">        glue the edges according to gluing_list (which must be a list</span>
<span class="sd">        of pairs of length equal to number of edges of the polygon).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__mutate</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">gluing_list</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">new_polygon</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">gluing_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_change_polygon</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">new_polygon</span><span class="p">,</span> <span class="n">gluing_list</span><span class="p">)</span></div>

<div class="viewcode-block" id="Surface.set_edge_pairing"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface.set_edge_pairing">[docs]</a>    <span class="k">def</span> <span class="nf">set_edge_pairing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label1</span><span class="p">,</span> <span class="n">edge1</span><span class="p">,</span> <span class="n">label2</span><span class="p">,</span> <span class="n">edge2</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the gluing so that (label,edge1) is glued to (label2, edge2).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__mutate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_edge_pairing</span><span class="p">(</span><span class="n">label1</span><span class="p">,</span> <span class="n">edge1</span><span class="p">,</span> <span class="n">label2</span><span class="p">,</span> <span class="n">edge2</span><span class="p">)</span></div>

    <span class="c1"># TODO: deprecation alias?</span>
    <span class="n">change_edge_gluing</span> <span class="o">=</span> <span class="n">set_edge_pairing</span>

<div class="viewcode-block" id="Surface.change_polygon_gluings"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface.change_polygon_gluings">[docs]</a>    <span class="k">def</span> <span class="nf">change_polygon_gluings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">glue_list</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the list of glued polygons according to the provided list,</span>
<span class="sd">        which is a list of pairs (pp,ee) whose position in the list</span>
<span class="sd">        describes the edge of the polygon with the provided label.</span>

<span class="sd">        This method updates both the edges of the polygon with label &quot;label&quot;</span>
<span class="sd">        and updates the edges listed in the glue_list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__mutate</span><span class="p">()</span>
        <span class="n">p</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">glue_list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ValueEror</span><span class="p">(</span><span class="s2">&quot;len(glue_list)=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">glue_list</span><span class="p">))</span><span class="o">+</span>\
                <span class="s2">&quot; and number of sides of polygon=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">num_edges</span><span class="p">())</span><span class="o">+</span>\
                <span class="s2">&quot; should be the same.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">e</span><span class="p">,(</span><span class="n">pp</span><span class="p">,</span><span class="n">ee</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">glue_list</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_edge_pairing</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">ee</span><span class="p">)</span></div>

<div class="viewcode-block" id="Surface.add_polygons"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface.add_polygons">[docs]</a>    <span class="k">def</span> <span class="nf">add_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polygons</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">add_polygon</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">polygons</span><span class="p">]</span></div>

<div class="viewcode-block" id="Surface.add_polygon"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface.add_polygon">[docs]</a>    <span class="k">def</span> <span class="nf">add_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_polygon</span><span class="p">,</span> <span class="n">gluing_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a the provided polygon to the surface. Utilizes gluing_list</span>
<span class="sd">        for the gluing data for edges (which must be a list</span>
<span class="sd">        of pairs representing edges of length equal to number of edges</span>
<span class="sd">        of the polygon).</span>

<span class="sd">        If the parameter label is provided, the Surface attempts to use</span>
<span class="sd">        this as the label for the new_polygon. However, this may fail</span>
<span class="sd">        depending on the implementation.</span>

<span class="sd">        Returns the label assigned to the new_polygon (which may differ</span>
<span class="sd">        from the label provided).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__mutate</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">gluing_list</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">new_polygon</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">gluing_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_polygon</span><span class="p">(</span><span class="n">new_polygon</span><span class="p">,</span> <span class="n">gluing_list</span><span class="p">,</span><span class="n">label</span><span class="p">)</span></div>

<div class="viewcode-block" id="Surface.remove_polygon"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface.remove_polygon">[docs]</a>    <span class="k">def</span> <span class="nf">remove_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the polygon with the provided label. Causes a ValueError</span>
<span class="sd">        if the base_label is removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">label</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">_base_label</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can not remove the base_label.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__mutate</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span></div>

<div class="viewcode-block" id="Surface.change_base_label"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface.change_base_label">[docs]</a>    <span class="k">def</span> <span class="nf">change_base_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_base_label</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the base_label to the provided label.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__mutate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base_label</span><span class="o">=</span><span class="n">new_base_label</span></div>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hash compatible with equals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;_hash&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Attempting to hash mutable surface.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Attempting to hash infinite surface.&quot;</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="mi">73</span><span class="o">+</span><span class="mi">17</span><span class="o">*</span><span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">())</span><span class="o">+</span><span class="mi">23</span><span class="o">*</span><span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_label</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_polygon_iterator</span><span class="p">():</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">7</span><span class="o">*</span><span class="nb">hash</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">edgepair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_gluing_iterator</span><span class="p">():</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="nb">hash</span><span class="p">(</span><span class="n">edgepair</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="o">=</span><span class="n">h</span>
        <span class="k">return</span> <span class="n">h</span>


    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implements a naive notion of equality where two finite surfaces are equal if:</span>
<span class="sd">        - their base rings are equal,</span>
<span class="sd">        - their base labels are equal,</span>
<span class="sd">        - their polygons are equal and labeled and glued in the same way.</span>
<span class="sd">        For infinite surfaces we use reference equality.</span>
<span class="sd">        Raises a value error if the surfaces are defined over different rings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Surface</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can not compare infinite surfaces.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">base_ring</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Refusing to compare surfaces with different base rings.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">():</span>
            <span class="n">hash1</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">hash2</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hash1</span> <span class="o">!=</span> <span class="n">hash2</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_label</span><span class="p">()</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">base_label</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_polygons</span><span class="p">()</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">num_polygons</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span><span class="n">polygon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_polygon_iterator</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">polygon2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">polygon</span> <span class="o">!=</span> <span class="n">polygon2</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">edge</span><span class="p">)</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">edge</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">_test_base_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="c1"># Test that the base_label is associated to a polygon</span>
        <span class="n">tester</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tester</span><span class="p">(</span><span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">Rings</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span> <span class="ow">in</span> <span class="n">Rings</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_test_base_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="c1"># Test that the base_label is associated to a polygon</span>
        <span class="n">tester</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tester</span><span class="p">(</span><span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">.polygon</span> <span class="kn">import</span> <span class="n">ConvexPolygon</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_label</span><span class="p">()),</span> <span class="n">ConvexPolygon</span><span class="p">),</span> \
            <span class="s2">&quot;polygon(base_label) does not return a ConvexPolygon. &quot;</span><span class="o">+</span>\
            <span class="s2">&quot;Here base_label=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_label</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">_test_gluings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="c1"># iterate over pairs with pair1 glued to pair2</span>
        <span class="n">tester</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tester</span><span class="p">(</span><span class="o">**</span><span class="n">options</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
            <span class="n">it</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_iterator</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span>
            <span class="n">it</span> <span class="o">=</span> <span class="n">islice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label_iterator</span><span class="p">(),</span> <span class="mi">30</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()):</span>
                <span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">lab</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">lab</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                <span class="n">tester</span><span class="o">.</span><span class="n">assertFalse</span><span class="p">(</span><span class="n">f</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="s2">&quot;edge (</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">) is not glued&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lab</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
                <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span>
                        <span class="s2">&quot;edge gluing is not a pairing:</span><span class="se">\n</span><span class="si">{}</span><span class="s2"> -&gt; </span><span class="si">{}</span><span class="s2"> -&gt; </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_test_override</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="c1"># Test that the required methods have been overridden and that some other methods have not been overridden.</span>

        <span class="c1"># Of course, we don&#39;t care if the methods are overridden or not we just want to warn the programmer.</span>
        <span class="k">if</span> <span class="s1">&#39;tester&#39;</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
            <span class="n">tester</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;tester&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tester</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tester</span><span class="p">(</span><span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="c1"># Build a naive Surface.</span>
        <span class="kn">from</span> <span class="nn">sage.rings.rational_field</span> <span class="kn">import</span> <span class="n">QQ</span>
        <span class="n">s</span><span class="o">=</span><span class="n">Surface</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">finite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Check for override:</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertNotEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span>
                              <span class="n">s</span><span class="o">.</span><span class="n">polygon</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span>
            <span class="s2">&quot;Method polygon of Surface must be overridden. The Surface is of type &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertNotEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">opposite_edge</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">opposite_edge</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span>
            <span class="s2">&quot;Method opposite_edge of Surface must be overridden. The Surface is of type &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>

        <span class="c1"># Check not overridden:</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">base_ring</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span> \
            <span class="s2">&quot;Method base_ring of Surface should not be overridden. The Surface is of type &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_label</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">base_label</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span> \
            <span class="s2">&quot;Method base_label of Surface should not be overridden. The Surface is of type &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_finite</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">is_finite</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span> \
            <span class="s2">&quot;Method is_finite of Surface should not be overridden. The Surface is of type &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_mutable</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">is_mutable</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span> \
            <span class="s2">&quot;Method is_mutable of Surface should not be overridden. The Surface is of type &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_immutable</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">set_immutable</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span> \
            <span class="s2">&quot;Method set_immutable of Surface should not be overridden. The Surface is of type &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">walker</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">walker</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span> \
            <span class="s2">&quot;Method walker of Surface should not be overridden. The Surface is of type &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">change_polygon</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">change_polygon</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span> \
            <span class="s2">&quot;Method change_polygon of Surface should not be overridden. The Surface is of type &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">change_polygon_gluings</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">change_polygon_gluings</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span> \
            <span class="s2">&quot;Method change_polygon_gluings of Surface should not be overridden. The Surface is of type &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">change_edge_gluing</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">change_edge_gluing</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span> \
            <span class="s2">&quot;Method change_edge_gluing of Surface should not be overridden. The Surface is of type &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">add_polygon</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">add_polygon</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span> \
            <span class="s2">&quot;Method add_polygon of Surface should not be overridden. The Surface is of type &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">remove_polygon</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">remove_polygon</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span> \
            <span class="s2">&quot;Method remove_polygon of Surface should not be overridden. The Surface is of type &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">change_base_label</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">change_base_label</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span> \
            <span class="s2">&quot;Method change_base_label of Surface should not be overridden. The Surface is of type &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">():</span>
            <span class="c1"># Check for override:</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertNotEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_change_polygon</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">_change_polygon</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span>\
                <span class="s2">&quot;Method _change_polygon of Surface must be overridden in a mutable surface. &quot;</span><span class="o">+</span>\
                <span class="s2">&quot;The Surface is of type &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertNotEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_set_edge_pairing</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">_set_edge_pairing</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span>\
                <span class="s2">&quot;Method _set_edge_pairing of Surface must be overridden in a mutable surface. &quot;</span><span class="o">+</span>\
                <span class="s2">&quot;The Surface is of type &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertNotEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_polygon</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">_add_polygon</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span><span class="s2">&quot;Method _add_polygon of Surface must be overridden in a mutable surface. &quot;</span><span class="o">+</span>\
                <span class="s2">&quot;The Surface is of type &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertNotEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_remove_polygon</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">_remove_polygon</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span><span class="s2">&quot;Method _remove_polygon of Surface must be overridden in a mutable surface. &quot;</span><span class="o">+</span>\
                <span class="s2">&quot;The Surface is of type &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_test_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="c1"># Test that the base_label is associated to a polygon</span>
        <span class="k">if</span> <span class="s1">&#39;tester&#39;</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
            <span class="n">tester</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;tester&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tester</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tester</span><span class="p">(</span><span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">.polygon</span> <span class="kn">import</span> <span class="n">ConvexPolygon</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
            <span class="n">it</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_iterator</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span>
            <span class="n">it</span> <span class="o">=</span> <span class="n">islice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label_iterator</span><span class="p">(),</span> <span class="mi">30</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label</span><span class="p">),</span> <span class="n">ConvexPolygon</span><span class="p">),</span> \
                <span class="s2">&quot;polygon(label) does not return a ConvexPolygon when label=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">label</span><span class="p">))</span></div>

<span class="c1">####</span>
<span class="c1">#### Surface_list</span>
<span class="c1">####</span>

<div class="viewcode-block" id="Surface_list"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface_list">[docs]</a><span class="k">class</span> <span class="nc">Surface_list</span><span class="p">(</span><span class="n">Surface</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A fast mutable implementation of surface using a list to store polygons and gluings.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import *</span>
<span class="sd">        sage: from flatsurf.geometry.surface import Surface_list</span>
<span class="sd">        sage: p=polygons.regular_ngon(5)</span>
<span class="sd">        sage: s=Surface_list(base_ring=p.base_ring())</span>
<span class="sd">        sage: s.add_polygon(p) # gets label 0</span>
<span class="sd">        0</span>
<span class="sd">        sage: s.add_polygon( (-matrix.identity(2))*p ) # gets label 1</span>
<span class="sd">        1</span>
<span class="sd">        sage: s.change_polygon_gluings(0,[(1,e) for e in range(5)])</span>
<span class="sd">        sage: # base label defaults to zero.</span>
<span class="sd">        sage: s.set_immutable()</span>
<span class="sd">        sage: TestSuite(s).run()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">###</span>
    <span class="c1">### Brief summary of internal workings.</span>
    <span class="c1">###</span>
    <span class="c1">#</span>
    <span class="c1"># The Surface_list maintains a list self._p for storing polygons together</span>
    <span class="c1"># with gluing data.</span>
    <span class="c1">#</span>
    <span class="c1"># Here self._p[label] is typically a list of two elements</span>
    <span class="c1"># [polygon, gluing_list]. The gluing_list is then a list of pairs</span>
    <span class="c1"># (other_label, other_edge) so that typically</span>
    <span class="c1"># self.opposite_edge(label, edge) returns self._p[label][1][edge].</span>
    <span class="c1">#</span>
    <span class="c1"># If constructed with a surface parameter which is not None and copy=False,</span>
    <span class="c1"># then Surface_list stores a reference to the provided surface as</span>
    <span class="c1"># self._reference_surface. (Otherwise self._reference_surface is None).</span>
    <span class="c1">#</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">surface</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mutable</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Surface_list is a Surface implementation which uses int for labels.</span>
<span class="sd">        (Internally, things are stored in a list.)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        base_ring : field or None</span>
<span class="sd">            Field containing the vertices of the polygons. If left None (as default)</span>
<span class="sd">            the base_ring is copied from the surface. If surface is also None</span>
<span class="sd">            a ValueError will be raised.</span>
<span class="sd">        surface : Surface or SimilaritySurface or None</span>
<span class="sd">            A surface to be copied or referenced to obtain the initial state.</span>
<span class="sd">            If surface is None (as default), the surface is initialized to be</span>
<span class="sd">            empty and mutability is forced.</span>
<span class="sd">        copy : boolean</span>
<span class="sd">            If copy is true and surface is not None, then a copy is made of the</span>
<span class="sd">            surface. This will result in an error if surface is infinite. If</span>
<span class="sd">            copy is true, an reference to surface is used instead. Results of</span>
<span class="sd">            querying are cached, therefore trying to store a reference of a</span>
<span class="sd">            mutable surface is not allowed. The main purpose of the option</span>
<span class="sd">            copy=False is to obtain a &quot;copy&quot; of an infinite surface. In case</span>
<span class="sd">            copy=False, the labels for polygons are decided on in a lazy way.</span>
<span class="sd">            In particular, you need to explore the resulting surface before</span>
<span class="sd">            calling polygon(100). (You can explore the surface using any</span>
<span class="sd">            of the iterators.)</span>
<span class="sd">        mutable : boolean or None</span>
<span class="sd">            If mutable is true, the resulting surface will be mutable. If mutable</span>
<span class="sd">            is false, then the resulting surface will not be mutable. If mutable</span>
<span class="sd">            is left at its default value of None, then the surface will be mutable</span>
<span class="sd">            if and only if a surface is not provided.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import *</span>
<span class="sd">            sage: print(&quot;We will surgically add a square into an infinite billiard surface&quot;)</span>
<span class="sd">            We will surgically add a square into an infinite billiard surface</span>
<span class="sd">            sage: p = polygons(vertices=[(0,0),(4,0),(0,3)])</span>
<span class="sd">            sage: s = similarity_surfaces.billiard(p)</span>
<span class="sd">            sage: ts=s.minimal_cover(cover_type=&quot;translation&quot;).copy(relabel=True, mutable=True)</span>
<span class="sd">            sage: # Explore the surface a bit</span>
<span class="sd">            sage: ts.polygon(0)</span>
<span class="sd">            Polygon: (0, 0), (4, 0), (0, 3)</span>
<span class="sd">            sage: ts.opposite_edge(0,0)</span>
<span class="sd">            (1, 2)</span>
<span class="sd">            sage: ts.polygon(1)</span>
<span class="sd">            Polygon: (0, 0), (0, -3), (4, 0)</span>
<span class="sd">            sage: s = ts.underlying_surface()</span>
<span class="sd">            sage: l=s.add_polygon(polygons.square(side=4))</span>
<span class="sd">            sage: s.change_edge_gluing(0,0,l,2)</span>
<span class="sd">            sage: s.change_edge_gluing(1,2,l,0)</span>
<span class="sd">            sage: s.change_edge_gluing(l,1,l,3)</span>
<span class="sd">            sage: print(&quot;Glued in label is &quot;+str(l))</span>
<span class="sd">            Glued in label is 2</span>
<span class="sd">            sage: count = 0</span>
<span class="sd">            sage: for x in ts.edge_iterator(gluings=True):</span>
<span class="sd">            ....:     print(x)</span>
<span class="sd">            ....:     count=count+1</span>
<span class="sd">            ....:     if count&gt;15:</span>
<span class="sd">            ....:         break</span>
<span class="sd">            ((0, 0), (2, 2))</span>
<span class="sd">            ((0, 1), (3, 1))</span>
<span class="sd">            ((0, 2), (4, 0))</span>
<span class="sd">            ((2, 0), (1, 2))</span>
<span class="sd">            ((2, 1), (2, 3))</span>
<span class="sd">            ((2, 2), (0, 0))</span>
<span class="sd">            ((2, 3), (2, 1))</span>
<span class="sd">            ((3, 0), (5, 2))</span>
<span class="sd">            ((3, 1), (0, 1))</span>
<span class="sd">            ((3, 2), (6, 0))</span>
<span class="sd">            ((4, 0), (0, 2))</span>
<span class="sd">            ((4, 1), (7, 1))</span>
<span class="sd">            ((4, 2), (8, 0))</span>
<span class="sd">            ((1, 0), (8, 2))</span>
<span class="sd">            ((1, 1), (9, 1))</span>
<span class="sd">            ((1, 2), (2, 0))</span>
<span class="sd">            sage: count = 0</span>
<span class="sd">            sage: for l,p in ts.label_iterator(polygons=True):</span>
<span class="sd">            ....:     print(str(l)+&quot; -&gt; &quot;+str(p))</span>
<span class="sd">            ....:     count=count+1</span>
<span class="sd">            ....:     if count&gt;5:</span>
<span class="sd">            ....:         break</span>
<span class="sd">            0 -&gt; Polygon: (0, 0), (4, 0), (0, 3)</span>
<span class="sd">            2 -&gt; Polygon: (0, 0), (4, 0), (4, 4), (0, 4)</span>
<span class="sd">            3 -&gt; Polygon: (0, 0), (-72/25, -21/25), (28/25, -96/25)</span>
<span class="sd">            4 -&gt; Polygon: (0, 0), (0, 3), (-4, 0)</span>
<span class="sd">            1 -&gt; Polygon: (0, 0), (0, -3), (4, 0)</span>
<span class="sd">            5 -&gt; Polygon: (0, 0), (-28/25, 96/25), (-72/25, -21/25)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_p</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># list of pairs (polygon, gluings)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># Whether or not we store a reference surface</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_removed_labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">surface</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">base_ring</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either surface or base_ring must be provided.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mutable</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">mutable</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If no surface is provided, then mutable must be true.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_num_polygons</span><span class="o">=</span><span class="mi">0</span>
            <span class="c1"># default label is zero.</span>
            <span class="n">Surface</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_ring</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">finite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">.similarity_surface</span> <span class="kn">import</span> <span class="n">SimilaritySurface</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span><span class="n">SimilaritySurface</span><span class="p">):</span>
                <span class="n">surface</span><span class="o">=</span><span class="n">surface</span><span class="o">.</span><span class="n">underlying_surface</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span><span class="n">Surface</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;surface must be either a Surface or SimilaritySurface&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">base_ring</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">base_ring</span> <span class="o">!=</span> <span class="n">surface</span><span class="o">.</span><span class="n">base_ring</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You currently can not provide both a surface and a base_ring.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_base_ring</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">copy</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">surface</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can not copy an infinite surface.&quot;</span><span class="p">)</span>
                <span class="c1"># Temporarily set base_label to none. Update below.</span>
                <span class="n">Surface</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surface</span><span class="o">.</span><span class="n">base_ring</span><span class="p">(),</span> <span class="kc">None</span><span class="p">,</span> <span class="n">finite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_num_polygons</span><span class="o">=</span><span class="mi">0</span>
                <span class="n">label_dict</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">label</span><span class="p">,</span><span class="n">polygon</span> <span class="ow">in</span> <span class="n">surface</span><span class="o">.</span><span class="n">label_polygon_iterator</span><span class="p">():</span>
                    <span class="n">label_dict</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
                    <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span>
                    <span class="c1"># This automatically adds one to _num_polygons:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_polygon</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">pair1</span><span class="p">,</span><span class="n">pair2</span> <span class="ow">in</span> <span class="n">surface</span><span class="o">.</span><span class="n">edge_gluing_iterator</span><span class="p">():</span>
                    <span class="n">l1</span><span class="p">,</span><span class="n">e1</span><span class="o">=</span><span class="n">pair1</span>
                    <span class="n">l2</span><span class="p">,</span><span class="n">e2</span><span class="o">=</span><span class="n">pair2</span>
                    <span class="n">ll1</span><span class="o">=</span><span class="n">label_dict</span><span class="p">[</span><span class="n">l1</span><span class="p">]</span>
                    <span class="n">ll2</span><span class="o">=</span><span class="n">label_dict</span><span class="p">[</span><span class="n">l2</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">ll1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">e1</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">ll2</span><span class="p">,</span><span class="n">e2</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">change_base_label</span><span class="p">(</span><span class="n">label_dict</span><span class="p">[</span><span class="n">surface</span><span class="o">.</span><span class="n">base_label</span><span class="p">()])</span>
                <span class="k">if</span> <span class="n">mutable</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">mutable</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_immutable</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">surface</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Surface_list will not store reference to a mutable surface.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span> <span class="o">=</span> <span class="n">surface</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ref_to_int</span><span class="o">=</span><span class="p">{}</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_int_to_ref</span><span class="o">=</span><span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__get_label</span><span class="p">(</span><span class="n">surface</span><span class="o">.</span><span class="n">base_label</span><span class="p">())</span>

                <span class="c1"># Cache the base polygon</span>
                <span class="n">polygon</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">surface</span><span class="o">.</span><span class="n">base_label</span><span class="p">())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">polygon</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">num_edges</span><span class="p">())]]</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_num_polygons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span><span class="o">.</span><span class="n">num_polygons</span><span class="p">()</span>
                <span class="c1"># Set base label to zero.</span>
                <span class="n">Surface</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surface</span><span class="o">.</span><span class="n">base_ring</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">finite</span><span class="o">=</span><span class="n">surface</span><span class="o">.</span><span class="n">is_finite</span><span class="p">(),</span> <span class="n">mutable</span><span class="o">=</span><span class="ow">not</span> <span class="n">mutable</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mutable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_label</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a corresponding label. Creates a new label if necessary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref_to_int</span><span class="p">[</span><span class="n">ref_label</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">polygon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">ref_label</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">polygon</span><span class="p">,[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">num_edges</span><span class="p">())]]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_removed_labels</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_removed_labels</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ref_to_int</span><span class="p">[</span><span class="n">ref_label</span><span class="p">]</span><span class="o">=</span><span class="n">i</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_int_to_ref</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">ref_label</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_int_to_ref</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;length of self._int_to_ref is &quot;</span><span class="o">+</span>\
                        <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_int_to_ref</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot; should be the same as &quot;</span><span class="o">+</span>\
                        <span class="s2">&quot;i=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ref_to_int</span><span class="p">[</span><span class="n">ref_label</span><span class="p">]</span><span class="o">=</span><span class="n">i</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_int_to_ref</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref_label</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">i</span>

<div class="viewcode-block" id="Surface_list.polygon"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface_list.polygon">[docs]</a>    <span class="k">def</span> <span class="nf">polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lab</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the polygon with label ``lab``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">lab</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No known polygon with provided label &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;. &quot;</span><span class="o">+</span>\
                <span class="s2">&quot;This can be caused by failing to explore your surface. &quot;</span><span class="o">+</span>\
                <span class="s2">&quot;See the documentation in flatsurf.geometry.surface.Surface_list.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Provided label was removed.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Surface_list.opposite_edge"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface_list.opposite_edge">[docs]</a>    <span class="k">def</span> <span class="nf">opposite_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the label ``p`` of a polygon and an edge ``e`` in that polygon</span>
<span class="sd">        returns the pair (``pp``, ``ee``) to which this edge is glued.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
             <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No known polygon with provided label&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Provided label was removed.&quot;</span><span class="p">)</span>
        <span class="n">glue</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">oe</span> <span class="o">=</span> <span class="n">glue</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Edge out of range of polygon.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">oe</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Perhaps the user of this class left an edge unglued?</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ref_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_int_to_ref</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
                <span class="n">ref_pp</span><span class="p">,</span> <span class="n">ref_ee</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">ref_p</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                <span class="n">pp</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_label</span><span class="p">(</span><span class="n">ref_pp</span><span class="p">)</span>
                <span class="n">return_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">ref_ee</span><span class="p">)</span>
                <span class="n">glue</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">return_value</span>
                <span class="k">return</span> <span class="n">return_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Sucessfully return edge data</span>
            <span class="k">return</span> <span class="n">oe</span></div>

    <span class="c1"># Methods for changing the surface</span>

    <span class="k">def</span> <span class="nf">_change_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">new_polygon</span><span class="p">,</span> <span class="n">gluing_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal method used by change_polygon(). Should not be called directly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No known polygon with provided label&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Provided label was removed from the surface.&quot;</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">new_polygon</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">new_polygon</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">new_polygon</span><span class="o">.</span><span class="n">num_edges</span><span class="p">())]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">gluing_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">change_polygon_gluings</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">gluing_list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_edge_pairing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label1</span><span class="p">,</span> <span class="n">edge1</span><span class="p">,</span> <span class="n">label2</span><span class="p">,</span> <span class="n">edge2</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal method used by change_edge_gluing(). Should not be called directly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">label1</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No known polygon with provided label1=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">label1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Provided label1=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">label1</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; was removed from the surface.&quot;</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">edge1</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">label2</span><span class="p">,</span><span class="n">edge2</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">label2</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No known polygon with provided label2=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">label2</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Provided label2=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">label2</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; was removed from the surface.&quot;</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">edge2</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">label1</span><span class="p">,</span><span class="n">edge1</span><span class="p">)</span>

    <span class="c1"># TODO: deprecation alias?</span>
    <span class="n">_change_edge_gluing</span> <span class="o">=</span> <span class="n">_set_edge_pairing</span>

    <span class="k">def</span> <span class="nf">_add_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_polygon</span><span class="p">,</span> <span class="n">gluing_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal method used by add_polygon(). Should not be called directly.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import *</span>
<span class="sd">            sage: from flatsurf.geometry.surface import Surface_list</span>
<span class="sd">            sage: p=polygons.regular_ngon(5)</span>
<span class="sd">            sage: s=Surface_list(base_ring=p.base_ring())</span>
<span class="sd">            sage: s.add_polygon(p, label=3)</span>
<span class="sd">            3</span>
<span class="sd">            sage: s.add_polygon( (-matrix.identity(2))*p, label=30)</span>
<span class="sd">            30</span>
<span class="sd">            sage: s.change_polygon_gluings(3,[(30,e) for e in range(5)])</span>
<span class="sd">            sage: s.change_base_label(30)</span>
<span class="sd">            sage: s.num_polygons()</span>
<span class="sd">            2</span>
<span class="sd">            sage: TestSuite(s).run()</span>
<span class="sd">            sage: s.remove_polygon(3)</span>
<span class="sd">            sage: s.add_polygon(p, label=6)</span>
<span class="sd">            6</span>
<span class="sd">            sage: s.change_polygon_gluings(6,[(30,e) for e in range(5)])</span>
<span class="sd">            sage: s.num_polygons()</span>
<span class="sd">            2</span>
<span class="sd">            sage: TestSuite(s).run()</span>
<span class="sd">            sage: s.change_base_label(6)</span>
<span class="sd">            sage: s.remove_polygon(30)</span>
<span class="sd">            sage: label = s.add_polygon((-matrix.identity(2))*p)</span>
<span class="sd">            sage: s.change_polygon_gluings(6,[(label,e) for e in range(5)])</span>
<span class="sd">            sage: TestSuite(s).run()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_polygon</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">new_polygon</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">new_polygon</span><span class="o">.</span><span class="n">num_edges</span><span class="p">())]</span> <span class="p">]</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_removed_labels</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">new_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_removed_labels</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">new_label</span><span class="p">]</span><span class="o">=</span><span class="n">data</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_label</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Need a blank in this list for algorithmic reasons</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_int_to_ref</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_label</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_label</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">new_label</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Trying to add a polygon with label=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; which already indexes a polygon.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">new_label</span><span class="p">]</span><span class="o">=</span><span class="n">data</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">new_label</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">100</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Adding a polygon with label=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; would add more than 100 entries in our list.&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">),</span><span class="n">new_label</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_removed_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># Need a blank in this list for algorithmic reasons</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_int_to_ref</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Need a blank in this list for algorithmic reasons</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_int_to_ref</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">gluing_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">change_polygon_gluings</span><span class="p">(</span><span class="n">new_label</span><span class="p">,</span><span class="n">gluing_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_polygons</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">new_label</span>

<div class="viewcode-block" id="Surface_list.num_polygons"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface_list.num_polygons">[docs]</a>    <span class="k">def</span> <span class="nf">num_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of polygons making up the surface in constant time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_polygons</span></div>

<div class="viewcode-block" id="Surface_list.label_iterator"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface_list.label_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">label_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator over all polygon labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Surface</span><span class="o">.</span><span class="n">label_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">i</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_polygons</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_polygons</span><span class="p">()):</span>
                <span class="k">yield</span> <span class="n">i</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We&#39;ve removed some labels</span>
            <span class="n">found</span><span class="o">=</span><span class="mi">0</span>
            <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">while</span> <span class="n">found</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_polygons</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">found</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">yield</span> <span class="n">i</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span></div>

    <span class="k">def</span> <span class="nf">_remove_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal method used by remove_polygon(). Should not be called directly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ref_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_int_to_ref</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_int_to_ref</span><span class="p">)</span><span class="o">==</span><span class="n">label</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ref_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref_to_int</span><span class="p">[</span><span class="n">ref_label</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_removed_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ref_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_int_to_ref</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ref_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_int_to_ref</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref_to_int</span><span class="p">[</span><span class="n">ref_label</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_polygons</span> <span class="o">-=</span> <span class="mi">1</span>

<div class="viewcode-block" id="Surface_list.ramified_cover"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface_list.ramified_cover">[docs]</a>    <span class="k">def</span> <span class="nf">ramified_cover</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a ramified cover of this surface.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``d`` - integer (the degree of the cover)</span>

<span class="sd">        - ``data`` - a dictionary which to a pair ``(label, edge_num)`` associates a permutation</span>
<span class="sd">          of {1,...,d}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.groups.perm_gps.permgroup_named</span> <span class="kn">import</span> <span class="n">SymmetricGroup</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">SymmetricGroup</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="n">cover</span> <span class="o">=</span> <span class="n">Surface_list</span><span class="p">(</span><span class="n">base_ring</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">())</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label_iterator</span><span class="p">())</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">())</span>
        <span class="n">cover_labels</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_iterator</span><span class="p">():</span>
                <span class="n">cover_labels</span><span class="p">[(</span><span class="n">lab</span><span class="p">,</span> <span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">cover</span><span class="o">.</span><span class="n">add_polygon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">lab</span><span class="p">))</span>
        <span class="k">while</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">lab</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">elab</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">llab</span><span class="p">,</span> <span class="n">ee</span> <span class="o">=</span> <span class="n">eelab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">lab</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="n">edges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">eelab</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">elab</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">eelab</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">elab</span><span class="p">]</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="n">eelab</span><span class="p">])</span><span class="o">.</span><span class="n">is_one</span><span class="p">():</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;inconsistent covering data&quot;</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">elab</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">eelab</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="o">~</span><span class="n">data</span><span class="p">[</span><span class="n">eelab</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">p0</span> <span class="o">=</span> <span class="n">cover_labels</span><span class="p">[(</span><span class="n">lab</span><span class="p">,</span> <span class="n">i</span><span class="p">)]</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">cover_labels</span><span class="p">[(</span><span class="n">lab</span><span class="p">,</span> <span class="n">s</span><span class="p">(</span><span class="n">i</span><span class="p">))]</span>
                <span class="n">cover</span><span class="o">.</span><span class="n">set_edge_pairing</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">ee</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cover</span></div></div>

<div class="viewcode-block" id="surface_list_from_polygons_and_gluings"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.surface_list_from_polygons_and_gluings">[docs]</a><span class="k">def</span> <span class="nf">surface_list_from_polygons_and_gluings</span><span class="p">(</span><span class="n">polygons</span><span class="p">,</span> <span class="n">gluings</span><span class="p">,</span> <span class="n">mutable</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take a list of polygons and gluings (given either as a list of pairs of edges, or as a dictionary),</span>
<span class="sd">    and produce a Surface_list from it. The mutable parameter determines the mutability of the resulting</span>
<span class="sd">    surface.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">polygons</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">polygons</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;polygons must be a list or tuple.&quot;</span><span class="p">)</span>
    <span class="n">field</span> <span class="o">=</span> <span class="n">polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">field</span><span class="p">()</span>
    <span class="n">s</span><span class="o">=</span><span class="n">Surface_list</span><span class="p">(</span><span class="n">base_ring</span><span class="o">=</span><span class="n">field</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">polygons</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">add_polygon</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># dict case:</span>
        <span class="n">it</span> <span class="o">=</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">gluings</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="c1"># list case:</span>
        <span class="n">it</span> <span class="o">=</span> <span class="n">gluings</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">e1</span><span class="p">),(</span><span class="n">l2</span><span class="p">,</span><span class="n">e2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">change_edge_gluing</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">e1</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">e2</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">mutable</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">set_immutable</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">s</span></div>

<span class="c1">####</span>
<span class="c1">#### Surface_dict</span>
<span class="c1">####</span>

<div class="viewcode-block" id="Surface_dict"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface_dict">[docs]</a><span class="k">class</span> <span class="nc">Surface_dict</span><span class="p">(</span><span class="n">Surface</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A mutable implementation of surface using a dictionary to store polygons and gluings. The dictionary</span>
<span class="sd">    implementation has the advantage that many label types are supported.</span>

<span class="sd">    The example below indicates how to construct a Surface_dict.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import *</span>
<span class="sd">        sage: p=polygons.regular_ngon(10)</span>
<span class="sd">        sage: s=Surface_dict(base_ring=p.base_ring())</span>
<span class="sd">        sage: s.add_polygon(p,label=&quot;A&quot;)</span>
<span class="sd">        &#39;A&#39;</span>
<span class="sd">        sage: s.change_polygon_gluings(&quot;A&quot;,[(&quot;A&quot;,(e+5)%10) for e in range(10)])</span>
<span class="sd">        sage: s.change_base_label(&quot;A&quot;)</span>
<span class="sd">        sage: s.set_immutable()</span>
<span class="sd">        sage: TestSuite(s).run()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">###</span>
    <span class="c1">### Brief summary of internal workings.</span>
    <span class="c1">###</span>
    <span class="c1">#</span>
    <span class="c1"># The Surface_dict maintains a dictionary self._p for storing polygons together with gluing data.</span>
    <span class="c1"># Here self._p[label] is typically a list of two elements [polygon, gluing_list].</span>
    <span class="c1"># The gluing_list is then a list of pairs (other_label, other_edge) so that typically</span>
    <span class="c1"># self.opposite_edge(label, edge) returns self._p[label][1][edge].</span>
    <span class="c1">#</span>
    <span class="c1"># If constructed with a surface parameter which is not None and copy=False, then Surface_dict</span>
    <span class="c1"># stores a reference to the provided surface as self._reference_surface.</span>
    <span class="c1"># (Otherwise self._reference_surface is None). If we have a reference surface, then to represent a removed</span>
    <span class="c1"># polygon we set self._p[label]=None.</span>
    <span class="c1">#</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">surface</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mutable</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Surface_list is a Surface implementation which uses int for labels.</span>
<span class="sd">        (Internally, things are stored in a list.)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        base_ring : field or None</span>
<span class="sd">            Field containing the vertices of the polygons. If left None (as default)</span>
<span class="sd">            the base_ring is copied from the surface. If surface is also None</span>
<span class="sd">            a ValueError will be raised.</span>
<span class="sd">        surface : Surface or SimilaritySurface or None</span>
<span class="sd">            A surface to be copied or referenced to obtain the initial state.</span>
<span class="sd">            If surface is None (as default), the surface is initialized to be</span>
<span class="sd">            empty and mutability is forced.</span>
<span class="sd">        copy : boolean</span>
<span class="sd">            If copy is true and surface is not None, then a copy is made of the</span>
<span class="sd">            surface. This will result in an error if surface is infinite. If</span>
<span class="sd">            copy is true, an reference to surface is used instead. Results of</span>
<span class="sd">            querying are cached, therefore trying to store a reference of a</span>
<span class="sd">            mutable surface is not allowed. The main purpose of the option</span>
<span class="sd">            copy=False is to obtain a &quot;copy&quot; of an infinite surface. In case</span>
<span class="sd">            copy=False, the labels for polygons are decided on in a lazy way.</span>
<span class="sd">            In particular, you need to explore the resulting surface before</span>
<span class="sd">            calling polygon(100). (You can explore the surface using any</span>
<span class="sd">            of the iterators.)</span>
<span class="sd">        mutable : boolean or None</span>
<span class="sd">            If mutable is true, the resulting surface will be mutable. If mutable</span>
<span class="sd">            is fals e, then the resulting surface will not be mutable. If mutable</span>
<span class="sd">            is left at its default value of None, then the surface will be mutable</span>
<span class="sd">            if and only if a surface is not provided.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_p</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">surface</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">base_ring</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either surface or base_ring must be provided.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mutable</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">mutable</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If no surface is provided, then mutable must be true.&quot;</span><span class="p">)</span>
            <span class="n">Surface</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_ring</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">finite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">.similarity_surface</span> <span class="kn">import</span> <span class="n">SimilaritySurface</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span><span class="n">SimilaritySurface</span><span class="p">):</span>
                <span class="n">surface</span><span class="o">=</span><span class="n">surface</span><span class="o">.</span><span class="n">underlying_surface</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span><span class="n">Surface</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;surface must be either a Surface or SimilaritySurface&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">base_ring</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">base_ring</span> <span class="o">!=</span> <span class="n">surface</span><span class="o">.</span><span class="n">base_ring</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You currently can not provide both a surface and a base_ring.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">copy</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">surface</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can not copy an infinite surface.&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">label</span><span class="p">,</span><span class="n">polygon</span> <span class="ow">in</span> <span class="n">surface</span><span class="o">.</span><span class="n">label_polygon_iterator</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">polygon</span><span class="p">,</span> \
                        <span class="p">[</span> <span class="n">surface</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">num_edges</span><span class="p">())</span> <span class="p">]</span> <span class="p">]</span>
                <span class="c1"># The only way we&#39;re mutable is if mutable=True:</span>
                <span class="n">Surface</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surface</span><span class="o">.</span><span class="n">base_ring</span><span class="p">(),</span> <span class="n">surface</span><span class="o">.</span><span class="n">base_label</span><span class="p">(),</span> <span class="n">finite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mutable</span><span class="o">=</span><span class="ow">not</span> <span class="n">mutable</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mutable</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">surface</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Surface_dict will not store reference to a mutable surface.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span> <span class="o">=</span> <span class="n">surface</span>
                <span class="c1"># The only way we&#39;re mutable is if mutable=True:</span>
                <span class="n">Surface</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surface</span><span class="o">.</span><span class="n">base_ring</span><span class="p">(),</span> <span class="n">surface</span><span class="o">.</span><span class="n">base_label</span><span class="p">(),</span> \
                    <span class="n">finite</span><span class="o">=</span><span class="n">surface</span><span class="o">.</span><span class="n">is_finite</span><span class="p">(),</span> <span class="n">mutable</span><span class="o">=</span><span class="ow">not</span> <span class="n">mutable</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mutable</span><span class="p">)</span>

<div class="viewcode-block" id="Surface_dict.polygon"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface_dict.polygon">[docs]</a>    <span class="k">def</span> <span class="nf">polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lab</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the polygon with label ``lab``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">lab</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># No label in dictionary.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
               <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No known polygon with provided label &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">polygon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">[</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">lab</span><span class="p">),</span> \
                    <span class="p">[</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">lab</span><span class="p">,</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">num_edges</span><span class="p">())</span> <span class="p">]</span> <span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">lab</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Label &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; was removed from the surface.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Surface_dict.opposite_edge"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface_dict.opposite_edge">[docs]</a>    <span class="k">def</span> <span class="nf">opposite_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the label ``p`` of a polygon and an edge ``e`` in that polygon</span>
<span class="sd">        returns the pair (``pp``, ``ee``) to which this edge is glued.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
             <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Label &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; was removed from the surface.&quot;</span><span class="p">)</span>
        <span class="n">gluing_data</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">gluing_data</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Edge e=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; is out of range in polygon with label &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">))</span></div>

    <span class="c1"># Methods for changing the surface</span>

    <span class="k">def</span> <span class="nf">_change_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">new_polygon</span><span class="p">,</span> <span class="n">gluing_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal method used by change_polygon(). Should not be called directly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Label &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; was removed from the surface.&quot;</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">new_polygon</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># Polygon probably lies in reference surface</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No known polygon with provided label&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Ensure the reference surface had a polygon with the provided label:</span>
                <span class="n">old_polygon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">old_polygon</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span> <span class="o">==</span> <span class="n">new_polygon</span><span class="o">.</span><span class="n">num_edges</span><span class="p">():</span>
                    <span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">new_polygon</span><span class="p">,</span> \
                        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">new_polygon</span><span class="o">.</span><span class="n">num_edges</span><span class="p">())]</span> <span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">=</span><span class="n">data</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">new_polygon</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">new_polygon</span><span class="o">.</span><span class="n">num_edges</span><span class="p">())]</span> <span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">=</span><span class="n">data</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="n">new_polygon</span><span class="o">.</span><span class="n">num_edges</span><span class="p">():</span>
            <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">new_polygon</span><span class="o">.</span><span class="n">num_edges</span><span class="p">())]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">gluing_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">change_polygon_gluings</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">gluing_list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_edge_pairing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label1</span><span class="p">,</span> <span class="n">edge1</span><span class="p">,</span> <span class="n">label2</span><span class="p">,</span> <span class="n">edge2</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal method used by set_edge_pairing(). Should not be called directly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">label1</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No known polygon with provided label1 = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Failure likely because reference_surface contains the polygon.</span>
                <span class="c1"># import the data into this surface.</span>
                <span class="n">polygon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label1</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">polygon</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">label1</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">num_edges</span><span class="p">())]]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">label1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">edge1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">label2</span><span class="p">,</span><span class="n">edge2</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="c1"># break down error</span>
            <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;polygon with label1=</span><span class="si">{}</span><span class="s2"> was removed&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label1</span><span class="p">))</span>
            <span class="n">data1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">data1</span><span class="p">[</span><span class="n">edge1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">label2</span><span class="p">,</span> <span class="n">edge2</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;edge1=</span><span class="si">{}</span><span class="s2"> is out of range in polygon with label1=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">edge1</span><span class="p">,</span> <span class="n">label1</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">label2</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no polygon with label2=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label2</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Failure likely because reference_surface contains the polygon.</span>
                <span class="c1"># import the data into this surface.</span>
                <span class="n">polygon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label2</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">polygon</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">label2</span><span class="p">,</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">num_edges</span><span class="p">())]]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">label2</span><span class="p">]</span><span class="o">=</span><span class="n">data</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">edge2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">label1</span><span class="p">,</span><span class="n">edge1</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="c1"># break down error</span>
            <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;polygon with label1=</span><span class="si">{}</span><span class="s2"> was removed&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label1</span><span class="p">))</span>
            <span class="n">data1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">data1</span><span class="p">[</span><span class="n">edge2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">label1</span><span class="p">,</span> <span class="n">edge1</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;edge </span><span class="si">{}</span><span class="s2"> is out of range in polygon with label2=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">edge2</span><span class="p">,</span> <span class="n">label2</span><span class="p">))</span>

    <span class="n">_change_edge_gluing</span> <span class="o">=</span> <span class="n">_set_edge_pairing</span>

    <span class="k">def</span> <span class="nf">_add_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_polygon</span><span class="p">,</span> <span class="n">gluing_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal method used by add_polygon(). Should not be called directly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">new_polygon</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">new_polygon</span><span class="o">.</span><span class="n">num_edges</span><span class="p">())]</span> <span class="p">]</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_label</span> <span class="o">=</span> <span class="n">ExtraLabel</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">old_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">old_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># already removed this polygon. That&#39;s good, we can add.</span>
                    <span class="n">new_label</span><span class="o">=</span><span class="n">label</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;label=</span><span class="si">{}</span><span class="s2"> already used by another polygon&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># This seems inconvienient to enforce:</span>
                <span class="c1">#</span>
                <span class="c1">#if not self._reference_surface is None:</span>
                <span class="c1">#    # Can not be sure we are not overwriting a polygon in the reference surface.</span>
                <span class="c1">#    raise ValueError(&quot;Can not assign this label to a Surface_dict containing a reference surface,&quot;+\</span>
                <span class="c1">#        &quot;which may already contain this label.&quot;)</span>
                <span class="n">new_label</span> <span class="o">=</span> <span class="n">label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">new_label</span><span class="p">]</span><span class="o">=</span><span class="n">data</span>
        <span class="k">if</span> <span class="n">gluing_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">change_polygon_gluings</span><span class="p">(</span><span class="n">new_label</span><span class="p">,</span><span class="n">gluing_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_label</span>

<div class="viewcode-block" id="Surface_dict.num_polygons"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface_dict.num_polygons">[docs]</a>    <span class="k">def</span> <span class="nf">num_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of polygons making up the surface in constant time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Unfortunately, I don&#39;t see a good way to compute this.</span>
                <span class="k">return</span> <span class="n">Surface</span><span class="o">.</span><span class="n">num_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">sage.rings.infinity</span> <span class="kn">import</span> <span class="n">Infinity</span>
            <span class="k">return</span> <span class="n">Infinity</span></div>

<div class="viewcode-block" id="Surface_dict.label_iterator"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.Surface_dict.label_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">label_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator over all polygon labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">i</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Surface</span><span class="o">.</span><span class="n">label_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">i</span></div>

    <span class="k">def</span> <span class="nf">_remove_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal method used by remove_polygon(). Should not be called directly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_surface</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Label &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; is not in the surface.&quot;</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
                <span class="c1"># Success.</span>
                <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Label &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; was already removed from the surface.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># Assume on faith we are removing a polygon in the base_surface.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="BaseRingChangedSurface"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.BaseRingChangedSurface">[docs]</a><span class="k">class</span> <span class="nc">BaseRingChangedSurface</span><span class="p">(</span><span class="n">Surface</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A surface with a different base_ring.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="n">ring</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">=</span><span class="n">surface</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base_ring</span><span class="o">=</span><span class="n">ring</span>
        <span class="kn">from</span> <span class="nn">flatsurf.geometry.polygon</span> <span class="kn">import</span> <span class="n">ConvexPolygons</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_P</span><span class="o">=</span><span class="n">ConvexPolygons</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_base_ring</span><span class="p">)</span>
        <span class="n">Surface</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">base_label</span><span class="p">(),</span> <span class="n">mutable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">finite</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">is_finite</span><span class="p">())</span>

<div class="viewcode-block" id="BaseRingChangedSurface.polygon"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.BaseRingChangedSurface.polygon">[docs]</a>    <span class="k">def</span> <span class="nf">polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lab</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_P</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span> <span class="p">)</span></div>

<div class="viewcode-block" id="BaseRingChangedSurface.opposite_edge"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.BaseRingChangedSurface.opposite_edge">[docs]</a>    <span class="k">def</span> <span class="nf">opposite_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">e</span><span class="p">)</span></div></div>


<span class="c1">#####</span>
<span class="c1">##### LABEL WALKER</span>
<span class="c1">#####</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<div class="viewcode-block" id="LabelWalker"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.LabelWalker">[docs]</a><span class="k">class</span> <span class="nc">LabelWalker</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take a canonical walk around the surface and find the labels of polygons.</span>

<span class="sd">    We start at the base_label().</span>
<span class="sd">    Then the labels are visited in order involving the combinatorial distance from the base_label(),</span>
<span class="sd">    where combinatorial distance measures the minimal number of edges which need to be crossed to reach the</span>
<span class="sd">    polygon with a givel label. Ties are broken using lexigraphical order on the numbers associated to edges crossed</span>
<span class="sd">    (labels are not used in this lexigraphical ordering).</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LabelWalker.LabelWalkerIterator"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.LabelWalker.LabelWalkerIterator">[docs]</a>    <span class="k">class</span> <span class="nc">LabelWalkerIterator</span><span class="p">:</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label_walker</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lw</span> <span class="o">=</span> <span class="n">label_walker</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_i</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lw</span><span class="p">):</span>
                <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lw</span><span class="o">.</span><span class="n">number_to_label</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_i</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_i</span> <span class="o">+</span><span class="mi">1</span>
                <span class="k">return</span> <span class="n">label</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lw</span><span class="p">):</span>
                <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lw</span><span class="o">.</span><span class="n">find_a_new_label</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_i</span><span class="o">+</span><span class="mi">1</span>
                <span class="k">return</span> <span class="n">label</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">()</span>

        <span class="nb">next</span> <span class="o">=</span> <span class="fm">__next__</span> <span class="c1"># for Python 2</span>

        <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span></div>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surface</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">=</span><span class="n">surface</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">base_label</span><span class="p">()]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_label_dict</span><span class="o">=</span><span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">base_label</span><span class="p">():</span><span class="mi">0</span><span class="p">}</span>

        <span class="c1"># This will stores an edge to move through to get to a polygon closer to the base_polygon</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_label_edge_back</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">base_label</span><span class="p">():</span><span class="kc">None</span><span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_walk</span><span class="o">=</span><span class="n">deque</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_walk</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">base_label</span><span class="p">(),</span><span class="mi">0</span><span class="p">))</span>

<div class="viewcode-block" id="LabelWalker.label_dictionary"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.LabelWalker.label_dictionary">[docs]</a>    <span class="k">def</span> <span class="nf">label_dictionary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a dictionary mapping labels to integers which gives a canonical order on labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label_dict</span></div>

<div class="viewcode-block" id="LabelWalker.edge_back"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.LabelWalker.edge_back">[docs]</a>    <span class="k">def</span> <span class="nf">edge_back</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the &quot;canonical&quot; edge to walk through to get closer to the base_label,</span>
<span class="sd">        or None if label already is the base_label.</span>

<span class="sd">        Remark: This could be slow on infinite surfaces!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label_edge_back</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
                    <span class="n">limit</span><span class="o">=</span><span class="mi">1000</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">limit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">num_polygons</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">limit</span><span class="p">):</span>
                <span class="n">new_label</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">find_a_new_label</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="n">new_label</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label_edge_back</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
        <span class="c1"># Maybe the surface is not connected?</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Unable to find label </span><span class="si">%s</span><span class="s2">. Are you sure the surface is connected?&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">label</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LabelWalker</span><span class="o">.</span><span class="n">LabelWalkerIterator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="LabelWalker.polygon_iterator"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.LabelWalker.polygon_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">polygon_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span></div>

<div class="viewcode-block" id="LabelWalker.label_polygon_iterator"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.LabelWalker.label_polygon_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">label_polygon_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span></div>

<div class="viewcode-block" id="LabelWalker.edge_iterator"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.LabelWalker.edge_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">edge_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span><span class="n">polygon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_polygon_iterator</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()):</span>
                <span class="k">yield</span> <span class="n">label</span><span class="p">,</span><span class="n">e</span></div>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of labels found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">)</span>

<div class="viewcode-block" id="LabelWalker.find_a_new_label"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.LabelWalker.find_a_new_label">[docs]</a>    <span class="k">def</span> <span class="nf">find_a_new_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds a new label, stores it, and returns it. Returns None if we have already found all labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_walk</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">label</span><span class="p">,</span><span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_walk</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="n">opposite_label</span><span class="p">,</span><span class="n">opposite_edge</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">e</span><span class="p">)</span>
            <span class="n">e</span><span class="o">=</span><span class="n">e</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">num_edges</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_walk</span><span class="o">.</span><span class="n">appendleft</span><span class="p">((</span><span class="n">label</span><span class="p">,</span><span class="n">e</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">opposite_label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label_dict</span><span class="p">:</span>
                <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">opposite_label</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_label_dict</span><span class="p">[</span><span class="n">opposite_label</span><span class="p">]</span><span class="o">=</span><span class="n">n</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_walk</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">opposite_label</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_label_edge_back</span><span class="p">[</span><span class="n">opposite_label</span><span class="p">]</span><span class="o">=</span><span class="n">opposite_edge</span>
                <span class="k">return</span> <span class="n">opposite_label</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="LabelWalker.find_new_labels"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.LabelWalker.find_new_labels">[docs]</a>    <span class="k">def</span> <span class="nf">find_new_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Look for n new labels. Return the list of labels found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_a_new_label</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">new_labels</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_labels</span></div>

<div class="viewcode-block" id="LabelWalker.find_all_labels"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.LabelWalker.find_all_labels">[docs]</a>    <span class="k">def</span> <span class="nf">find_all_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">is_finite</span><span class="p">())</span>
        <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_a_new_label</span><span class="p">()</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_a_new_label</span><span class="p">()</span></div>

<div class="viewcode-block" id="LabelWalker.number_to_label"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.LabelWalker.number_to_label">[docs]</a>    <span class="k">def</span> <span class="nf">number_to_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the n-th label where n is less than the length.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">n</span><span class="p">]</span></div>

<div class="viewcode-block" id="LabelWalker.label_to_number"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.LabelWalker.label_to_number">[docs]</a>    <span class="k">def</span> <span class="nf">label_to_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">search</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number associated to the provided label.</span>

<span class="sd">        Returns an error if the label has not already been found by the walker</span>
<span class="sd">        unless search=True in which case we look for the label. We look by</span>
<span class="sd">        continuing to look for the label by walking over the surface visiting</span>
<span class="sd">        the next limit many polygons.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">search</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label_dict</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label_dict</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label_dict</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">limit</span><span class="p">):</span>
                <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_a_new_label</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="n">l</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label_dict</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Failed to find label even after searching. limit=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">limit</span><span class="p">))</span></div>

<div class="viewcode-block" id="LabelWalker.surface"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.LabelWalker.surface">[docs]</a>    <span class="k">def</span> <span class="nf">surface</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span></div></div>

<span class="c1">######</span>
<span class="c1">###### ExtraLabels</span>
<span class="c1">######</span>

<div class="viewcode-block" id="ExtraLabel"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.ExtraLabel">[docs]</a><span class="k">class</span> <span class="nc">ExtraLabel</span><span class="p">(</span><span class="n">SageObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used to spit out new labels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_next</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new label.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ExtraLabel</span><span class="o">.</span><span class="n">_next</span><span class="p">)</span>
            <span class="n">ExtraLabel</span><span class="o">.</span><span class="n">_next</span> <span class="o">=</span> <span class="n">ExtraLabel</span><span class="o">.</span><span class="n">_next</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_label</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="mi">23</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;E&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;ExtraLabel(&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;)&quot;</span></div>

<span class="c1">######</span>
<span class="c1">###### LabelComparator</span>
<span class="c1">######</span>

<div class="viewcode-block" id="LabelComparator"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.LabelComparator">[docs]</a><span class="k">class</span> <span class="nc">LabelComparator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implements a total ordering on labels, which may be of varying types.</span>
<span class="sd">    </span>
<span class="sd">    We use hashes, so if hash(label1) &lt; hash(label2) we declare label1 &lt; label2.</span>
<span class="sd">    For objects with the same hash, we store an arbitary ordering.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a label comparator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hash_collision_resolver</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">_get_resolver_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label_hash</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">lst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash_collision_resolver</span><span class="p">[</span><span class="n">label_hash</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">lst</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash_collision_resolver</span><span class="p">[</span><span class="n">label_hash</span><span class="p">]</span> <span class="o">=</span> <span class="n">lst</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">stored_label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="n">stored_label</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">i</span>
        <span class="c1"># At this point we know label is not in lst</span>
        <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
            
<div class="viewcode-block" id="LabelComparator.lt"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.LabelComparator.lt">[docs]</a>    <span class="k">def</span> <span class="nf">lt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the truth value of l1 &lt; l2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">h1</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">l1</span><span class="p">)</span>
        <span class="n">h2</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">l2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">h1</span> <span class="o">&lt;</span> <span class="n">h2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">h1</span> <span class="o">&gt;</span> <span class="n">h2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># Otherwise the hashes are equal.</span>
        <span class="k">if</span> <span class="n">l1</span> <span class="o">==</span> <span class="n">l2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_resolver_index</span><span class="p">(</span><span class="n">h1</span><span class="p">,</span> <span class="n">l1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_resolver_index</span><span class="p">(</span><span class="n">h1</span><span class="p">,</span> <span class="n">l2</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="LabelComparator.le"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.LabelComparator.le">[docs]</a>    <span class="k">def</span> <span class="nf">le</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the truth value of l1 &lt;= l2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">l1</span> <span class="o">==</span> <span class="n">l2</span></div>
    
<div class="viewcode-block" id="LabelComparator.gt"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.LabelComparator.gt">[docs]</a>    <span class="k">def</span> <span class="nf">gt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the truth value of l1 &gt; l2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span> <span class="n">l1</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="LabelComparator.ge"><a class="viewcode-back" href="../../../geometry.html#flatsurf.geometry.surface.LabelComparator.ge">[docs]</a>    <span class="k">def</span> <span class="nf">ge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the truth value of l1 &gt;= l2.</span>
<span class="sd">        r&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span> <span class="n">l1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">l1</span> <span class="o">==</span> <span class="n">l2</span></div></div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">sage-flatsurf 0.4.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">flatsurf.geometry.surface</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2021, Vincent Delecroix and Pat Hooper.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.4.
    </div>
  </body>
</html>