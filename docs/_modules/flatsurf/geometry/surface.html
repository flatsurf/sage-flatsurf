<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" />

    <!-- Generated with Sphinx 5.3.0 and Furo 2023.05.20 -->
        <title>flatsurf.geometry.surface - sage-flatsurf 0.5.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?digest=e6660623a769aa55fea372102b9bf3151b292993" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="https://doc.sagemath.org/html/en/reference/_static/custom-furo.css" />
    <link rel="stylesheet" type="text/css" href="https://doc.sagemath.org/html/en/reference/_static/custom-jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="https://doc.sagemath.org/html/en/reference/_static/custom-codemirror-monokai.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/jupyter_execute.css" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  --color-brand-primary: #0f0fff;
  --color-brand-content: #0f0fff;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">sage-flatsurf 0.5.2 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../../_static/logo.svg" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../../_static/logo.svg" alt="Dark Logo"/>
  </div>
  
  <span class="sidebar-brand-text">sage-flatsurf 0.5.2 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installing sage-flatsurf</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer.html">The Developer’s Guide for sage-flatsurf</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/tour.html">A Tour of the flatsurf Suite</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/defining_surfaces.html">Defining Surfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/graphics_configuration.html">Graphics Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/linear_action_and_delaunay.html">The GL(2,R) Action, the Veech Group, Delaunay Decomposition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/rel_deformations.html">Relative Period Deformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/saddle_connections.html">Working with Saddle Connections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/apisa_wright.html">Exploring Orbit Closures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/siegel_veech.html">Siegel-Veech Constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/straight_line_flow.html">Straight-Line Flow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/warwick-2017.html">Notes from the Warwick EPSRC Symposium on “Computation in geometric topology”</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/boshernitzan_conjecture.html">Boshernitzan’s Conjectures</a></li>
</ul>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../geometry.html">The flatsurf.geometry Package</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of The flatsurf.geometry Package</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/categories.html"><code class="docutils literal notranslate"><span class="pre">categories</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/chamanara.html"><code class="docutils literal notranslate"><span class="pre">chamanara</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/circle.html"><code class="docutils literal notranslate"><span class="pre">circle</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/cone_surfaces.html"><code class="docutils literal notranslate"><span class="pre">cone_surfaces</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/delaunay.html"><code class="docutils literal notranslate"><span class="pre">delaunay</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/dilation_surfaces.html"><code class="docutils literal notranslate"><span class="pre">dilation_surfaces</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/euclidean.html"><code class="docutils literal notranslate"><span class="pre">euclidean</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/finitely_generated_matrix_group.html"><code class="docutils literal notranslate"><span class="pre">finitely_generated_matrix_group</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/fundamental_group.html"><code class="docutils literal notranslate"><span class="pre">fundamental_group</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/gl2r_orbit_closure.html"><code class="docutils literal notranslate"><span class="pre">gl2r_orbit_closure</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/half_dilation_surface.html"><code class="docutils literal notranslate"><span class="pre">half_dilation_surface</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/half_translation_surfaces.html"><code class="docutils literal notranslate"><span class="pre">half_translation_surfaces</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/hyperbolic.html"><code class="docutils literal notranslate"><span class="pre">hyperbolic</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/hyperbolic_polygons.html"><code class="docutils literal notranslate"><span class="pre">hyperbolic_polygons</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/interval_exchange_transformation.html"><code class="docutils literal notranslate"><span class="pre">interval_exchange_transformation</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/l_infinity_delaunay_cells.html"><code class="docutils literal notranslate"><span class="pre">l_infinity_delaunay_cells</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/mappings.html"><code class="docutils literal notranslate"><span class="pre">mappings</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/mega_wollmilchsau.html"><code class="docutils literal notranslate"><span class="pre">mega_wollmilchsau</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/minimal_cover.html"><code class="docutils literal notranslate"><span class="pre">minimal_cover</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/origami.html"><code class="docutils literal notranslate"><span class="pre">origami</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/polygon.html"><code class="docutils literal notranslate"><span class="pre">polygon</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/polygonal_surfaces.html"><code class="docutils literal notranslate"><span class="pre">polygonal_surfaces</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/polygons.html"><code class="docutils literal notranslate"><span class="pre">polygons</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/polyhedra.html"><code class="docutils literal notranslate"><span class="pre">polyhedra</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/pyflatsurf_conversion.html"><code class="docutils literal notranslate"><span class="pre">pyflatsurf_conversion</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/euclidean_polygonal_surfaces.html"><code class="docutils literal notranslate"><span class="pre">euclidean_polygonal_surfaces</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/euclidean_polygons.html"><code class="docutils literal notranslate"><span class="pre">euclidean_polygons</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/euclidean_polygons_with_angles.html"><code class="docutils literal notranslate"><span class="pre">euclidean_polygons_with_angles</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/relative_homology.html"><code class="docutils literal notranslate"><span class="pre">relative_homology</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/similarity.html"><code class="docutils literal notranslate"><span class="pre">similarity</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/similarity_surfaces.html"><code class="docutils literal notranslate"><span class="pre">similarity_surfaces</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/similarity_surface_generators.html"><code class="docutils literal notranslate"><span class="pre">similarity_surface_generators</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/straight_line_trajectory.html"><code class="docutils literal notranslate"><span class="pre">straight_line_trajectory</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/subfield.html"><code class="docutils literal notranslate"><span class="pre">subfield</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/surface_category.html"><code class="docutils literal notranslate"><span class="pre">surface_category</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/surface_legacy.html"><code class="docutils literal notranslate"><span class="pre">surface_legacy</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/surface_objects.html"><code class="docutils literal notranslate"><span class="pre">surface_objects</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/surface.html"><code class="docutils literal notranslate"><span class="pre">surface</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/tangent_bundle.html"><code class="docutils literal notranslate"><span class="pre">tangent_bundle</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/thurston_veech.html"><code class="docutils literal notranslate"><span class="pre">thurston_veech</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/topological_surfaces.html"><code class="docutils literal notranslate"><span class="pre">topological_surfaces</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/translation_surfaces.html"><code class="docutils literal notranslate"><span class="pre">translation_surfaces</span></code></a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../graphical.html">The flatsurf.graphical Package</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of The flatsurf.graphical Package</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../graphical/hyperbolic.html"><code class="docutils literal notranslate"><span class="pre">hyperbolic</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../graphical/polygon.html"><code class="docutils literal notranslate"><span class="pre">polygon</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../graphical/straight_line_trajectory.html"><code class="docutils literal notranslate"><span class="pre">straight_line_trajectory</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../graphical/surface_point.html"><code class="docutils literal notranslate"><span class="pre">surface_point</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../graphical/surface.html"><code class="docutils literal notranslate"><span class="pre">surface</span></code></a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for flatsurf.geometry.surface</h1><div class="highlight"><pre>
<span></span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Generic mutable and immutable surfaces</span>

<span class="sd">This module provides base classes and implementations of surfaces. Most</span>
<span class="sd">surfaces in sage-flatsurf inherit from some of the classes in this module.</span>

<span class="sd">The most important class in this module is</span>
<span class="sd">:class:`MutableOrientedSimilaritySurface` which allows you to create a surface</span>
<span class="sd">by gluing polygons with similarities.</span>

<span class="sd">EXAMPLES:</span>

<span class="sd">We build a translation surface by gluing two hexagons, labeled 0 and 1::</span>

<span class="sd">    sage: from flatsurf import MutableOrientedSimilaritySurface, polygons</span>
<span class="sd">    sage: S = MutableOrientedSimilaritySurface(QuadraticField(3))</span>

<span class="sd">    sage: S.add_polygon(polygons.regular_ngon(6))</span>
<span class="sd">    0</span>
<span class="sd">    sage: S.add_polygon(polygons.regular_ngon(6))</span>
<span class="sd">    1</span>

<span class="sd">    sage: S.glue((0, 0), (1, 3))</span>
<span class="sd">    sage: S.glue((0, 1), (1, 4))</span>
<span class="sd">    sage: S.glue((0, 2), (1, 5))</span>
<span class="sd">    sage: S.glue((0, 3), (1, 0))</span>
<span class="sd">    sage: S.glue((0, 4), (1, 1))</span>
<span class="sd">    sage: S.glue((0, 5), (1, 2))</span>

<span class="sd">    sage: S</span>
<span class="sd">    Translation Surface built from 2 regular hexagons</span>

<span class="sd">We signal that the construction is complete. This refines the category of the</span>
<span class="sd">surface and makes more functionality available::</span>

<span class="sd">    sage: S.set_immutable()</span>
<span class="sd">    sage: S</span>
<span class="sd">    Translation Surface in H_2(1^2) built from 2 regular hexagons</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># ********************************************************************</span>
<span class="c1">#  This file is part of sage-flatsurf.</span>
<span class="c1">#</span>
<span class="c1">#        Copyright (C) 2016-2020 Vincent Delecroix</span>
<span class="c1">#                           2023 Julian Rüth</span>
<span class="c1">#</span>
<span class="c1">#  sage-flatsurf is free software: you can redistribute it and/or modify</span>
<span class="c1">#  it under the terms of the GNU General Public License as published by</span>
<span class="c1">#  the Free Software Foundation, either version 2 of the License, or</span>
<span class="c1">#  (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1">#  sage-flatsurf is distributed in the hope that it will be useful,</span>
<span class="c1">#  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1">#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1">#  GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1">#  You should have received a copy of the GNU General Public License</span>
<span class="c1">#  along with sage-flatsurf. If not, see &lt;https://www.gnu.org/licenses/&gt;.</span>
<span class="c1"># ********************************************************************</span>
<span class="kn">import</span> <span class="nn">collections.abc</span>

<span class="kn">from</span> <span class="nn">sage.structure.parent</span> <span class="kn">import</span> <span class="n">Parent</span>
<span class="kn">from</span> <span class="nn">sage.misc.cachefunc</span> <span class="kn">import</span> <span class="n">cached_method</span>

<span class="kn">from</span> <span class="nn">flatsurf.geometry.surface_objects</span> <span class="kn">import</span> <span class="n">SurfacePoint</span>


<div class="viewcode-block" id="Surface_base"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.Surface_base">[docs]</a><span class="k">class</span> <span class="nc">Surface_base</span><span class="p">(</span><span class="n">Parent</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A base class for all surfaces in sage-flatsurf.</span>

<span class="sd">    This class patches bits of the category framework in SageMath that assume</span>
<span class="sd">    that all parent structures are immutable.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import translation_surfaces</span>
<span class="sd">        sage: S = translation_surfaces.square_torus()</span>

<span class="sd">        sage: from flatsurf.geometry.surface import Surface_base</span>
<span class="sd">        sage: isinstance(S, Surface_base)</span>
<span class="sd">        True</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_refine_category_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Refine the category of this surface to a subcategory ``category``.</span>

<span class="sd">        We need to override this method from ``Parent`` since we need to</span>
<span class="sd">        disable a hashing check that is otherwise enabled when doctesting.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>
<span class="sd">            sage: S.category()</span>
<span class="sd">            Category of finite type oriented similarity surfaces</span>

<span class="sd">            sage: S._refine_category_(S.refined_category())</span>
<span class="sd">            sage: S.category()</span>
<span class="sd">            Category of connected without boundary finite type translation surfaces</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.structure.debug_options</span> <span class="kn">import</span> <span class="n">debug</span>

        <span class="n">old_refine_category_hash_check</span> <span class="o">=</span> <span class="n">debug</span><span class="o">.</span><span class="n">refine_category_hash_check</span>
        <span class="n">debug</span><span class="o">.</span><span class="n">refine_category_hash_check</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_refine_category_</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">debug</span><span class="o">.</span><span class="n">refine_category_hash_check</span> <span class="o">=</span> <span class="n">old_refine_category_hash_check</span>

        <span class="c1"># The (cached) an_element is going to fail its test suite because it has the wrong category now.</span>
        <span class="c1"># Make sure that we create a new copy of an_element when requested.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache_an_element</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="MutablePolygonalSurface"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutablePolygonalSurface">[docs]</a><span class="k">class</span> <span class="nc">MutablePolygonalSurface</span><span class="p">(</span><span class="n">Surface_base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A base class for mutable surfaces that are built by gluing polygons.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import MutableOrientedSimilaritySurface</span>
<span class="sd">        sage: S = MutableOrientedSimilaritySurface(QQ)</span>

<span class="sd">        sage: from flatsurf.geometry.surface import MutablePolygonalSurface</span>
<span class="sd">        sage: isinstance(S, MutablePolygonalSurface)</span>
<span class="sd">        True</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="MutablePolygonalSurface.__init__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutablePolygonalSurface.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">ZZ</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_next_label</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_roots</span> <span class="o">=</span> <span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_mutable</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">category</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_test_refined_category</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test that this surface has been refined to its best possible</span>
<span class="sd">        subcategory (that can be computed cheaply.)</span>

<span class="sd">        We override this method here to disable this check for mutable</span>
<span class="sd">        surfaces. Mutable surfaces have not been refined yet since changes in</span>
<span class="sd">        the surface might require a widening of the category which is not</span>
<span class="sd">        possible.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>

<span class="sd">            sage: S._test_refined_category()</span>
<span class="sd">            sage: S.set_immutable()</span>
<span class="sd">            sage: S._test_refined_category()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mutable</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_test_refined_category</span><span class="p">(</span><span class="o">**</span><span class="n">options</span><span class="p">)</span>

<div class="viewcode-block" id="MutablePolygonalSurface.add_polygon"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutablePolygonalSurface.add_polygon">[docs]</a>    <span class="k">def</span> <span class="nf">add_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polygon</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an unglued polygon to this surface and return its label.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``polygon`` -- a simple Euclidean polygon</span>

<span class="sd">        - ``label`` -- a hashable identifier or ``None`` (default: ``None``);</span>
<span class="sd">          if ``None`` an integer identifier is automatically selected</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            0</span>

<span class="sd">            sage: S.add_polygon(polygons.square(), label=0)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: polygon label already present in this surface</span>

<span class="sd">            sage: S.add_polygon(polygons.square(), label=&#39;X&#39;)</span>
<span class="sd">            &#39;X&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mutable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;cannot modify an immutable surface&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_next_label</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_label</span>

        <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;polygon label already present in this surface&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">label</span></div>

<div class="viewcode-block" id="MutablePolygonalSurface.add_polygons"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutablePolygonalSurface.add_polygons">[docs]</a>    <span class="k">def</span> <span class="nf">add_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polygons</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add several polygons with automatically assigned labels at once.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: S.add_polygons([polygons.square(), polygons.square()])</span>
<span class="sd">            doctest:warning</span>
<span class="sd">            ...</span>
<span class="sd">            UserWarning: add_polygons() has been deprecated and will be removed in a future version of sage-flatsurf; use labels = [add_polygon(p) for p in polygons] instead</span>
<span class="sd">            [0, 1]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">warnings</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;add_polygons() has been deprecated and will be removed in a future version of sage-flatsurf; use labels = [add_polygon(p) for p in polygons] instead&quot;</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">add_polygon</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">polygons</span><span class="p">]</span></div>

<div class="viewcode-block" id="MutablePolygonalSurface.set_default_graphical_surface"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutablePolygonalSurface.set_default_graphical_surface">[docs]</a>    <span class="k">def</span> <span class="nf">set_default_graphical_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graphical_surface</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        EXAMPLES:</span>

<span class="sd">        This has been disabled because it tends to break caching::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>
<span class="sd">            sage: S.set_default_graphical_surface(S.graphical_surface())</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            NotImplementedError: set_default_graphical_surface() has been removed from this version of sage-flatsurf. If you want to change the default plotting of a surface, create a subclass and override graphical_surface() instead</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;set_default_graphical_surface() has been removed from this version of sage-flatsurf. If you want to change the default plotting of a surface, create a subclass and override graphical_surface() instead&quot;</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="MutablePolygonalSurface.remove_polygon"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutablePolygonalSurface.remove_polygon">[docs]</a>    <span class="k">def</span> <span class="nf">remove_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the polygon with label ``label`` from this surface (and all data</span>
<span class="sd">        associated to it.)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            0</span>

<span class="sd">            sage: S.remove_polygon(0)</span>

<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mutable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;cannot modify an immutable surface&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_roots</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">root</span> <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_roots</span> <span class="k">if</span> <span class="n">root</span> <span class="o">!=</span> <span class="n">label</span><span class="p">)</span></div>

<div class="viewcode-block" id="MutablePolygonalSurface.roots"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutablePolygonalSurface.roots">[docs]</a>    <span class="k">def</span> <span class="nf">roots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a label for each connected component on this surface.</span>

<span class="sd">        This implements :meth:`flatsurf.geometry.categories.polygonal_surfaces.PolygonalSurfaces.ParentMethods.roots`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>

<span class="sd">            sage: S.roots()</span>
<span class="sd">            ()</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            0</span>

<span class="sd">            sage: S.roots()</span>
<span class="sd">            (0,)</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            1</span>

<span class="sd">            sage: S.roots()</span>
<span class="sd">            (0, 1)</span>

<span class="sd">            sage: S.glue((0, 0), (1, 0))</span>
<span class="sd">            sage: S.roots()</span>
<span class="sd">            (0,)</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`components`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">LabeledView</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">RootedComponents_MutablePolygonalSurface</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">finite</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="MutablePolygonalSurface.components"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutablePolygonalSurface.components">[docs]</a>    <span class="k">def</span> <span class="nf">components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the connected components as the sequence of their respective</span>
<span class="sd">        polygon labels.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>

<span class="sd">            sage: S.components()</span>
<span class="sd">            ()</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            0</span>

<span class="sd">            sage: S.components()</span>
<span class="sd">            ((0,),)</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            1</span>

<span class="sd">            sage: S.components()</span>
<span class="sd">            ((0,), (1,))</span>

<span class="sd">            sage: S.glue((0, 0), (1, 0))</span>
<span class="sd">            sage: S.components()</span>
<span class="sd">            ((0, 1),)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">LabeledView</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">RootedComponents_MutablePolygonalSurface</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">finite</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="MutablePolygonalSurface.polygon"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutablePolygonalSurface.polygon">[docs]</a>    <span class="k">def</span> <span class="nf">polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the polygon with label ``label`` in this surface.</span>

<span class="sd">        This implements</span>
<span class="sd">        :meth:`flatsurf.geometry.categories.polygonal_surfaces.PolygonalSurfaces.ParentMethods.polygon`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>

<span class="sd">            sage: S.polygon(0)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            KeyError: 0</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            0</span>

<span class="sd">            sage: S.polygon(0)</span>
<span class="sd">            Polygon(vertices=[(0, 0), (1, 0), (1, 1), (0, 1)])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span><span class="p">[</span><span class="n">label</span><span class="p">]</span></div>

<div class="viewcode-block" id="MutablePolygonalSurface.set_immutable"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutablePolygonalSurface.set_immutable">[docs]</a>    <span class="k">def</span> <span class="nf">set_immutable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make this surface immutable.</span>

<span class="sd">        Any mutation attempts from now on will be an error.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            0</span>

<span class="sd">            sage: S.glue((0, 0), (0, 2))</span>
<span class="sd">            sage: S.glue((0, 1), (0, 3))</span>

<span class="sd">        Note that declaring a surface immutable refines its category and</span>
<span class="sd">        thereby unlocks more methods that are available to such a surface::</span>

<span class="sd">            sage: S.category()</span>
<span class="sd">            Category of finite type oriented similarity surfaces</span>
<span class="sd">            sage: old_methods = set(method for method in dir(S) if not method.startswith(&#39;_&#39;))</span>

<span class="sd">            sage: S.set_immutable()</span>
<span class="sd">            sage: S.category()</span>
<span class="sd">            Category of connected without boundary finite type translation surfaces</span>
<span class="sd">            sage: new_methods = set(method for method in dir(S) if not method.startswith(&#39;_&#39;))</span>
<span class="sd">            sage: new_methods - old_methods</span>
<span class="sd">            {&#39;angles&#39;,</span>
<span class="sd">             &#39;apply_matrix&#39;,</span>
<span class="sd">             &#39;area&#39;,</span>
<span class="sd">             &#39;canonicalize&#39;,</span>
<span class="sd">             &#39;canonicalize_mapping&#39;,</span>
<span class="sd">             &#39;erase_marked_points&#39;,</span>
<span class="sd">             &#39;holonomy_field&#39;,</span>
<span class="sd">             &#39;is_veering_triangulated&#39;,</span>
<span class="sd">             &#39;j_invariant&#39;,</span>
<span class="sd">             &#39;l_infinity_delaunay_triangulation&#39;,</span>
<span class="sd">             &#39;minimal_translation_cover&#39;,</span>
<span class="sd">             &#39;normalized_coordinates&#39;,</span>
<span class="sd">             &#39;rel_deformation&#39;,</span>
<span class="sd">             &#39;stratum&#39;,</span>
<span class="sd">             &#39;veering_triangulation&#39;}</span>

<span class="sd">        An immutable surface cannot be mutated anymore::</span>

<span class="sd">            sage: S.remove_polygon(0)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            Exception: cannot modify an immutable surface</span>

<span class="sd">        However, the category of an immutable might be further refined as</span>
<span class="sd">        (expensive to determine) features of the surface are deduced.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mutable</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_roots</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">roots</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mutable</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_refine_category_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">refined_category</span><span class="p">())</span></div>

<div class="viewcode-block" id="MutablePolygonalSurface.is_mutable"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutablePolygonalSurface.is_mutable">[docs]</a>    <span class="k">def</span> <span class="nf">is_mutable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this surface can be modified.</span>

<span class="sd">        This implements</span>
<span class="sd">        :meth:`flatsurf.geometry.categories.topological_surfaces.TopologicalSurfaces.ParentMethods.is_mutable`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>

<span class="sd">            sage: S.is_mutable()</span>
<span class="sd">            True</span>

<span class="sd">            sage: S.set_immutable()</span>
<span class="sd">            sage: S.is_mutable()</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mutable</span></div>

<div class="viewcode-block" id="MutablePolygonalSurface.__eq__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutablePolygonalSurface.__eq__">[docs]</a>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this surface is indistinguishable from ``other``.</span>

<span class="sd">        See</span>
<span class="sd">        :meth:`~.categories.similarity_surfaces.SimilaritySurfaces.FiniteType.ParentMethods._test_eq_surface`</span>
<span class="sd">        for details on this notion of equality.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>
<span class="sd">            sage: T = MutableOrientedSimilaritySurface(QQ)</span>

<span class="sd">            sage: S == T</span>
<span class="sd">            True</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            0</span>

<span class="sd">            sage: S == T</span>
<span class="sd">            False</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>
<span class="sd">            sage: T = MutableOrientedSimilaritySurface(QQ)</span>

<span class="sd">            sage: S != T</span>
<span class="sd">            False</span>

<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            0</span>

<span class="sd">            sage: S != T</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MutablePolygonalSurface</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">()</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">base</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_polygons</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Note that the order of the root labels matters since it changes the order of iteration in labels()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_roots</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_roots</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mutable</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_mutable</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="MutablePolygonalSurface.__hash__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutablePolygonalSurface.__hash__">[docs]</a>    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a hash value for this surface that is compatible with</span>
<span class="sd">        :meth:`__eq__`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>
<span class="sd">            sage: T = MutableOrientedSimilaritySurface(QQ)</span>
<span class="sd">            sage: hash(S) == hash(T)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            TypeError: cannot hash a mutable surface</span>

<span class="sd">            sage: S.set_immutable()</span>
<span class="sd">            sage: T.set_immutable()</span>
<span class="sd">            sage: hash(S) == hash(T)</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mutable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot hash a mutable surface&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">()),</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_roots</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a printable representation of this surface.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>
<span class="sd">            sage: S</span>
<span class="sd">            Empty Surface</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            0</span>
<span class="sd">            sage: S</span>
<span class="sd">            Translation Surface with boundary built from a square</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite_type</span><span class="p">():</span>
            <span class="k">return</span> <span class="s2">&quot;Surface built from infinitely many polygons&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;Empty Surface&quot;</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_describe_surface</span><span class="p">()</span><span class="si">}</span><span class="s2"> built from </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_describe_polygons</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span> <span class="nf">_describe_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a string describing this kind of surface.</span>

<span class="sd">        This is a helper method for :meth:`_repr_`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>
<span class="sd">            sage: S._describe_surface()</span>
<span class="sd">            &#39;Translation Surface&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;Surface&quot;</span>

    <span class="k">def</span> <span class="nf">_describe_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a string describing the nature of the polygons that make up this surface.</span>

<span class="sd">        This is a helper method for :meth:`_repr_`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>
<span class="sd">            sage: S._describe_polygons()</span>
<span class="sd">            &#39;&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">polygons</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">erase_marked_vertices</span><span class="p">()</span><span class="o">.</span><span class="n">vertices</span><span class="p">()),</span> <span class="n">p</span><span class="o">.</span><span class="n">describe_polygon</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">()</span>
        <span class="p">]</span>
        <span class="n">polygons</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">polygons</span> <span class="o">=</span> <span class="p">[</span><span class="n">description</span> <span class="k">for</span> <span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">description</span><span class="p">)</span> <span class="ow">in</span> <span class="n">polygons</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">polygons</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>

        <span class="n">collated</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">polygons</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">polygon</span> <span class="o">=</span> <span class="n">polygons</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">while</span> <span class="n">polygons</span> <span class="ow">and</span> <span class="n">polygons</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">polygon</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">polygons</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">collated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">polygon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">polygon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">collated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">count</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">polygon</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">description</span> <span class="o">=</span> <span class="n">collated</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">collated</span><span class="p">:</span>
            <span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">collated</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; and &quot;</span> <span class="o">+</span> <span class="n">description</span>

        <span class="k">return</span> <span class="n">description</span>

<div class="viewcode-block" id="MutablePolygonalSurface.set_root"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutablePolygonalSurface.set_root">[docs]</a>    <span class="k">def</span> <span class="nf">set_root</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set ``root`` as the label at which exploration of a connected component</span>
<span class="sd">        starts.</span>

<span class="sd">        This method can be called for connected and disconnected surfaces. In</span>
<span class="sd">        either case, it establishes ``root`` as the new label from which</span>
<span class="sd">        enumeration of the connected component containing it starts. If another</span>
<span class="sd">        label for this component had been set earlier, it is replaced.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            After roots have been declared explicitly, gluing operations come</span>
<span class="sd">            at an additional cost since the root labels have to be updated</span>
<span class="sd">            sometimes. It is therefore good practice to declare the root labels</span>
<span class="sd">            after all the gluings have been established when creating a</span>
<span class="sd">            surface.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``root`` -- a polygon label in this surface</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>

<span class="sd">            sage: S.set_root(0)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: root must be a label in the surface</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            0</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            1</span>

<span class="sd">            sage: S.set_root(0)</span>
<span class="sd">            sage: S.set_root(1)</span>

<span class="sd">            sage: S.roots()</span>
<span class="sd">            (0, 1)</span>

<span class="sd">        Note that the roots get updated automatically when merging components::</span>

<span class="sd">            sage: S.glue((0, 0), (1, 0))</span>
<span class="sd">            sage: S.roots()</span>
<span class="sd">            (0,)</span>

<span class="sd">        The purpose of changing the root label is to modify the order of</span>
<span class="sd">        exploration, e.g., in :meth:`labels`::</span>

<span class="sd">            sage: S.labels()</span>
<span class="sd">            (0, 1)</span>

<span class="sd">            sage: S.set_root(1)</span>
<span class="sd">            sage: S.labels()</span>
<span class="sd">            (1, 0)</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`set_roots` to replace all the root labels</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mutable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;cannot modify an immutable surface&quot;</span><span class="p">)</span>

        <span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="n">label</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">()</span> <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="n">root</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;root must be a label in the surface&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">component</span> <span class="o">=</span> <span class="p">[</span><span class="n">component</span> <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">()</span> <span class="k">if</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">component</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">component</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">component</span> <span class="o">=</span> <span class="n">component</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_roots</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_roots</span> <span class="k">if</span> <span class="n">r</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">component</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">root</span><span class="p">,)</span></div>

<div class="viewcode-block" id="MutablePolygonalSurface.set_roots"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutablePolygonalSurface.set_roots">[docs]</a>    <span class="k">def</span> <span class="nf">set_roots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roots</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Declare that the labels in ``roots`` are the labels from which their</span>
<span class="sd">        corresponding connected components should be enumerated.</span>

<span class="sd">        There must be at most one label for each connected component in</span>
<span class="sd">        ``roots``. Components that have no label set explicitly will have their</span>
<span class="sd">        label chosen automatically.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``roots`` -- a sequence of polygon labels in this surface</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            0</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            1</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            2</span>

<span class="sd">            sage: S.glue((0, 0), (1, 0))</span>

<span class="sd">            sage: S.set_roots([1])</span>
<span class="sd">            sage: S.roots()</span>
<span class="sd">            (1, 2)</span>

<span class="sd">        Setting the roots of connected components affects their enumeration in :meth:`labels`::</span>

<span class="sd">            sage: S.labels()</span>
<span class="sd">            (1, 0, 2)</span>

<span class="sd">            sage: S.set_roots([0, 2])</span>
<span class="sd">            sage: S.labels()</span>
<span class="sd">            (0, 1, 2)</span>

<span class="sd">        There must be at most one root per component::</span>

<span class="sd">            sage: S.set_roots([0, 1, 2])</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: there must be at most one root label for each connected component</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mutable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;cannot modify an immutable surface&quot;</span><span class="p">)</span>

        <span class="n">roots</span> <span class="o">=</span> <span class="p">[[</span><span class="n">label</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">()</span> <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="n">root</span><span class="p">]</span> <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;roots must be existing labels in the surface&quot;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">)</span>

        <span class="n">roots</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">([</span><span class="n">root</span> <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">roots</span> <span class="k">if</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">component</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;there must be at most one root label for each connected component&quot;</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_roots</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span></div>

<div class="viewcode-block" id="MutablePolygonalSurface.change_base_label"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutablePolygonalSurface.change_base_label">[docs]</a>    <span class="k">def</span> <span class="nf">change_base_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a deprecated alias for :meth:`set_root`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            0</span>

<span class="sd">            sage: S.change_base_label(0)</span>
<span class="sd">            doctest:warning</span>
<span class="sd">            ...</span>
<span class="sd">            UserWarning: change_base_label() has been deprecated and will be removed in a future version of sage-flatsurf; use set_root() instead</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">warnings</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;change_base_label() has been deprecated and will be removed in a future version of sage-flatsurf; use set_root() instead&quot;</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_root</span><span class="p">(</span><span class="n">label</span><span class="p">)</span></div>

<div class="viewcode-block" id="MutablePolygonalSurface.labels"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutablePolygonalSurface.labels">[docs]</a>    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the polygon labels in this surface.</span>

<span class="sd">        This replaces the generic</span>
<span class="sd">        :meth:`flatsurf.geometry.categories.polygonal_surfaces.PolygonalSurfaces.ParentMethods.labels`</span>
<span class="sd">        method with a more efficient implementation.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>

<span class="sd">            sage: S.labels()</span>
<span class="sd">            ()</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            0</span>

<span class="sd">            sage: S.labels()</span>
<span class="sd">            (0,)</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`polygon` to translate polygon labels to the corresponding polygons</span>

<span class="sd">            :meth:`polygons` for the corresponding sequence of polygons</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">LabelsFromView</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">finite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="MutablePolygonalSurface.polygons"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutablePolygonalSurface.polygons">[docs]</a>    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the polygons that make up this surface.</span>

<span class="sd">        The order the polygons are returned is guaranteed to be compatible with</span>
<span class="sd">        the order of the labels in :meth:`~.categories.polygonal_surfaces.PolygonalSurfaces.ParentMethods.labels`.</span>

<span class="sd">        This replaces the generic</span>
<span class="sd">        :meth:`flatsurf.geometry.categories.polygonal_surfaces.PolygonalSurfaces.ParentMethods.polygons`</span>
<span class="sd">        with a more efficient implementation.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>

<span class="sd">            sage: S.polygons()</span>
<span class="sd">            ()</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            0</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            1</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            2</span>

<span class="sd">            sage: S.polygons()</span>
<span class="sd">            (Polygon(vertices=[(0, 0), (1, 0), (1, 1), (0, 1)]), Polygon(vertices=[(0, 0), (1, 0), (1, 1), (0, 1)]), Polygon(vertices=[(0, 0), (1, 0), (1, 1), (0, 1)]))</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`polygon` to get a single polygon</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Polygons_MutableOrientedSimilaritySurface</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="OrientedSimilaritySurface"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.OrientedSimilaritySurface">[docs]</a><span class="k">class</span> <span class="nc">OrientedSimilaritySurface</span><span class="p">(</span><span class="n">Surface_base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for surfaces built from Euclidean polygons that are glued with</span>
<span class="sd">    orientation preserving similarities.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import MutableOrientedSimilaritySurface</span>
<span class="sd">        sage: S = MutableOrientedSimilaritySurface(QQ)</span>

<span class="sd">        sage: from flatsurf.geometry.surface import OrientedSimilaritySurface</span>
<span class="sd">        sage: isinstance(S, OrientedSimilaritySurface)</span>
<span class="sd">        True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Element</span> <span class="o">=</span> <span class="n">SurfacePoint</span>

<div class="viewcode-block" id="OrientedSimilaritySurface.__init__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.OrientedSimilaritySurface.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sage.categories.all</span> <span class="kn">import</span> <span class="n">Rings</span>

        <span class="k">if</span> <span class="n">base</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Rings</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;base ring must be a ring&quot;</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">flatsurf.geometry.categories</span> <span class="kn">import</span> <span class="n">SimilaritySurfaces</span>

        <span class="k">if</span> <span class="n">category</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">category</span> <span class="o">=</span> <span class="n">SimilaritySurfaces</span><span class="p">()</span><span class="o">.</span><span class="n">Oriented</span><span class="p">()</span>

        <span class="n">category</span> <span class="o">&amp;=</span> <span class="n">SimilaritySurfaces</span><span class="p">()</span><span class="o">.</span><span class="n">Oriented</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">category</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_describe_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite_type</span><span class="p">():</span>
            <span class="k">return</span> <span class="s2">&quot;Surface built from infinitely many polygons&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_connected</span><span class="p">():</span>
            <span class="c1"># Many checks do not work yet if a surface is not connected, so we stop here.</span>
            <span class="k">return</span> <span class="s2">&quot;Disconnected Surface&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_translation_surface</span><span class="p">(</span><span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;Translation Surface&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_translation_surface</span><span class="p">(</span><span class="n">positive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;Half-Translation Surface&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_dilation_surface</span><span class="p">(</span><span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;Positive Dilation Surface&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_dilation_surface</span><span class="p">(</span><span class="n">positive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;Dilation Surface&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_cone_surface</span><span class="p">():</span>
            <span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;Cone Surface&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_rational_surface</span><span class="p">():</span>
                <span class="n">description</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Rational </span><span class="si">{</span><span class="n">description</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;Surface&quot;</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;stratum&quot;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">description</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="c1"># Computation of the stratum might fail due to #227.</span>
                <span class="k">pass</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">genus</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="n">description</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Genus </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">description</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_with_boundary</span><span class="p">():</span>
            <span class="n">description</span> <span class="o">+=</span> <span class="s2">&quot; with boundary&quot;</span>

        <span class="k">return</span> <span class="n">description</span></div>


<div class="viewcode-block" id="MutableOrientedSimilaritySurface_base"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutableOrientedSimilaritySurface_base">[docs]</a><span class="k">class</span> <span class="nc">MutableOrientedSimilaritySurface_base</span><span class="p">(</span><span class="n">OrientedSimilaritySurface</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for surface built from Euclidean polyogns glued by orientation</span>
<span class="sd">    preserving similarities.</span>

<span class="sd">    This provides the features of :class:`MutableOrientedSimilaritySurface`</span>
<span class="sd">    without making a choice about how data is stored internally; it is a</span>
<span class="sd">    generic base class for other implementations of mutable surfaces.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import MutableOrientedSimilaritySurface</span>
<span class="sd">        sage: S = MutableOrientedSimilaritySurface(QQ)</span>

<span class="sd">        sage: from flatsurf.geometry.surface import MutableOrientedSimilaritySurface_base</span>
<span class="sd">        sage: isinstance(S, MutableOrientedSimilaritySurface_base)</span>
<span class="sd">        True</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="MutableOrientedSimilaritySurface_base.triangle_flip"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutableOrientedSimilaritySurface_base.triangle_flip">[docs]</a>    <span class="k">def</span> <span class="nf">triangle_flip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">test</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overrides</span>
<span class="sd">        :meth:`.categories.similarity_surfaces.SimilaritySurfaces.Oriented.ParentMethods.triangle_flip`</span>
<span class="sd">        to provide in-place flipping of triangles.</span>

<span class="sd">        See that method for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">triangle_flip</span><span class="p">(</span>
                <span class="n">l1</span><span class="o">=</span><span class="n">l1</span><span class="p">,</span> <span class="n">e1</span><span class="o">=</span><span class="n">e1</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="n">in_place</span><span class="p">,</span> <span class="n">test</span><span class="o">=</span><span class="n">test</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">direction</span>
            <span class="p">)</span>

        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">p1</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">l1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The polygon with the provided label is not a triangle.&quot;</span><span class="p">)</span>
        <span class="n">l2</span><span class="p">,</span> <span class="n">e2</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">e1</span><span class="p">)</span>

        <span class="n">sim</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">edge_transformation</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">l2</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">p2</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The polygon opposite the provided edge is not a triangle.&quot;</span>
            <span class="p">)</span>

        <span class="kn">from</span> <span class="nn">flatsurf</span> <span class="kn">import</span> <span class="n">Polygon</span>

        <span class="n">p2</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[</span><span class="n">sim</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">p2</span><span class="o">.</span><span class="n">vertices</span><span class="p">()],</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">p1</span><span class="o">.</span><span class="n">base_ring</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">direction</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="c1"># Get vertices corresponding to separatices in the provided direction.</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">find_separatrix</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="n">find_separatrix</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Our quadrilateral has vertices labeled:</span>
        <span class="c1"># * 0=p1.vertex(e1+1)=p2.vertex(e2)</span>
        <span class="c1"># * 1=p1.vertex(e1+2)</span>
        <span class="c1"># * 2=p1.vertex(e1)=p2.vertex(e2+1)</span>
        <span class="c1"># * 3=p2.vertex(e2+2)</span>
        <span class="c1"># Record the corresponding vertices of this quadrilateral.</span>
        <span class="n">q1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="n">v1</span> <span class="o">-</span> <span class="n">e1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span>
        <span class="n">q2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="n">v2</span> <span class="o">-</span> <span class="n">e2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span>

        <span class="n">new_diagonal</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="n">vertex</span><span class="p">((</span><span class="n">e2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">p1</span><span class="o">.</span><span class="n">vertex</span><span class="p">((</span><span class="n">e1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span>
        <span class="c1"># This list will store the new triangles which are being glued in.</span>
        <span class="c1"># (Unfortunately, they may not be cyclically labeled in the correct way.)</span>
        <span class="n">new_triangle</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">new_triangle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">Polygon</span><span class="p">(</span>
                    <span class="n">edges</span><span class="o">=</span><span class="p">[</span>
                        <span class="n">p1</span><span class="o">.</span><span class="n">edge</span><span class="p">((</span><span class="n">e1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">),</span>
                        <span class="n">p2</span><span class="o">.</span><span class="n">edge</span><span class="p">((</span><span class="n">e2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">),</span>
                        <span class="o">-</span><span class="n">new_diagonal</span><span class="p">,</span>
                    <span class="p">],</span>
                    <span class="n">base_ring</span><span class="o">=</span><span class="n">p1</span><span class="o">.</span><span class="n">base_ring</span><span class="p">(),</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">new_triangle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">Polygon</span><span class="p">(</span>
                    <span class="n">edges</span><span class="o">=</span><span class="p">[</span>
                        <span class="n">p2</span><span class="o">.</span><span class="n">edge</span><span class="p">((</span><span class="n">e2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">),</span>
                        <span class="n">p1</span><span class="o">.</span><span class="n">edge</span><span class="p">((</span><span class="n">e1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">),</span>
                        <span class="n">new_diagonal</span><span class="p">,</span>
                    <span class="p">],</span>
                    <span class="n">base_ring</span><span class="o">=</span><span class="n">p1</span><span class="o">.</span><span class="n">base_ring</span><span class="p">(),</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># The above triangles would be glued along edge 2 to form the diagonal of the quadrilateral being removed.</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Gluing triangles along this edge yields a non-convex quadrilateral.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Find the separatrices of the two new triangles, and in particular which way they point.</span>
        <span class="n">new_sep</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_sep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_triangle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">find_separatrix</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">new_sep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_triangle</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">find_separatrix</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># The quadrilateral vertices corresponding to these separatrices are</span>
        <span class="c1"># new_sep[0]+1 and (new_sep[1]+3)%4 respectively.</span>

        <span class="c1"># i=0 if the new_triangle[0] should be labeled l1 and new_triangle[1] should be labeled l2.</span>
        <span class="c1"># i=1 indicates the opposite labeling.</span>
        <span class="k">if</span> <span class="n">new_sep</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">q1</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">new_sep</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="n">q2</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">new_sep</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="n">q1</span>
            <span class="k">assert</span> <span class="n">new_sep</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">q2</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># These quantities represent the cyclic relabeling of triangles needed.</span>
        <span class="n">cycle1</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_sep</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">v1</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span>
        <span class="n">cycle2</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_sep</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">v2</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span>

        <span class="c1"># This will be the new triangle with label l1:</span>
        <span class="n">tri1</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span>
            <span class="n">edges</span><span class="o">=</span><span class="p">[</span>
                <span class="n">new_triangle</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">cycle1</span><span class="p">),</span>
                <span class="n">new_triangle</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">edge</span><span class="p">((</span><span class="n">cycle1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">),</span>
                <span class="n">new_triangle</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">edge</span><span class="p">((</span><span class="n">cycle1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">),</span>
            <span class="p">],</span>
            <span class="n">base_ring</span><span class="o">=</span><span class="n">p1</span><span class="o">.</span><span class="n">base_ring</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="c1"># This will be the new triangle with label l2:</span>
        <span class="n">tri2</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span>
            <span class="n">edges</span><span class="o">=</span><span class="p">[</span>
                <span class="n">new_triangle</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">cycle2</span><span class="p">),</span>
                <span class="n">new_triangle</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">edge</span><span class="p">((</span><span class="n">cycle2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">),</span>
                <span class="n">new_triangle</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">edge</span><span class="p">((</span><span class="n">cycle2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">),</span>
            <span class="p">],</span>
            <span class="n">base_ring</span><span class="o">=</span><span class="n">p1</span><span class="o">.</span><span class="n">base_ring</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="c1"># In the above, edge 2-cycle1 of tri1 would be glued to edge 2-cycle2 of tri2</span>
        <span class="n">diagonal_glue_e1</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">cycle1</span>
        <span class="n">diagonal_glue_e2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">cycle2</span>

        <span class="k">assert</span> <span class="n">p1</span><span class="o">.</span><span class="n">find_separatrix</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">)</span> <span class="o">==</span> <span class="n">tri1</span><span class="o">.</span><span class="n">find_separatrix</span><span class="p">(</span>
            <span class="n">direction</span><span class="o">=</span><span class="n">direction</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="n">p2</span><span class="o">.</span><span class="n">find_separatrix</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">)</span> <span class="o">==</span> <span class="n">tri2</span><span class="o">.</span><span class="n">find_separatrix</span><span class="p">(</span>
            <span class="n">direction</span><span class="o">=</span><span class="n">direction</span>
        <span class="p">)</span>

        <span class="c1"># Two opposite edges will not change their labels (label,edge) under our regluing operation.</span>
        <span class="c1"># The other two opposite ones will change and in fact they change labels.</span>
        <span class="c1"># The following finds them (there are two cases).</span>
        <span class="c1"># At the end of the if statement, the following will be true:</span>
        <span class="c1"># * new_glue_e1 and new_glue_e2 will be the edges of the new triangle with label l1 and l2 which need regluing.</span>
        <span class="c1"># * old_e1 and old_e2 will be the corresponding edges of the old triangles.</span>
        <span class="c1"># (Note that labels are swapped between the pair. The appending 1 or 2 refers to the label used for the triangle.)</span>
        <span class="k">if</span> <span class="n">p1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="o">==</span> <span class="n">tri1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">v1</span><span class="p">):</span>
            <span class="c1"># We don&#39;t have to worry about changing gluings on edge v1 of the triangles with label l1</span>
            <span class="c1"># We do have to worry about the following edge:</span>
            <span class="n">new_glue_e1</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mi">3</span> <span class="o">-</span> <span class="n">diagonal_glue_e1</span> <span class="o">-</span> <span class="n">v1</span>
            <span class="p">)</span>  <span class="c1"># returns the edge which is neither diagonal_glue_e1 nor v1.</span>
            <span class="c1"># This corresponded to the following old edge:</span>
            <span class="n">old_e1</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">-</span> <span class="n">e1</span> <span class="o">-</span> <span class="n">v1</span>  <span class="c1"># Again this finds the edge which is neither e1 nor v1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">v1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span>
            <span class="k">assert</span> <span class="n">p1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">==</span> <span class="n">tri1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
            <span class="c1"># We don&#39;t have to worry about changing gluings on edge (v1+2)%3 of the triangles with label l1</span>
            <span class="c1"># We do have to worry about the following edge:</span>
            <span class="n">new_glue_e1</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mi">3</span> <span class="o">-</span> <span class="n">diagonal_glue_e1</span> <span class="o">-</span> <span class="n">temp</span>
            <span class="p">)</span>  <span class="c1"># returns the edge which is neither diagonal_glue_e1 nor temp.</span>
            <span class="c1"># This corresponded to the following old edge:</span>
            <span class="n">old_e1</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mi">3</span> <span class="o">-</span> <span class="n">e1</span> <span class="o">-</span> <span class="n">temp</span>
            <span class="p">)</span>  <span class="c1"># Again this finds the edge which is neither e1 nor temp</span>
        <span class="k">if</span> <span class="n">p2</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span> <span class="o">==</span> <span class="n">tri2</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">v2</span><span class="p">):</span>
            <span class="c1"># We don&#39;t have to worry about changing gluings on edge v2 of the triangles with label l2</span>
            <span class="c1"># We do have to worry about the following edge:</span>
            <span class="n">new_glue_e2</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mi">3</span> <span class="o">-</span> <span class="n">diagonal_glue_e2</span> <span class="o">-</span> <span class="n">v2</span>
            <span class="p">)</span>  <span class="c1"># returns the edge which is neither diagonal_glue_e2 nor v2.</span>
            <span class="c1"># This corresponded to the following old edge:</span>
            <span class="n">old_e2</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">-</span> <span class="n">e2</span> <span class="o">-</span> <span class="n">v2</span>  <span class="c1"># Again this finds the edge which is neither e2 nor v2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">v2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span>
            <span class="k">assert</span> <span class="n">p2</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">==</span> <span class="n">tri2</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
            <span class="c1"># We don&#39;t have to worry about changing gluings on edge (v2+2)%3 of the triangles with label l2</span>
            <span class="c1"># We do have to worry about the following edge:</span>
            <span class="n">new_glue_e2</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mi">3</span> <span class="o">-</span> <span class="n">diagonal_glue_e2</span> <span class="o">-</span> <span class="n">temp</span>
            <span class="p">)</span>  <span class="c1"># returns the edge which is neither diagonal_glue_e2 nor temp.</span>
            <span class="c1"># This corresponded to the following old edge:</span>
            <span class="n">old_e2</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mi">3</span> <span class="o">-</span> <span class="n">e2</span> <span class="o">-</span> <span class="n">temp</span>
            <span class="p">)</span>  <span class="c1"># Again this finds the edge which is neither e2 nor temp</span>

        <span class="c1"># remember the old gluings.</span>
        <span class="n">old_opposite1</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">old_e1</span><span class="p">)</span>
        <span class="n">old_opposite2</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span> <span class="n">old_e2</span><span class="p">)</span>

        <span class="n">us</span> <span class="o">=</span> <span class="n">s</span>

        <span class="c1"># Replace the triangles.</span>
        <span class="n">us</span><span class="o">.</span><span class="n">replace_polygon</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">tri1</span><span class="p">)</span>
        <span class="n">us</span><span class="o">.</span><span class="n">replace_polygon</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span> <span class="n">tri2</span><span class="p">)</span>
        <span class="c1"># Glue along the new diagonal of the quadrilateral</span>
        <span class="n">us</span><span class="o">.</span><span class="n">glue</span><span class="p">((</span><span class="n">l1</span><span class="p">,</span> <span class="n">diagonal_glue_e1</span><span class="p">),</span> <span class="p">(</span><span class="n">l2</span><span class="p">,</span> <span class="n">diagonal_glue_e2</span><span class="p">))</span>
        <span class="c1"># Now we deal with that pair of opposite edges of the quadrilateral that need regluing.</span>
        <span class="c1"># There are some special cases:</span>
        <span class="k">if</span> <span class="n">old_opposite1</span> <span class="o">==</span> <span class="p">(</span><span class="n">l2</span><span class="p">,</span> <span class="n">old_e2</span><span class="p">):</span>
            <span class="c1"># These opposite edges were glued to each other.</span>
            <span class="c1"># Do the same in the new surface:</span>
            <span class="n">us</span><span class="o">.</span><span class="n">glue</span><span class="p">((</span><span class="n">l1</span><span class="p">,</span> <span class="n">new_glue_e1</span><span class="p">),</span> <span class="p">(</span><span class="n">l2</span><span class="p">,</span> <span class="n">new_glue_e2</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">old_opposite1</span> <span class="o">==</span> <span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">old_e1</span><span class="p">):</span>
                <span class="c1"># That edge was &quot;self-glued&quot;.</span>
                <span class="n">us</span><span class="o">.</span><span class="n">glue</span><span class="p">((</span><span class="n">l2</span><span class="p">,</span> <span class="n">new_glue_e2</span><span class="p">),</span> <span class="p">(</span><span class="n">l2</span><span class="p">,</span> <span class="n">new_glue_e2</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># The edge (l1,old_e1) was glued in a standard way.</span>
                <span class="c1"># That edge now corresponds to (l2,new_glue_e2):</span>
                <span class="n">us</span><span class="o">.</span><span class="n">glue</span><span class="p">((</span><span class="n">l2</span><span class="p">,</span> <span class="n">new_glue_e2</span><span class="p">),</span> <span class="p">(</span><span class="n">old_opposite1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">old_opposite1</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">old_opposite2</span> <span class="o">==</span> <span class="p">(</span><span class="n">l2</span><span class="p">,</span> <span class="n">old_e2</span><span class="p">):</span>
                <span class="c1"># That edge was &quot;self-glued&quot;.</span>
                <span class="n">us</span><span class="o">.</span><span class="n">glue</span><span class="p">((</span><span class="n">l1</span><span class="p">,</span> <span class="n">new_glue_e1</span><span class="p">),</span> <span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">new_glue_e1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># The edge (l2,old_e2) was glued in a standard way.</span>
                <span class="c1"># That edge now corresponds to (l1,new_glue_e1):</span>
                <span class="n">us</span><span class="o">.</span><span class="n">glue</span><span class="p">((</span><span class="n">l1</span><span class="p">,</span> <span class="n">new_glue_e1</span><span class="p">),</span> <span class="p">(</span><span class="n">old_opposite2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">old_opposite2</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="MutableOrientedSimilaritySurface_base.standardize_polygons"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutableOrientedSimilaritySurface_base.standardize_polygons">[docs]</a>    <span class="k">def</span> <span class="nf">standardize_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace each polygon with a new polygon which differs by</span>
<span class="sd">        translation and reindexing. The new polygon will have the property</span>
<span class="sd">        that vertex zero is the origin, and all vertices lie either in the</span>
<span class="sd">        upper half plane, or on the x-axis with non-negative x-coordinate.</span>

<span class="sd">        This is done to the current surface if in_place=True. A mutable</span>
<span class="sd">        copy is created and returned if in_place=False (as default).</span>

<span class="sd">        This overrides</span>
<span class="sd">        :meth:`flatsurf.geometry.categories.similarity_surfaces.SimilaritySurfaces.FiniteType.Oriented.ParentMethods.standardize_polygons`</span>
<span class="sd">        to provide in-place standardizing of surfaces.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface, Polygon</span>
<span class="sd">            sage: p = Polygon(vertices = ([(1,1),(2,1),(2,2),(1,2)]))</span>
<span class="sd">            sage: s = MutableOrientedSimilaritySurface(QQ)</span>
<span class="sd">            sage: s.add_polygon(p)</span>
<span class="sd">            0</span>
<span class="sd">            sage: s.glue((0, 0), (0, 2))</span>
<span class="sd">            sage: s.glue((0, 1), (0, 3))</span>
<span class="sd">            sage: s.set_root(0)</span>
<span class="sd">            sage: s.set_immutable()</span>

<span class="sd">            sage: s.standardize_polygons().polygon(0)</span>
<span class="sd">            Polygon(vertices=[(0, 0), (1, 0), (1, 1), (0, 1)])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">MutableOrientedSimilaritySurface</span><span class="o">.</span><span class="n">from_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">S</span><span class="o">.</span><span class="n">standardize_polygons</span><span class="p">(</span><span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">S</span>

        <span class="n">cv</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># dictionary for non-zero canonical vertices</span>
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">()):</span>
            <span class="n">best</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">best_pt</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">best</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">vertices</span><span class="p">())):</span>
                <span class="n">pt</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">best_pt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">best_pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">best_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">best</span> <span class="o">=</span> <span class="n">v</span>
                    <span class="n">best_pt</span> <span class="o">=</span> <span class="n">pt</span>
            <span class="c1"># We replace the polygon if the best vertex is not the zero vertex, or</span>
            <span class="c1"># if the coordinates of the best vertex differs from the origin.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">best</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">best_pt</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()):</span>
                <span class="n">cv</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">best</span>
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cv</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_vertex_zero</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div></div>


<div class="viewcode-block" id="MutableOrientedSimilaritySurface"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutableOrientedSimilaritySurface">[docs]</a><span class="k">class</span> <span class="nc">MutableOrientedSimilaritySurface</span><span class="p">(</span>
    <span class="n">MutableOrientedSimilaritySurface_base</span><span class="p">,</span> <span class="n">MutablePolygonalSurface</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A surface built from Euclidean polyogns glued by orientation preserving</span>
<span class="sd">    similarities.</span>

<span class="sd">    This is the main tool to create new surfaces of finite type in</span>
<span class="sd">    sage-flatsurf.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import MutableOrientedSimilaritySurface</span>
<span class="sd">        sage: S = MutableOrientedSimilaritySurface(QQ)</span>

<span class="sd">        sage: from flatsurf import polygons</span>
<span class="sd">        sage: S.add_polygon(polygons.square())</span>
<span class="sd">        0</span>

<span class="sd">        sage: S.glue((0, 0), (0, 2))</span>
<span class="sd">        sage: S.glue((0, 1), (0, 3))</span>

<span class="sd">        sage: S.set_immutable()</span>

<span class="sd">        sage: S</span>
<span class="sd">        Translation Surface in H_1(0) built from a square</span>

<span class="sd">    TESTS::</span>

<span class="sd">        sage: TestSuite(S).run()</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="MutableOrientedSimilaritySurface.__init__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutableOrientedSimilaritySurface.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gluings</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="kn">from</span> <span class="nn">flatsurf.geometry.categories</span> <span class="kn">import</span> <span class="n">SimilaritySurfaces</span>

        <span class="k">if</span> <span class="n">category</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">category</span> <span class="o">=</span> <span class="n">SimilaritySurfaces</span><span class="p">()</span><span class="o">.</span><span class="n">Oriented</span><span class="p">()</span><span class="o">.</span><span class="n">FiniteType</span><span class="p">()</span>

        <span class="n">category</span> <span class="o">&amp;=</span> <span class="n">SimilaritySurfaces</span><span class="p">()</span><span class="o">.</span><span class="n">Oriented</span><span class="p">()</span><span class="o">.</span><span class="n">FiniteType</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">category</span><span class="p">)</span></div>

<div class="viewcode-block" id="MutableOrientedSimilaritySurface.from_surface"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutableOrientedSimilaritySurface.from_surface">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_surface</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a mutable copy of ``surface``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import translation_surfaces, MutableOrientedSimilaritySurface, polygons</span>

<span class="sd">            sage: T = translation_surfaces.square_torus()</span>

<span class="sd">        We build a surface that is made from two tori:</span>

<span class="sd">            sage: S = MutableOrientedSimilaritySurface.from_surface(T)</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            1</span>
<span class="sd">            sage: S.glue((1, 0), (1, 2))</span>
<span class="sd">            sage: S.glue((1, 1), (1, 3))</span>

<span class="sd">            sage: S.set_immutable()</span>

<span class="sd">            sage: S</span>
<span class="sd">            Disconnected Surface built from 2 squares</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">surface</span><span class="o">.</span><span class="n">is_finite_type</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="n">MutableOrientedSimilaritySurface</span><span class="p">(</span><span class="n">surface</span><span class="o">.</span><span class="n">base_ring</span><span class="p">(),</span> <span class="n">category</span><span class="o">=</span><span class="n">category</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">surface</span><span class="o">.</span><span class="n">labels</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_polygon</span><span class="p">(</span><span class="n">surface</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">surface</span><span class="o">.</span><span class="n">labels</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">surface</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">vertices</span><span class="p">())):</span>
                <span class="n">cross</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cross</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">glue</span><span class="p">((</span><span class="n">label</span><span class="p">,</span> <span class="n">edge</span><span class="p">),</span> <span class="n">cross</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">MutablePolygonalSurface</span><span class="p">):</span>
            <span class="c1"># Only copy explicitly set roots over</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_roots</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">_roots</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_roots</span><span class="p">(</span><span class="n">surface</span><span class="o">.</span><span class="n">roots</span><span class="p">())</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="MutableOrientedSimilaritySurface.add_polygon"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutableOrientedSimilaritySurface.add_polygon">[docs]</a>    <span class="k">def</span> <span class="nf">add_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polygon</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Overrides add_polygon from MutablePolygonalSurface</span>
        <span class="n">label</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">add_polygon</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gluings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gluings</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_roots</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_roots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_roots</span> <span class="o">+</span> <span class="p">(</span><span class="n">label</span><span class="p">,)</span>

        <span class="k">return</span> <span class="n">label</span></div>

<div class="viewcode-block" id="MutableOrientedSimilaritySurface.remove_polygon"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutableOrientedSimilaritySurface.remove_polygon">[docs]</a>    <span class="k">def</span> <span class="nf">remove_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="c1"># Overrides remove_polygon from MutablePolygonalSurface</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unglue_polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gluings</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">remove_polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span></div>

<div class="viewcode-block" id="MutableOrientedSimilaritySurface.glue"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutableOrientedSimilaritySurface.glue">[docs]</a>    <span class="k">def</span> <span class="nf">glue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Glue ``x`` and ``y`` with an (orientation preserving) similarity.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``x`` -- a pair consisting of a polygon label and an edge index for</span>
<span class="sd">          that polygon</span>

<span class="sd">        - ``y`` -- a pair consisting of a polygon label and an edge index for</span>
<span class="sd">          that polygon</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface, polygons</span>

<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            0</span>

<span class="sd">        Glue two opposite sides of the square to each other::</span>

<span class="sd">            sage: S.glue((0, 1), (0, 3))</span>

<span class="sd">        Glue the other sides of the square to themselves::</span>

<span class="sd">            sage: S.glue((0, 0), (0, 0))</span>
<span class="sd">            sage: S.glue((0, 2), (0, 2))</span>

<span class="sd">        Note that existing gluings are removed when gluing already glued</span>
<span class="sd">        sides::</span>

<span class="sd">            sage: S.glue((0, 0), (0, 2))</span>
<span class="sd">            sage: S.set_immutable()</span>

<span class="sd">            sage: S</span>
<span class="sd">            Translation Surface in H_1(0) built from a square</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mutable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;cannot modify immutable surface; create a copy with MutableOrientedSimilaritySurface.from_surface()&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span>

        <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">unglue</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unglue</span><span class="p">(</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_roots</span><span class="p">:</span>
            <span class="n">component</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">component</span><span class="p">:</span>
                <span class="c1"># Gluing will join two connected components.</span>
                <span class="n">cross_component</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_roots</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">component</span> <span class="ow">or</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">cross_component</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_roots</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_roots</span> <span class="k">if</span> <span class="n">r</span> <span class="o">!=</span> <span class="n">root</span><span class="p">])</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;did not find any root to eliminate&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_gluings</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gluings</span><span class="p">[</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">x</span></div>

<div class="viewcode-block" id="MutableOrientedSimilaritySurface.unglue"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutableOrientedSimilaritySurface.unglue">[docs]</a>    <span class="k">def</span> <span class="nf">unglue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unglue the side ``edge`` of the polygon ``label`` if it is glued.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface, translation_surfaces</span>

<span class="sd">            sage: T = translation_surfaces.square_torus()</span>

<span class="sd">            sage: S = MutableOrientedSimilaritySurface.from_surface(T)</span>

<span class="sd">            sage: S.unglue(0, 0)</span>

<span class="sd">            sage: S.gluings()</span>
<span class="sd">            (((0, 1), (0, 3)), ((0, 3), (0, 1)))</span>

<span class="sd">            sage: S.set_immutable()</span>
<span class="sd">            sage: S</span>
<span class="sd">            Translation Surface with boundary built from a square</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mutable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;cannot modify immutable surface; create a copy with MutableOrientedSimilaritySurface.from_surface()&quot;</span>
            <span class="p">)</span>

        <span class="n">cross</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gluings</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="n">edge</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">cross</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gluings</span><span class="p">[</span><span class="n">cross</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">cross</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_gluings</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="n">edge</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">cross</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_roots</span><span class="p">:</span>
            <span class="n">component</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">cross</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">component</span><span class="p">:</span>
                <span class="c1"># Ungluing created a new connected component.</span>
                <span class="n">cross_component</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">cross</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="k">assert</span> <span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cross_component</span>
                <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_roots</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">component</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_roots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_roots</span> <span class="o">+</span> <span class="p">(</span>
                            <span class="n">LabeledView</span><span class="p">(</span>
                                <span class="n">surface</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">view</span><span class="o">=</span><span class="n">cross_component</span><span class="p">,</span> <span class="n">finite</span><span class="o">=</span><span class="kc">True</span>
                            <span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
                        <span class="p">)</span>
                        <span class="k">break</span>
                    <span class="k">if</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">cross_component</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_roots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_roots</span> <span class="o">+</span> <span class="p">(</span>
                            <span class="n">LabeledView</span><span class="p">(</span>
                                <span class="n">surface</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">view</span><span class="o">=</span><span class="n">component</span><span class="p">,</span> <span class="n">finite</span><span class="o">=</span><span class="kc">True</span>
                            <span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
                        <span class="p">)</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;did not find any root to split&quot;</span></div>

    <span class="k">def</span> <span class="nf">_unglue_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all gluigns from polygon ``label``.</span>

<span class="sd">        This is a helper method to completely unglue a polygon before removing</span>
<span class="sd">        or replacing it.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface, translation_surfaces</span>

<span class="sd">            sage: T = translation_surfaces.square_torus()</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface.from_surface(T)</span>

<span class="sd">            sage: S._unglue_polygon(0)</span>
<span class="sd">            sage: S.gluings()</span>
<span class="sd">            ()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">edge</span><span class="p">,</span> <span class="n">cross</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gluings</span><span class="p">[</span><span class="n">label</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">cross</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">cross_label</span><span class="p">,</span> <span class="n">cross_edge</span> <span class="o">=</span> <span class="n">cross</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gluings</span><span class="p">[</span><span class="n">cross_label</span><span class="p">][</span><span class="n">cross_edge</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gluings</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>

<div class="viewcode-block" id="MutableOrientedSimilaritySurface.set_edge_pairing"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutableOrientedSimilaritySurface.set_edge_pairing">[docs]</a>    <span class="k">def</span> <span class="nf">set_edge_pairing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label0</span><span class="p">,</span> <span class="n">edge0</span><span class="p">,</span> <span class="n">label1</span><span class="p">,</span> <span class="n">edge1</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import polygons, MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            0</span>
<span class="sd">            sage: S.set_edge_pairing(0, 0, 0, 2)</span>
<span class="sd">            doctest:warning</span>
<span class="sd">            ...</span>
<span class="sd">            UserWarning: set_edge_pairing(label0, edge0, label1, edge1) has been deprecated and will be removed in a future version of sage-flatsurf; use glue((label0, edge0), (label1, edge1)) instead</span>
<span class="sd">            sage: S.set_edge_pairing(0, 1, 0, 3)</span>

<span class="sd">            sage: S.gluings()</span>
<span class="sd">            (((0, 0), (0, 2)), ((0, 1), (0, 3)), ((0, 2), (0, 0)), ((0, 3), (0, 1)))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">warnings</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;set_edge_pairing(label0, edge0, label1, edge1) has been deprecated and will be removed in a future version of sage-flatsurf; use glue((label0, edge0), (label1, edge1)) instead&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">glue</span><span class="p">((</span><span class="n">label0</span><span class="p">,</span> <span class="n">edge0</span><span class="p">),</span> <span class="p">(</span><span class="n">label1</span><span class="p">,</span> <span class="n">edge1</span><span class="p">))</span></div>

<div class="viewcode-block" id="MutableOrientedSimilaritySurface.change_edge_gluing"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutableOrientedSimilaritySurface.change_edge_gluing">[docs]</a>    <span class="k">def</span> <span class="nf">change_edge_gluing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label0</span><span class="p">,</span> <span class="n">edge0</span><span class="p">,</span> <span class="n">label1</span><span class="p">,</span> <span class="n">edge1</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import polygons, MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            0</span>
<span class="sd">            sage: S.change_edge_gluing(0, 0, 0, 2)</span>
<span class="sd">            doctest:warning</span>
<span class="sd">            ...</span>
<span class="sd">            UserWarning: change_edge_gluing(label0, edge0, label1, edge1) has been deprecated and will be removed in a future version of sage-flatsurf; use glue((label0, edge0), (label1, edge1)) instead</span>
<span class="sd">            sage: S.change_edge_gluing(0, 1, 0, 3)</span>

<span class="sd">            sage: S.gluings()</span>
<span class="sd">            (((0, 0), (0, 2)), ((0, 1), (0, 3)), ((0, 2), (0, 0)), ((0, 3), (0, 1)))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">warnings</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;change_edge_gluing(label0, edge0, label1, edge1) has been deprecated and will be removed in a future version of sage-flatsurf; use glue((label0, edge0), (label1, edge1)) instead&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">glue</span><span class="p">((</span><span class="n">label0</span><span class="p">,</span> <span class="n">edge0</span><span class="p">),</span> <span class="p">(</span><span class="n">label1</span><span class="p">,</span> <span class="n">edge1</span><span class="p">))</span></div>

<div class="viewcode-block" id="MutableOrientedSimilaritySurface.change_polygon_gluings"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutableOrientedSimilaritySurface.change_polygon_gluings">[docs]</a>    <span class="k">def</span> <span class="nf">change_polygon_gluings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">gluings</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import polygons, MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            0</span>
<span class="sd">            sage: S.change_polygon_gluings(0, [(0, 2), (0, 3), (0, 0), (0, 1)])</span>
<span class="sd">            doctest:warning</span>
<span class="sd">            ...</span>
<span class="sd">            UserWarning: change_polygon_gluings() has been deprecated and will be removed in a future version of sage-flatsurf; use glue() in a loop instead</span>

<span class="sd">            sage: S.gluings()</span>
<span class="sd">            (((0, 0), (0, 2)), ((0, 1), (0, 3)), ((0, 2), (0, 0)), ((0, 3), (0, 1)))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">warnings</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;change_polygon_gluings() has been deprecated and will be removed in a future version of sage-flatsurf; use glue() in a loop instead&quot;</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">edge0</span><span class="p">,</span> <span class="n">cross</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gluings</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">cross</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unglue</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">edge0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">glue</span><span class="p">((</span><span class="n">label</span><span class="p">,</span> <span class="n">edge0</span><span class="p">),</span> <span class="n">cross</span><span class="p">)</span></div>

<div class="viewcode-block" id="MutableOrientedSimilaritySurface.change_polygon"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutableOrientedSimilaritySurface.change_polygon">[docs]</a>    <span class="k">def</span> <span class="nf">change_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">polygon</span><span class="p">,</span> <span class="n">gluing_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface, translation_surfaces</span>

<span class="sd">            sage: T = translation_surfaces.square_torus()</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface.from_surface(T)</span>

<span class="sd">            sage: S.change_polygon(0, 2 * S.polygon(0))</span>
<span class="sd">            doctest:warning</span>
<span class="sd">            ...</span>
<span class="sd">            UserWarning: change_polygon() has been deprecated and will be removed in a future version of sage-flatsurf; use replace_polygon() or remove_polygon() and add_polygon() instead</span>

<span class="sd">            sage: S.polygon(0)</span>
<span class="sd">            Polygon(vertices=[(0, 0), (2, 0), (2, 2), (0, 2)])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">warnings</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;change_polygon() has been deprecated and will be removed in a future version of sage-flatsurf; use replace_polygon() or remove_polygon() and add_polygon() instead&quot;</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mutable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;cannot modify immutable surface; create a copy with MutableOrientedSimilaritySurface.from_surface()&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Note that this obscure feature. If the number of edges is unchanged, we keep the gluings, otherwise we trash them all.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">vertices</span><span class="p">()):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unglue_polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gluings</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">polygon</span>

        <span class="k">if</span> <span class="n">gluing_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cross</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gluing_list</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">glue</span><span class="p">((</span><span class="n">label</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">cross</span><span class="p">)</span></div>

<div class="viewcode-block" id="MutableOrientedSimilaritySurface.replace_polygon"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutableOrientedSimilaritySurface.replace_polygon">[docs]</a>    <span class="k">def</span> <span class="nf">replace_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">polygon</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace the polygon ``label`` with ``polygon`` while keeping its</span>
<span class="sd">        gluings intact.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``label`` -- an element of :meth:`~.MutablePolygonalSurface.labels`</span>

<span class="sd">        - ``polygon`` -- a Euclidean polygon</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import Polygon, MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>
<span class="sd">            sage: S.add_polygon(Polygon(vertices=[(0, 0), (1, 0), (1, 1), (0, 1)]))</span>
<span class="sd">            0</span>
<span class="sd">            sage: S.glue((0, 0), (0, 2))</span>
<span class="sd">            sage: S.glue((0, 1), (0, 3))</span>

<span class="sd">            sage: S.replace_polygon(0, Polygon(vertices=[(0, 0), (2, 0), (2, 2), (0, 2)]))</span>

<span class="sd">        The replacement of a polygon must have the same number of sides::</span>

<span class="sd">            sage: S.replace_polygon(0, Polygon(vertices=[(0, 0), (2, 0), (2, 2)]))</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: polygon must be a quadrilateral</span>

<span class="sd">        To replace the polygon without keeping its glueings, remove the polygon</span>
<span class="sd">        first and then add a new one::</span>

<span class="sd">            sage: S.remove_polygon(0)</span>
<span class="sd">            sage: S.add_polygon(Polygon(vertices=[(0, 0), (2, 0), (2, 2)]), label=0)</span>
<span class="sd">            0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">vertices</span><span class="p">()):</span>
            <span class="kn">from</span> <span class="nn">flatsurf.geometry.categories.polygons</span> <span class="kn">import</span> <span class="n">Polygons</span>

            <span class="n">article</span><span class="p">,</span> <span class="n">singular</span><span class="p">,</span> <span class="n">plural</span> <span class="o">=</span> <span class="n">Polygons</span><span class="o">.</span><span class="n">_describe_polygon</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="o">.</span><span class="n">vertices</span><span class="p">()))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;polygon must be </span><span class="si">{</span><span class="n">article</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">singular</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">polygon</span></div>

<div class="viewcode-block" id="MutableOrientedSimilaritySurface.opposite_edge"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutableOrientedSimilaritySurface.opposite_edge">[docs]</a>    <span class="k">def</span> <span class="nf">opposite_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the edge that ``edge`` of ``label`` is glued to or ``None`` if this edge is unglued.</span>

<span class="sd">        This implements</span>
<span class="sd">        :meth:`flatsurf.geometry.categories.polygonal_surfaces.PolygonalSurfaces.ParentMethods.opposite_edge`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``label`` -- one of the labels included in :meth:`~.MutablePolygonalSurface.labels`</span>

<span class="sd">        - ``edge`` -- a non-negative integer to specify an edge (the edges</span>
<span class="sd">          of a polygon are numbered starting from zero.)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import Polygon, MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>
<span class="sd">            sage: S.add_polygon(Polygon(vertices=[(0, 0), (1, 0), (1, 1), (0, 1)]))</span>
<span class="sd">            0</span>

<span class="sd">            sage: S.glue((0, 0), (0, 1))</span>
<span class="sd">            sage: S.glue((0, 2), (0, 2))</span>

<span class="sd">            sage: S.opposite_edge(0, 0)</span>
<span class="sd">            (0, 1)</span>
<span class="sd">            sage: S.opposite_edge(0, 1)</span>
<span class="sd">            (0, 0)</span>
<span class="sd">            sage: S.opposite_edge(0, 2)</span>
<span class="sd">            (0, 2)</span>
<span class="sd">            sage: S.opposite_edge(0, 3)</span>

<span class="sd">            sage: S.opposite_edge((0, 0))</span>
<span class="sd">            doctest:warning</span>
<span class="sd">            ...</span>
<span class="sd">            UserWarning: calling opposite_edge() with a single argument has been deprecated and will be removed in a future version of sage-flatsurf; use opposite_edge(label, edge) instead</span>
<span class="sd">            (0, 1)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">edge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">warnings</span>

            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;calling opposite_edge() with a single argument has been deprecated and will be removed in a future version of sage-flatsurf; use opposite_edge(label, edge) instead&quot;</span>
            <span class="p">)</span>
            <span class="n">label</span><span class="p">,</span> <span class="n">edge</span> <span class="o">=</span> <span class="n">label</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gluings</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="n">edge</span><span class="p">]</span></div>

<div class="viewcode-block" id="MutableOrientedSimilaritySurface.set_vertex_zero"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutableOrientedSimilaritySurface.set_vertex_zero">[docs]</a>    <span class="k">def</span> <span class="nf">set_vertex_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overrides</span>
<span class="sd">        :meth:`flatsurf.geometry.categories.similarity_surfaces.SimilaritySurfaces.Oriented.ParentMethods.set_vertex_zero`</span>
<span class="sd">        to make it possible to set the zero vertex in-place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_vertex_zero</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="n">in_place</span><span class="p">)</span>

        <span class="n">us</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">us</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;set_vertex_zero can only be done in_place for a mutable surface.&quot;</span>
            <span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">us</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span>
        <span class="n">glue</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="kn">from</span> <span class="nn">flatsurf</span> <span class="kn">import</span> <span class="n">Polygon</span>

        <span class="n">pp</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span>
            <span class="n">edges</span><span class="o">=</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">edge</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)],</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">us</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span>
            <span class="n">ll</span><span class="p">,</span> <span class="n">ee</span> <span class="o">=</span> <span class="n">us</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ll</span> <span class="o">==</span> <span class="n">label</span><span class="p">:</span>
                <span class="n">ee</span> <span class="o">=</span> <span class="p">(</span><span class="n">ee</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="n">v</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span>
            <span class="n">glue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ll</span><span class="p">,</span> <span class="n">ee</span><span class="p">))</span>

        <span class="n">us</span><span class="o">.</span><span class="n">remove_polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="n">us</span><span class="o">.</span><span class="n">add_polygon</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">cross</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">glue</span><span class="p">):</span>
            <span class="n">us</span><span class="o">.</span><span class="n">glue</span><span class="p">((</span><span class="n">label</span><span class="p">,</span> <span class="n">e</span><span class="p">),</span> <span class="n">cross</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="MutableOrientedSimilaritySurface.relabel"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutableOrientedSimilaritySurface.relabel">[docs]</a>    <span class="k">def</span> <span class="nf">relabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">relabeling_map</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overrides</span>
<span class="sd">        :meth:`flatsurf.geometry.categories.similarity_surfaces.SimilaritySurfaces.Oriented.ParentMethods.relabel`</span>
<span class="sd">        to allow relabeling in-place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="n">relabeling_map</span><span class="o">=</span><span class="n">relabeling_map</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="n">in_place</span><span class="p">)</span>

        <span class="n">us</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">relabeling_map</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Currently relabeling is only implemented via a dictionary.&quot;</span>
            <span class="p">)</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">codomain</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span> <span class="ow">in</span> <span class="n">relabeling_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">us</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">l1</span><span class="p">)</span>
            <span class="n">glue</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">vertices</span><span class="p">())):</span>
                <span class="n">ll</span><span class="p">,</span> <span class="n">ee</span> <span class="o">=</span> <span class="n">us</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lll</span> <span class="o">=</span> <span class="n">relabeling_map</span><span class="p">[</span><span class="n">ll</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">lll</span> <span class="o">=</span> <span class="n">ll</span>
                <span class="n">glue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lll</span><span class="p">,</span> <span class="n">ee</span><span class="p">))</span>
            <span class="n">data</span><span class="p">[</span><span class="n">l2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">glue</span><span class="p">)</span>
            <span class="n">domain</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">l1</span><span class="p">)</span>
            <span class="n">codomain</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">l2</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">codomain</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The relabeling_map must be injective. Received &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">relabeling_map</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">changed_labels</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">codomain</span><span class="p">)</span>
        <span class="n">added_labels</span> <span class="o">=</span> <span class="n">codomain</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
        <span class="n">removed_labels</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">codomain</span><span class="p">)</span>
        <span class="c1"># Pass to add_polygons</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">us</span><span class="o">.</span><span class="n">roots</span><span class="p">())</span>
        <span class="n">relabel_errors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">l2</span> <span class="ow">in</span> <span class="n">added_labels</span><span class="p">:</span>
            <span class="n">p</span><span class="p">,</span> <span class="n">glue</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">l2</span><span class="p">]</span>
            <span class="n">l3</span> <span class="o">=</span> <span class="n">us</span><span class="o">.</span><span class="n">add_polygon</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">l2</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">l2</span> <span class="o">==</span> <span class="n">l3</span><span class="p">:</span>
                <span class="c1"># This means the label l2 could not be added for some reason.</span>
                <span class="c1"># Perhaps the implementation does not support this type of label.</span>
                <span class="c1"># Or perhaps there is already a polygon with this label.</span>
                <span class="n">relabel_errors</span><span class="p">[</span><span class="n">l2</span><span class="p">]</span> <span class="o">=</span> <span class="n">l3</span>
        <span class="c1"># Pass to change polygons</span>
        <span class="k">for</span> <span class="n">l2</span> <span class="ow">in</span> <span class="n">changed_labels</span><span class="p">:</span>
            <span class="n">p</span><span class="p">,</span> <span class="n">glue</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">l2</span><span class="p">]</span>
            <span class="n">us</span><span class="o">.</span><span class="n">remove_polygon</span><span class="p">(</span><span class="n">l2</span><span class="p">)</span>
            <span class="n">us</span><span class="o">.</span><span class="n">add_polygon</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">l2</span><span class="p">)</span>
            <span class="n">us</span><span class="o">.</span><span class="n">replace_polygon</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="c1"># Deal with the component roots</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="p">[</span><span class="n">relabeling_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">]</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="p">[</span><span class="n">relabel_errors</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">]</span>
        <span class="c1"># Pass to remove polygons:</span>
        <span class="k">for</span> <span class="n">l1</span> <span class="ow">in</span> <span class="n">removed_labels</span><span class="p">:</span>
            <span class="n">us</span><span class="o">.</span><span class="n">remove_polygon</span><span class="p">(</span><span class="n">l1</span><span class="p">)</span>
        <span class="c1"># Pass to update the edge gluings</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">relabel_errors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># No problems. Update the gluings.</span>
            <span class="k">for</span> <span class="n">l2</span> <span class="ow">in</span> <span class="n">codomain</span><span class="p">:</span>
                <span class="n">p</span><span class="p">,</span> <span class="n">glue</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">l2</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">cross</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">glue</span><span class="p">):</span>
                    <span class="n">us</span><span class="o">.</span><span class="n">glue</span><span class="p">((</span><span class="n">l2</span><span class="p">,</span> <span class="n">e</span><span class="p">),</span> <span class="n">cross</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use the gluings provided by relabel_errors when necessary</span>
            <span class="k">for</span> <span class="n">l2</span> <span class="ow">in</span> <span class="n">codomain</span><span class="p">:</span>
                <span class="n">p</span><span class="p">,</span> <span class="n">glue</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">l2</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">vertices</span><span class="p">())):</span>
                    <span class="n">ll</span><span class="p">,</span> <span class="n">ee</span> <span class="o">=</span> <span class="n">glue</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># First try the error dictionary</span>
                        <span class="n">us</span><span class="o">.</span><span class="n">glue</span><span class="p">((</span><span class="n">l2</span><span class="p">,</span> <span class="n">e</span><span class="p">),</span> <span class="p">(</span><span class="n">relabel_errors</span><span class="p">[</span><span class="n">ll</span><span class="p">],</span> <span class="n">ee</span><span class="p">))</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="n">us</span><span class="o">.</span><span class="n">glue</span><span class="p">((</span><span class="n">l2</span><span class="p">,</span> <span class="n">e</span><span class="p">),</span> <span class="p">(</span><span class="n">ll</span><span class="p">,</span> <span class="n">ee</span><span class="p">))</span>
        <span class="n">us</span><span class="o">.</span><span class="n">set_roots</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">relabel_errors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="MutableOrientedSimilaritySurface.join_polygons"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutableOrientedSimilaritySurface.join_polygons">[docs]</a>    <span class="k">def</span> <span class="nf">join_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">test</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overrides</span>
<span class="sd">        :meth:`flatsurf.geometry.categories.similarity_surfaces.SimilaritySurfaces.Oriented.ParentMethods.join_polygons`</span>
<span class="sd">        to allow joining in-place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">test</span><span class="p">:</span>
            <span class="n">in_place</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">join_polygon</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">test</span><span class="o">=</span><span class="n">test</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="n">in_place</span><span class="p">)</span>

        <span class="n">poly1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
        <span class="n">p2</span><span class="p">,</span> <span class="n">e2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">e1</span><span class="p">)</span>
        <span class="n">poly2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">p1</span> <span class="o">==</span> <span class="n">p2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t glue polygon to itself.&quot;</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_transformation</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">derivative</span><span class="p">()</span>
        <span class="n">es</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">edge_map</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Store the pairs for the old edges.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">e1</span><span class="p">):</span>
            <span class="n">edge_map</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">es</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">es</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="n">ne</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">poly2</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ne</span><span class="p">):</span>
            <span class="n">ee</span> <span class="o">=</span> <span class="p">(</span><span class="n">e2</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="n">ne</span>
            <span class="n">edge_map</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">es</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">ee</span><span class="p">)</span>
            <span class="n">es</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dt</span> <span class="o">*</span> <span class="n">poly2</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">ee</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">e1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">poly1</span><span class="o">.</span><span class="n">vertices</span><span class="p">())):</span>
            <span class="n">edge_map</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">es</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">es</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

        <span class="kn">from</span> <span class="nn">flatsurf</span> <span class="kn">import</span> <span class="n">Polygon</span>

        <span class="n">new_polygon</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">es</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">())</span>

        <span class="c1"># Do the gluing.</span>
        <span class="n">ss</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">ss</span>

        <span class="n">inv_edge_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">edge_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">inv_edge_map</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="n">glue_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">es</span><span class="p">)):</span>
            <span class="n">p3</span><span class="p">,</span> <span class="n">e3</span> <span class="o">=</span> <span class="n">edge_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">p4</span><span class="p">,</span> <span class="n">e4</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">p3</span><span class="p">,</span> <span class="n">e3</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">p4</span> <span class="o">==</span> <span class="n">p1</span> <span class="ow">or</span> <span class="n">p4</span> <span class="o">==</span> <span class="n">p2</span><span class="p">:</span>
                <span class="n">glue_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inv_edge_map</span><span class="p">[(</span><span class="n">p4</span><span class="p">,</span> <span class="n">e4</span><span class="p">)])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">glue_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">p4</span><span class="p">,</span> <span class="n">e4</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">p2</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">roots</span><span class="p">():</span>
            <span class="n">s</span><span class="o">.</span><span class="n">set_roots</span><span class="p">(</span><span class="n">p1</span> <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="n">p2</span> <span class="k">else</span> <span class="n">label</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">roots</span><span class="p">())</span>

        <span class="n">s</span><span class="o">.</span><span class="n">remove_polygon</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>

        <span class="n">s</span><span class="o">.</span><span class="n">remove_polygon</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
        <span class="n">s</span><span class="o">.</span><span class="n">add_polygon</span><span class="p">(</span><span class="n">new_polygon</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">p1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">cross</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">glue_list</span><span class="p">):</span>
            <span class="n">s</span><span class="o">.</span><span class="n">glue</span><span class="p">((</span><span class="n">p1</span><span class="p">,</span> <span class="n">e</span><span class="p">),</span> <span class="n">cross</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="MutableOrientedSimilaritySurface.subdivide_polygon"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutableOrientedSimilaritySurface.subdivide_polygon">[docs]</a>    <span class="k">def</span> <span class="nf">subdivide_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">test</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">new_label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overrides</span>
<span class="sd">        :meth:`flatsurf.geometry.categories.similarity_surfaces.SimilaritySurfaces.Oriented.ParentMethods.subdivide_polygon`</span>
<span class="sd">        to allow subdividing in-place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">test</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">subdivide_polygon</span><span class="p">(</span>
                <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">v1</span><span class="o">=</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="o">=</span><span class="n">v2</span><span class="p">,</span> <span class="n">test</span><span class="o">=</span><span class="n">test</span><span class="p">,</span> <span class="n">new_label</span><span class="o">=</span><span class="n">new_label</span>
            <span class="p">)</span>

        <span class="n">poly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">ne</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">v1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">v2</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">v1</span> <span class="o">&gt;=</span> <span class="n">ne</span> <span class="ow">or</span> <span class="n">v2</span> <span class="o">&gt;=</span> <span class="n">ne</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Provided vertices out of bounds.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">v1</span> <span class="o">-</span> <span class="n">v2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">v1</span> <span class="o">-</span> <span class="n">v2</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">ne</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Provided diagonal is not actually a diagonal.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">v2</span> <span class="o">&lt;</span> <span class="n">v1</span><span class="p">:</span>
            <span class="n">v2</span> <span class="o">=</span> <span class="n">v2</span> <span class="o">+</span> <span class="n">ne</span>

        <span class="n">newedges1</span> <span class="o">=</span> <span class="p">[</span><span class="n">poly</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span> <span class="o">-</span> <span class="n">poly</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">v1</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">ne</span><span class="p">):</span>
            <span class="n">newedges1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

        <span class="kn">from</span> <span class="nn">flatsurf</span> <span class="kn">import</span> <span class="n">Polygon</span>

        <span class="n">newpoly1</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">newedges1</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">())</span>

        <span class="n">newedges2</span> <span class="o">=</span> <span class="p">[</span><span class="n">poly</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="o">-</span> <span class="n">poly</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">v2</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
            <span class="n">newedges2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="n">newpoly2</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">newedges2</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">())</span>

        <span class="c1"># Store the old gluings</span>
        <span class="n">old_gluings</span> <span class="o">=</span> <span class="p">{(</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ne</span><span class="p">)}</span>

        <span class="c1"># Update the polygon with label p, add a new polygon.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_polygon</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_polygon</span><span class="p">(</span><span class="n">newpoly1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_polygon</span><span class="p">(</span><span class="n">newpoly2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_polygon</span><span class="p">(</span><span class="n">newpoly2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">new_label</span><span class="p">)</span>
        <span class="c1"># This gluing is the diagonal we used.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">glue</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">new_label</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="c1"># Setup conversion from old to new labels.</span>
        <span class="n">old_to_new_labels</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
            <span class="n">old_to_new_labels</span><span class="p">[(</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span> <span class="o">%</span> <span class="n">ne</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_label</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">v1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">ne</span> <span class="o">+</span> <span class="n">v1</span><span class="p">):</span>
            <span class="n">old_to_new_labels</span><span class="p">[(</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span> <span class="o">%</span> <span class="n">ne</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">v2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">newpoly1</span><span class="o">.</span><span class="n">vertices</span><span class="p">())):</span>
            <span class="n">pair</span> <span class="o">=</span> <span class="n">old_gluings</span><span class="p">[(</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="n">v2</span> <span class="o">+</span> <span class="n">e</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">ne</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">old_to_new_labels</span><span class="p">:</span>
                <span class="n">pair</span> <span class="o">=</span> <span class="n">old_to_new_labels</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">glue</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">),</span> <span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">newpoly2</span><span class="o">.</span><span class="n">vertices</span><span class="p">())):</span>
            <span class="n">pair</span> <span class="o">=</span> <span class="n">old_gluings</span><span class="p">[(</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="n">v1</span> <span class="o">+</span> <span class="n">e</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">ne</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">old_to_new_labels</span><span class="p">:</span>
                <span class="n">pair</span> <span class="o">=</span> <span class="n">old_to_new_labels</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">glue</span><span class="p">((</span><span class="n">new_label</span><span class="p">,</span> <span class="n">e</span><span class="p">),</span> <span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span></div>

<div class="viewcode-block" id="MutableOrientedSimilaritySurface.reposition_polygons"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutableOrientedSimilaritySurface.reposition_polygons">[docs]</a>    <span class="k">def</span> <span class="nf">reposition_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">relabel</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overrides</span>
<span class="sd">        :meth:`flatsurf.geometry.categories.similarity_surfaces.SimilaritySurfaces.FiniteType.Oriented.ParentMethods.reposition_polygons`</span>
<span class="sd">        to allow normalizing in-place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">reposition_polygons</span><span class="p">(</span><span class="n">in_place</span><span class="o">=</span><span class="n">in_place</span><span class="p">,</span> <span class="n">relabel</span><span class="o">=</span><span class="n">relabel</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">relabel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">relabel</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;the relabel keyword has been removed from reposition_polygon; use relabel({old: new for (new, old) in enumerate(surface.labels())}) to use integer labels instead&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">warnings</span>

                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;the relabel keyword will be removed in a future version of sage-flatsurf; do not pass it explicitly anymore to reposition_polygons()&quot;</span>
                <span class="p">)</span>

        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">labels</span><span class="p">())</span>
        <span class="kn">from</span> <span class="nn">flatsurf.geometry.similarity</span> <span class="kn">import</span> <span class="n">SimilarityGroup</span>

        <span class="n">S</span> <span class="o">=</span> <span class="n">SimilarityGroup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">())</span>
        <span class="n">identity</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
        <span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="n">label</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
        <span class="n">changes</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="n">identity</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
            <span class="n">polygon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="n">adjacencies</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">edge</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">edge</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">vertices</span><span class="p">()))</span>
            <span class="p">}</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">adjacencies</span><span class="p">,</span>
                <span class="c1"># pylint: disable-next=cell-var-from-loop</span>
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">edge</span><span class="p">:</span> <span class="n">labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">adjacencies</span><span class="p">[</span><span class="n">edge</span><span class="p">]),</span>
            <span class="p">)</span>
            <span class="n">label2</span><span class="p">,</span> <span class="n">edge2</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span>
            <span class="n">changes</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">changes</span><span class="p">[</span><span class="n">label2</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span><span class="o">.</span><span class="n">edge_transformation</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span>
        <span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="c1"># Skip the base label:</span>
        <span class="n">label</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">changes</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">derivative</span><span class="p">()</span> <span class="o">*</span> <span class="n">p</span>
            <span class="n">s</span><span class="o">.</span><span class="n">replace_polygon</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="MutableOrientedSimilaritySurface.triangulate"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutableOrientedSimilaritySurface.triangulate">[docs]</a>    <span class="k">def</span> <span class="nf">triangulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">relabel</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overrides</span>
<span class="sd">        :meth:`flatsurf.geometry.categories.similarity_surfaces.SimilaritySurfaces.Oriented.ParentMethods.triangulate`</span>
<span class="sd">        to allow triangulating in-place.</span>

<span class="sd">        .. TODO::</span>

<span class="sd">            The code here is not using</span>
<span class="sd">            :meth:`~.categories.euclidean_polygons.EuclideanPolygons.Simple.ParentMethods.triangulation`.</span>
<span class="sd">            It should probably be rewritten to share the same logic.</span>

<span class="sd">        TESTS:</span>

<span class="sd">        Verify that the monotile can be triangulated::</span>

<span class="sd">            sage: from flatsurf import Polygon, MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: K = QuadraticField(3)</span>
<span class="sd">            sage: a = K.gen()</span>
<span class="sd">            sage: # build the vectors</span>
<span class="sd">            sage: l = [(1, 0), (1, 2), (a, 11), (a, 1), (1, 4), (1, 6), (a, 3),</span>
<span class="sd">            ....:      (a, 5), (1, 8), (1, 6), (a, 9), (a, 7), (1, 10), (1, 0)]</span>
<span class="sd">            sage: vecs = []</span>
<span class="sd">            sage: for m, e in l:</span>
<span class="sd">            ....:     v = vector(K, [m * cos(2*pi*e/12), m * sin(2*pi*e/12)])</span>
<span class="sd">            ....:     vecs.append(v)</span>
<span class="sd">            sage: p = Polygon(edges=vecs)</span>

<span class="sd">            sage: from collections import defaultdict</span>
<span class="sd">            sage: d = defaultdict(list)</span>
<span class="sd">            sage: for i, e in enumerate(p.edges()):</span>
<span class="sd">            ....:     e.set_immutable()</span>
<span class="sd">            ....:     d[e].append(i)</span>

<span class="sd">            sage: Sbase = MutableOrientedSimilaritySurface(K)</span>
<span class="sd">            sage: _ = Sbase.add_polygon(p)</span>
<span class="sd">            sage: for v in list(d):</span>
<span class="sd">            ....:     if v in d:</span>
<span class="sd">            ....:         indices = d[v]</span>
<span class="sd">            ....:         v_op = -v</span>
<span class="sd">            ....:         v_op.set_immutable()</span>
<span class="sd">            ....:         opposite_indices = d[v_op]</span>
<span class="sd">            ....:         assert len(indices) == len(opposite_indices), (len(indices), len(opposite_indices))</span>
<span class="sd">            ....:         if len(indices) == 1:</span>
<span class="sd">            ....:             del d[v]</span>
<span class="sd">            ....:             del d[v_op]</span>
<span class="sd">            ....:             Sbase.glue((0, indices[0]), (0, opposite_indices[0]))</span>

<span class="sd">            sage: (i0, j0), (i1, j1) = d.values()</span>

<span class="sd">            sage: S1 = MutableOrientedSimilaritySurface.from_surface(Sbase)</span>
<span class="sd">            sage: S1.glue((0, i0), (0, i1))</span>
<span class="sd">            sage: S1.glue((0, j0), (0, j1))</span>
<span class="sd">            sage: S1.set_immutable()</span>

<span class="sd">            sage: S1.triangulate()</span>
<span class="sd">            Translation Surface in H_3(4, 0) built from 5 isosceles triangles, 6 triangles and a right triangle</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">relabel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">warnings</span>

            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;the relabel keyword argument of triangulate() is ignored, it has been deprecated and will be removed in a future version of sage-flatsurf&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">triangulate</span><span class="p">(</span><span class="n">in_place</span><span class="o">=</span><span class="n">in_place</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># We triangulate the whole surface</span>
            <span class="c1"># Store the current labels.</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">())</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="c1"># Subdivide each polygon in turn.</span>
            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">triangulate</span><span class="p">(</span><span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">s</span>

        <span class="n">poly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This polygon is already a triangle.</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="kn">from</span> <span class="nn">flatsurf.geometry.euclidean</span> <span class="kn">import</span> <span class="n">ccw</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">3</span><span class="p">):</span>
            <span class="n">poly</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">e1</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">e2</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">edge</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ccw</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># This is in case the polygon is a triangle with subdivided edge.</span>
                    <span class="n">e3</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">edge</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ccw</span><span class="p">(</span><span class="n">e1</span> <span class="o">+</span> <span class="n">e2</span><span class="p">,</span> <span class="n">e3</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">s</span><span class="o">.</span><span class="n">subdivide_polygon</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
                        <span class="k">break</span>
        <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="MutableOrientedSimilaritySurface.delaunay_single_flip"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutableOrientedSimilaritySurface.delaunay_single_flip">[docs]</a>    <span class="k">def</span> <span class="nf">delaunay_single_flip</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform a single in place flip of a triangulated mutable surface</span>
<span class="sd">        in-place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label_comparator</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">e1</span><span class="p">),</span> <span class="p">(</span><span class="n">l2</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gluings</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">lc</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">l1</span> <span class="o">==</span> <span class="n">l2</span> <span class="ow">and</span> <span class="n">e1</span> <span class="o">&lt;=</span> <span class="n">e2</span><span class="p">)</span>
            <span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delaunay_edge_needs_flip</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">e1</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">triangle_flip</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="MutableOrientedSimilaritySurface.delaunay_triangulation"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutableOrientedSimilaritySurface.delaunay_triangulation">[docs]</a>    <span class="k">def</span> <span class="nf">delaunay_triangulation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">triangulated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">in_place</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">direction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">relabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overrides</span>
<span class="sd">        :meth:`flatsurf.geometry.categories.similarity_surfaces.SimilaritySurfaces.Oriented.ParentMethods.delaunay_triangulation`</span>
<span class="sd">        to allow triangulating in-place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">delaunay_triangulation</span><span class="p">(</span>
                <span class="n">triangulated</span><span class="o">=</span><span class="n">triangulated</span><span class="p">,</span>
                <span class="n">in_place</span><span class="o">=</span><span class="n">in_place</span><span class="p">,</span>
                <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span>
                <span class="n">relabel</span><span class="o">=</span><span class="n">relabel</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">relabel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">relabel</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;the relabel keyword has been removed from delaunay_triangulation(); use relabel({old: new for (new, old) in enumerate(surface.labels())}) to use integer labels instead&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">warnings</span>

                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;the relabel keyword will be removed in a future version of sage-flatsurf; do not pass it explicitly anymore to delaunay_triangulation()&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">triangulated</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">triangulate</span><span class="p">(</span><span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">direction</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">direction</span><span class="o">.</span><span class="n">is_zero</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span>

        <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

        <span class="n">unchecked_labels</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">labels</span><span class="p">())</span>
        <span class="n">checked_labels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">unchecked_labels</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">unchecked_labels</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="n">flipped</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">_delaunay_edge_needs_flip</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
                    <span class="c1"># Record the current opposite edge:</span>
                    <span class="n">label2</span><span class="p">,</span> <span class="n">edge2</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span>
                    <span class="c1"># Perform the flip.</span>
                    <span class="n">s</span><span class="o">.</span><span class="n">triangle_flip</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">)</span>
                    <span class="c1"># Move the opposite polygon to the list of labels we need to check.</span>
                    <span class="k">if</span> <span class="n">label2</span> <span class="o">!=</span> <span class="n">label</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">checked_labels</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">label2</span><span class="p">)</span>
                            <span class="n">unchecked_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label2</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                            <span class="c1"># Occurs if label2 is not in checked_labels</span>
                            <span class="k">pass</span>
                    <span class="n">flipped</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">flipped</span><span class="p">:</span>
                <span class="n">unchecked_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">checked_labels</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="MutableOrientedSimilaritySurface.delaunay_decomposition"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutableOrientedSimilaritySurface.delaunay_decomposition">[docs]</a>    <span class="k">def</span> <span class="nf">delaunay_decomposition</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">triangulated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">delaunay_triangulated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">in_place</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">direction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">relabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overrides</span>
<span class="sd">        :meth:`flatsurf.geometry.categories.similarity_surfaces.SimilaritySurfaces.Oriented.ParentMethods.delaunay_decomposition`</span>
<span class="sd">        to allow normalizing in-place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">delaunay_decomposition</span><span class="p">(</span>
                <span class="n">triangulated</span><span class="o">=</span><span class="n">triangulated</span><span class="p">,</span>
                <span class="n">delaunay_triangulated</span><span class="o">=</span><span class="n">delaunay_triangulated</span><span class="p">,</span>
                <span class="n">in_place</span><span class="o">=</span><span class="n">in_place</span><span class="p">,</span>
                <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span>
                <span class="n">relabel</span><span class="o">=</span><span class="n">relabel</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">relabel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">relabel</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;the relabel keyword has been removed from delaunay_decomposition(); use relabel({old: new for (new, old) in enumerate(surface.labels())}) to use integer labels instead&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">warnings</span>

                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;the relabel keyword will be removed in a future version of sage-flatsurf; do not pass it explicitly anymore to delaunay_decomposition()&quot;</span>
                <span class="p">)</span>

        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">delaunay_triangulated</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">delaunay_triangulation</span><span class="p">(</span>
                <span class="n">triangulated</span><span class="o">=</span><span class="n">triangulated</span><span class="p">,</span>
                <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span>
                <span class="n">relabel</span><span class="o">=</span><span class="n">relabel</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">e1</span><span class="p">),</span> <span class="p">(</span><span class="n">l2</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">gluings</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">_delaunay_edge_needs_join</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">e1</span><span class="p">):</span>
                    <span class="n">s</span><span class="o">.</span><span class="n">join_polygons</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="MutableOrientedSimilaritySurface.cmp"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutableOrientedSimilaritySurface.cmp">[docs]</a>    <span class="k">def</span> <span class="nf">cmp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compare two surfaces. This is an ordering returning -1, 0, or 1.</span>

<span class="sd">        The surfaces will be considered equal if and only if there is a translation automorphism</span>
<span class="sd">        respecting the polygons and the root labels.</span>

<span class="sd">        If the two surfaces are infinite, we just examine the first limit polygons.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite_type</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">s2</span><span class="o">.</span><span class="n">is_finite_type</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;limit only enabled for finite surfaces&quot;</span><span class="p">)</span>

                <span class="n">sign</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">())</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="o">.</span><span class="n">polygons</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">sign</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">sign</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

                <span class="n">lw1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">()</span>
                <span class="n">labels1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lw1</span><span class="p">)</span>

                <span class="n">lw2</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="n">labels</span><span class="p">()</span>
                <span class="n">labels2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lw2</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lw1</span><span class="p">,</span> <span class="n">lw2</span><span class="p">):</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">l1</span><span class="p">)</span><span class="o">.</span><span class="n">cmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">l2</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">ret</span>

                    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">l1</span><span class="p">)</span><span class="o">.</span><span class="n">vertices</span><span class="p">())):</span>
                        <span class="n">ll1</span><span class="p">,</span> <span class="n">e1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                        <span class="n">ll2</span><span class="p">,</span> <span class="n">e2</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                        <span class="n">num1</span> <span class="o">=</span> <span class="n">labels1</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ll1</span><span class="p">)</span>
                        <span class="n">num2</span> <span class="o">=</span> <span class="n">labels2</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ll2</span><span class="p">)</span>

                        <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">num1</span> <span class="o">&gt;</span> <span class="n">num2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">num1</span> <span class="o">&lt;</span> <span class="n">num2</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">ret</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">ret</span>
                        <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">e1</span> <span class="o">&gt;</span> <span class="n">e2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">e1</span> <span class="o">&lt;</span> <span class="n">e2</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">ret</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">ret</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># s1 is finite but s2 is infinite.</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s2</span><span class="o">.</span><span class="n">is_finite_type</span><span class="p">():</span>
                <span class="c1"># s1 is infinite but s2 is finite.</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span>

                <span class="c1"># both surfaces are infinite.</span>
                <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span>

                <span class="n">lw1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">()</span>
                <span class="n">labels1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">lw1</span><span class="p">,</span> <span class="n">limit</span><span class="p">))</span>

                <span class="n">lw2</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="n">labels</span><span class="p">()</span>
                <span class="n">labels2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">lw2</span><span class="p">,</span> <span class="n">limit</span><span class="p">))</span>

                <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lw1</span><span class="p">,</span> <span class="n">lw2</span><span class="p">):</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">l1</span><span class="p">)</span><span class="o">.</span><span class="n">cmp</span><span class="p">(</span><span class="n">s2</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">l2</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">ret</span>

                    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">l1</span><span class="p">)</span><span class="o">.</span><span class="n">vertices</span><span class="p">())):</span>
                        <span class="n">ll1</span><span class="p">,</span> <span class="n">ee1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                        <span class="n">ll2</span><span class="p">,</span> <span class="n">ee2</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                        <span class="n">num1</span> <span class="o">=</span> <span class="n">labels1</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ll1</span><span class="p">)</span>
                        <span class="n">num2</span> <span class="o">=</span> <span class="n">labels2</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ll2</span><span class="p">)</span>
                        <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">num1</span> <span class="o">&gt;</span> <span class="n">num2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">num1</span> <span class="o">&lt;</span> <span class="n">num2</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">ret</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">ret</span>
                        <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">ee1</span> <span class="o">&gt;</span> <span class="n">ee2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">ee1</span> <span class="o">&lt;</span> <span class="n">ee2</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">ret</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">ret</span>
                    <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="n">limit</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="MutableOrientedSimilaritySurface.__eq__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutableOrientedSimilaritySurface.__eq__">[docs]</a>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this surface is indistinguishable from ``other``.</span>

<span class="sd">        See</span>
<span class="sd">        :meth:`~.categories.similarity_surfaces.SimilaritySurfaces.FiniteType.ParentMethods._test_eq_surface`</span>
<span class="sd">        for details on this notion of equality.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface</span>

<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>
<span class="sd">            sage: T = MutableOrientedSimilaritySurface(AA)</span>

<span class="sd">            sage: S == T</span>
<span class="sd">            False</span>

<span class="sd">            sage: S == S</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MutableOrientedSimilaritySurface</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gluings</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_gluings</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="MutableOrientedSimilaritySurface.__hash__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.MutableOrientedSimilaritySurface.__hash__">[docs]</a>    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a hash value for this surface that is compatible with</span>
<span class="sd">        :meth:`__eq__`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface</span>

<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>
<span class="sd">            sage: T = MutableOrientedSimilaritySurface(QQ)</span>

<span class="sd">            sage: hash(S) == hash(T)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            TypeError: cannot hash a mutable surface</span>

<span class="sd">            sage: S.set_immutable()</span>
<span class="sd">            sage: T.set_immutable()</span>
<span class="sd">            sage: hash(S) == hash(T)</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mutable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot hash a mutable surface&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(),</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gluings</span><span class="p">())))</span></div></div>


<div class="viewcode-block" id="BaseRingChangedSurface"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.BaseRingChangedSurface">[docs]</a><span class="k">class</span> <span class="nc">BaseRingChangedSurface</span><span class="p">(</span><span class="n">OrientedSimilaritySurface</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Changes the ring over which a surface is defined.</span>

<span class="sd">    EXAMPLES:</span>

<span class="sd">    This class is used in the implementation of</span>
<span class="sd">    :meth:`flatsurf.geometry.categories.similarity_surfaces.SimilaritySurfaces.Oriented.ParentMethods.change_ring`::</span>

<span class="sd">        sage: from flatsurf import translation_surfaces</span>
<span class="sd">        sage: T = translation_surfaces.square_torus()</span>
<span class="sd">        sage: S = T.change_ring(AA)</span>

<span class="sd">        sage: from flatsurf.geometry.surface import BaseRingChangedSurface</span>
<span class="sd">        sage: isinstance(S, BaseRingChangedSurface)</span>
<span class="sd">        True</span>

<span class="sd">        sage: TestSuite(S).run()</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="BaseRingChangedSurface.__init__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.BaseRingChangedSurface.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">surface</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;surface must be immutable&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_reference</span> <span class="o">=</span> <span class="n">surface</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">category</span> <span class="ow">or</span> <span class="n">surface</span><span class="o">.</span><span class="n">category</span><span class="p">())</span></div>

<div class="viewcode-block" id="BaseRingChangedSurface.is_mutable"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.BaseRingChangedSurface.is_mutable">[docs]</a>    <span class="k">def</span> <span class="nf">is_mutable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this surface can be modified, i.e., return ``False``.</span>

<span class="sd">        This implements</span>
<span class="sd">        :meth:`flatsurf.geometry.categories.topological_surfaces.TopologicalSurfaces.ParentMethods.is_mutable`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import translation_surfaces</span>
<span class="sd">            sage: T = translation_surfaces.square_torus()</span>
<span class="sd">            sage: S = T.change_ring(AA)</span>

<span class="sd">            sage: S.is_mutable()</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="BaseRingChangedSurface.labels"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.BaseRingChangedSurface.labels">[docs]</a>    <span class="k">def</span> <span class="nf">labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the labels of the polygons of this surface.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import translation_surfaces</span>
<span class="sd">            sage: T = translation_surfaces.square_torus()</span>
<span class="sd">            sage: S = T.change_ring(AA)</span>
<span class="sd">            sage: S.labels()</span>
<span class="sd">            (0,)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference</span><span class="o">.</span><span class="n">labels</span><span class="p">()</span></div>

<div class="viewcode-block" id="BaseRingChangedSurface.roots"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.BaseRingChangedSurface.roots">[docs]</a>    <span class="k">def</span> <span class="nf">roots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a label for each connected component on this surface.</span>

<span class="sd">        This implements :meth:`flatsurf.geometry.categories.polygonal_surfaces.PolygonalSurfaces.ParentMethods.roots`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import translation_surfaces</span>
<span class="sd">            sage: T = translation_surfaces.square_torus()</span>
<span class="sd">            sage: S = T.change_ring(AA)</span>

<span class="sd">            sage: S.roots()</span>
<span class="sd">            (0,)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference</span><span class="o">.</span><span class="n">roots</span><span class="p">()</span></div>

<div class="viewcode-block" id="BaseRingChangedSurface.polygon"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.BaseRingChangedSurface.polygon">[docs]</a>    <span class="k">def</span> <span class="nf">polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the polygon with ``label``.</span>

<span class="sd">        This implements</span>
<span class="sd">        :meth:`flatsurf.geometry.categories.polygonal_surfaces.PolygonalSurfaces.ParentMethods.polygon`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import translation_surfaces</span>
<span class="sd">            sage: T = translation_surfaces.square_torus()</span>
<span class="sd">            sage: S = T.change_ring(AA)</span>

<span class="sd">            sage: p = S.polygon(0)</span>
<span class="sd">            sage: p.base_ring()</span>
<span class="sd">            Algebraic Real Field</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">())</span></div>

<div class="viewcode-block" id="BaseRingChangedSurface.opposite_edge"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.BaseRingChangedSurface.opposite_edge">[docs]</a>    <span class="k">def</span> <span class="nf">opposite_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the edge that ``edge`` of ``label`` is glued to or ``None`` if this edge is unglued.</span>

<span class="sd">        This implements</span>
<span class="sd">        :meth:`flatsurf.geometry.categories.polygonal_surfaces.PolygonalSurfaces.ParentMethods.opposite_edge`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import translation_surfaces</span>
<span class="sd">            sage: T = translation_surfaces.square_torus()</span>
<span class="sd">            sage: S = T.change_ring(AA)</span>

<span class="sd">            sage: S.opposite_edge(0, 0)</span>
<span class="sd">            (0, 2)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseRingChangedSurface.__eq__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.BaseRingChangedSurface.__eq__">[docs]</a>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this surface is indistinguishable from ``other``.</span>

<span class="sd">        See</span>
<span class="sd">        :meth:`~.categories.similarity_surfaces.SimilaritySurfaces.FiniteType.ParentMethods._test_eq_surface`</span>
<span class="sd">        for details on this notion of equality.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import translation_surfaces</span>
<span class="sd">            sage: T = translation_surfaces.square_torus()</span>
<span class="sd">            sage: T.change_ring(AA) == T.change_ring(AA)</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BaseRingChangedSurface</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_reference</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">base</span><span class="p">()</span></div>

<div class="viewcode-block" id="BaseRingChangedSurface.__hash__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.BaseRingChangedSurface.__hash__">[docs]</a>    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a hash value for this surface that is compatible with</span>
<span class="sd">        :meth:`__eq__`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import translation_surfaces</span>
<span class="sd">            sage: T = translation_surfaces.square_torus()</span>
<span class="sd">            sage: hash(T.change_ring(AA)) == hash(T.change_ring(AA))</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_reference</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">()))</span></div></div>


<div class="viewcode-block" id="RootedComponents_MutablePolygonalSurface"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.RootedComponents_MutablePolygonalSurface">[docs]</a><span class="k">class</span> <span class="nc">RootedComponents_MutablePolygonalSurface</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Mapping</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Connected components of a :class:`MutablePolygonalSurface`.</span>

<span class="sd">    The components are represented as a mapping that maps the root labels to</span>
<span class="sd">    the labels of the corresponding component.</span>

<span class="sd">    This is a helper method for :meth:`MutablePolygonalSurface.components` and</span>
<span class="sd">    :meth:`MutablePolygonalSurface.roots`.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import MutableOrientedSimilaritySurface</span>
<span class="sd">        sage: S = MutableOrientedSimilaritySurface(QQ)</span>

<span class="sd">        sage: from flatsurf import polygons</span>
<span class="sd">        sage: S.add_polygon(polygons.square())</span>
<span class="sd">        0</span>
<span class="sd">        sage: S.add_polygon(polygons.square())</span>
<span class="sd">        1</span>

<span class="sd">        sage: from flatsurf.geometry.surface import RootedComponents_MutablePolygonalSurface</span>
<span class="sd">        sage: components = RootedComponents_MutablePolygonalSurface(S)</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RootedComponents_MutablePolygonalSurface.__init__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.RootedComponents_MutablePolygonalSurface.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surface</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_surface</span> <span class="o">=</span> <span class="n">surface</span></div>

<div class="viewcode-block" id="RootedComponents_MutablePolygonalSurface.__getitem__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.RootedComponents_MutablePolygonalSurface.__getitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the labels of the connected component rooted at the label</span>
<span class="sd">        ``root``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            0</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            1</span>
<span class="sd">            sage: S.glue((0, 0), (1, 0))</span>

<span class="sd">            sage: from flatsurf.geometry.surface import RootedComponents_MutablePolygonalSurface</span>
<span class="sd">            sage: components = RootedComponents_MutablePolygonalSurface(S)</span>
<span class="sd">            sage: components[0]</span>
<span class="sd">            (0, 1)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_surface</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">root</span><span class="p">)</span></div>

<div class="viewcode-block" id="RootedComponents_MutablePolygonalSurface.__iter__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.RootedComponents_MutablePolygonalSurface.__iter__">[docs]</a>    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over the keys of this mapping, i.e., the root labels of the</span>
<span class="sd">        connected components.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            0</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            1</span>
<span class="sd">            sage: S.glue((0, 0), (1, 0))</span>

<span class="sd">            sage: from flatsurf.geometry.surface import RootedComponents_MutablePolygonalSurface</span>
<span class="sd">            sage: components = RootedComponents_MutablePolygonalSurface(S)</span>
<span class="sd">            sage: list(components)</span>
<span class="sd">            [0]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Shortcut enumeration if this is known to be a connected surface.</span>
        <span class="n">connected</span> <span class="o">=</span> <span class="s2">&quot;Connected&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_surface</span><span class="o">.</span><span class="n">category</span><span class="p">()</span><span class="o">.</span><span class="n">axioms</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_surface</span><span class="o">.</span><span class="n">_roots</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">root</span>
            <span class="k">if</span> <span class="n">connected</span><span class="p">:</span>
                <span class="k">return</span>

        <span class="n">labels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_surface</span><span class="o">.</span><span class="n">_polygons</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_surface</span><span class="o">.</span><span class="n">_roots</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_surface</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">labels</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">LabeledView</span><span class="p">(</span><span class="n">surface</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_surface</span><span class="p">,</span> <span class="n">view</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">finite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

            <span class="k">yield</span> <span class="n">root</span>
            <span class="k">if</span> <span class="n">connected</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_surface</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">label</span><span class="p">)</span></div>

<div class="viewcode-block" id="RootedComponents_MutablePolygonalSurface.__len__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.RootedComponents_MutablePolygonalSurface.__len__">[docs]</a>    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of connected components of this surface.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import MutableOrientedSimilaritySurface</span>
<span class="sd">            sage: S = MutableOrientedSimilaritySurface(QQ)</span>

<span class="sd">            sage: from flatsurf import polygons</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            0</span>
<span class="sd">            sage: S.add_polygon(polygons.square())</span>
<span class="sd">            1</span>
<span class="sd">            sage: S.glue((0, 0), (1, 0))</span>

<span class="sd">            sage: from flatsurf.geometry.surface import RootedComponents_MutablePolygonalSurface</span>
<span class="sd">            sage: components = RootedComponents_MutablePolygonalSurface(S)</span>
<span class="sd">            sage: len(components)</span>
<span class="sd">            1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">components</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">components</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">components</span></div></div>


<div class="viewcode-block" id="LabeledCollection"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.LabeledCollection">[docs]</a><span class="k">class</span> <span class="nc">LabeledCollection</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class for collection of labels as returned by ``labels()``</span>
<span class="sd">    methods of surfaces.</span>

<span class="sd">    This also serves as a base clas for things such as ``polygons()`` that are</span>
<span class="sd">    tied to labels.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``surface`` -- a polygonal surface, the labels are taken from that</span>
<span class="sd">      surface; subclasses might change this to only represent a subset of the</span>
<span class="sd">      labels of this surface</span>

<span class="sd">    - ``finite`` -- a boolean or ``None`` (default: ``None``); whether this is</span>
<span class="sd">      a finite set; if ``None``, it is not known whether the set is finite</span>
<span class="sd">      (some operations might not be supported in that case or not terminate if</span>
<span class="sd">      the set is actually infinite.)</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import translation_surfaces</span>
<span class="sd">        sage: S = translation_surfaces.square_torus()</span>
<span class="sd">        sage: labels = S.labels()</span>

<span class="sd">        sage: from flatsurf.geometry.surface import LabeledCollection</span>
<span class="sd">        sage: isinstance(labels, LabeledCollection)</span>
<span class="sd">        True</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LabeledCollection.__init__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.LabeledCollection.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="n">finite</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">finite</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">surface</span><span class="o">.</span><span class="n">is_finite_type</span><span class="p">():</span>
            <span class="n">finite</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_surface</span> <span class="o">=</span> <span class="n">surface</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finite</span> <span class="o">=</span> <span class="n">finite</span></div>

<div class="viewcode-block" id="LabeledCollection.__repr__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.LabeledCollection.__repr__">[docs]</a>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a printable representation of this set.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import translation_surfaces</span>
<span class="sd">            sage: S = translation_surfaces.square_torus()</span>
<span class="sd">            sage: S.labels()</span>
<span class="sd">            (0,)</span>

<span class="sd">            sage: S = translation_surfaces.infinite_staircase()</span>
<span class="sd">            sage: S.labels()</span>
<span class="sd">            (0, 1, -1, 2, -2, 3, -3, 4, -4, 5, -5, 6, -6, 7, -7, 8, …)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span>

        <span class="n">items</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="mi">17</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finite</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">17</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">islice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">))</span><span class="si">}</span><span class="s2">, …)&quot;</span></div>

<div class="viewcode-block" id="LabeledCollection.__len__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.LabeledCollection.__len__">[docs]</a>    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the size of this set.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import translation_surfaces</span>
<span class="sd">            sage: S = translation_surfaces.square_torus()</span>
<span class="sd">            sage: len(S.labels())</span>
<span class="sd">            1</span>

<span class="sd">        Python does not allow ``__len__`` to return anything but an integer, so</span>
<span class="sd">        we cannot return infinity::</span>

<span class="sd">            sage: S = translation_surfaces.infinite_staircase()</span>
<span class="sd">            sage: len(S.labels())</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            NotImplementedError: len() of an infinite set</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finite</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;infinite set has no integer length&quot;</span><span class="p">)</span>

        <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>  <span class="c1"># pylint: disable=not-an-iterable</span>
            <span class="n">length</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">length</span></div>

<div class="viewcode-block" id="LabeledCollection.__contains__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.LabeledCollection.__contains__">[docs]</a>    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether ``x`` is contained in this set.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import translation_surfaces</span>
<span class="sd">            sage: S = translation_surfaces.square_torus()</span>
<span class="sd">            sage: labels = S.labels()</span>
<span class="sd">            sage: 0 in labels</span>
<span class="sd">            True</span>
<span class="sd">            sage: 1 in labels</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>  <span class="c1"># pylint: disable=not-an-iterable</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">item</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span></div></div>


<div class="viewcode-block" id="LabeledView"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.LabeledView">[docs]</a><span class="k">class</span> <span class="nc">LabeledView</span><span class="p">(</span><span class="n">LabeledCollection</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A set of labels (or something resembling labels such as ``polygons()``)</span>
<span class="sd">    backed by another collection ``view``.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``surface`` -- a polygonal surface, the labels in ``view`` are labels of</span>
<span class="sd">      that surface</span>

<span class="sd">    - ``view`` -- a collection that all queries are going to be redirected to.</span>
<span class="sd">      Note that ``labels()`` guarantees that iteration over labels happens in a</span>
<span class="sd">      breadth-first-search so iteration over ``view`` must follow that same</span>
<span class="sd">      order. However, subclasses can remove this requirement by overriding</span>
<span class="sd">      :meth:`__iter__`.</span>

<span class="sd">    - ``finite`` -- a boolean or ``None`` (default: ``None``); whether this is</span>
<span class="sd">      a finite set; if ``None``, it is not known whether the set is finite</span>
<span class="sd">      (some operations might not be supported in that case or not terminate if</span>
<span class="sd">      the set is actually infinite.)</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import translation_surfaces</span>
<span class="sd">        sage: S = translation_surfaces.t_fractal()</span>
<span class="sd">        sage: labels = S.labels()</span>

<span class="sd">        sage: from flatsurf.geometry.surface import LabeledView</span>
<span class="sd">        sage: isinstance(labels, LabeledView)</span>
<span class="sd">        True</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LabeledView.__init__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.LabeledView.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">finite</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">finite</span><span class="o">=</span><span class="n">finite</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_view</span> <span class="o">=</span> <span class="n">view</span></div>

<div class="viewcode-block" id="LabeledView.__iter__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.LabeledView.__iter__">[docs]</a>    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_view</span><span class="p">)</span></div>

<div class="viewcode-block" id="LabeledView.__contains__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.LabeledView.__contains__">[docs]</a>    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_view</span></div>

<div class="viewcode-block" id="LabeledView.__len__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.LabeledView.__len__">[docs]</a>    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_view</span><span class="p">)</span></div>

<div class="viewcode-block" id="LabeledView.min"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.LabeledView.min">[docs]</a>    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a minimal item in this set.</span>

<span class="sd">        If the items can be compared, this is just the actual ``min`` of the</span>
<span class="sd">        items.</span>

<span class="sd">        Otherwise, we take the one with minimal ``repr``.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            If the items cannot be compared, and there are clashes in the</span>
<span class="sd">            ``repr``, this method will fail.</span>

<span class="sd">            Also, if comparison of items is not consistent, then this can</span>
<span class="sd">            produce somewhat random output.</span>

<span class="sd">            Finally, note with this approach the min of a set is not the always</span>
<span class="sd">            the min of the mins of a each partition of that set.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import translation_surfaces</span>
<span class="sd">            sage: S = translation_surfaces.t_fractal()</span>
<span class="sd">            sage: S.labels().min()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            NotImplementedError: cannot determine minimum of an infinite set</span>

<span class="sd">        ::</span>

<span class="sd">            sage: from flatsurf import translation_surfaces</span>
<span class="sd">            sage: C = translation_surfaces.cathedral(1,2)</span>
<span class="sd">            sage: C.labels().min()</span>
<span class="sd">            0</span>

<span class="sd">        ::</span>

<span class="sd">            sage: labels = list(C.labels())[:3]</span>
<span class="sd">            sage: from flatsurf.geometry.surface import LabeledView</span>
<span class="sd">            sage: LabeledView(C, labels).min()</span>
<span class="sd">            0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finite</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot determine minimum of an infinite set&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">reprs</span> <span class="o">=</span> <span class="p">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">item</span><span class="p">):</span> <span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">}</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reprs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;cannot determine minimum of tset without ordering and with non-unique repr()&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">reprs</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">reprs</span><span class="p">)]</span></div></div>


<div class="viewcode-block" id="ComponentLabels"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.ComponentLabels">[docs]</a><span class="k">class</span> <span class="nc">ComponentLabels</span><span class="p">(</span><span class="n">LabeledCollection</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The labels of a connected component.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``surface`` -- a polygonal surface</span>

<span class="sd">    - ``root`` -- a label of the connected component from which enumeration of</span>
<span class="sd">      the component starts.</span>

<span class="sd">    - ``finite`` -- a boolean or ``None`` (default: ``None``); whether this is</span>
<span class="sd">      a finite component; if ``None``, it is not known whether the component is</span>
<span class="sd">      finite (some operations might not be supported in that case or not</span>
<span class="sd">      terminate if the component is actually infinite.)</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import translation_surfaces</span>
<span class="sd">        sage: S = translation_surfaces.t_fractal()</span>
<span class="sd">        sage: component = S.component(0)</span>

<span class="sd">        sage: from flatsurf.geometry.surface import ComponentLabels</span>
<span class="sd">        sage: isinstance(component, ComponentLabels)</span>
<span class="sd">        True</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ComponentLabels.__init__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.ComponentLabels.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">finite</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">finite</span><span class="o">=</span><span class="n">finite</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_root</span> <span class="o">=</span> <span class="n">root</span></div>

<div class="viewcode-block" id="ComponentLabels.__iter__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.ComponentLabels.__iter__">[docs]</a>    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterator of this component that enumerates labels starting</span>
<span class="sd">        from the root label in a breadth-first-search.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import translation_surfaces</span>
<span class="sd">            sage: C = translation_surfaces.cathedral(1, 2)</span>
<span class="sd">            sage: component = C.component(0)</span>
<span class="sd">            sage: list(component)</span>
<span class="sd">            [0, 1, 3, 2]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

        <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">pending</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="p">])</span>

        <span class="k">while</span> <span class="n">pending</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">pending</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

            <span class="k">yield</span> <span class="n">label</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_surface</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">vertices</span><span class="p">())):</span>
                <span class="n">cross</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_surface</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cross</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">pending</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cross</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div></div>


<div class="viewcode-block" id="Labels"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.Labels">[docs]</a><span class="k">class</span> <span class="nc">Labels</span><span class="p">(</span><span class="n">LabeledCollection</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Set</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The labels of a surface.</span>

<span class="sd">    .. NOTE::</span>

<span class="sd">        This is a generic implementation that represents the set of labels of a</span>
<span class="sd">        surface in a breadth-first iteration starting from the root labels of the</span>
<span class="sd">        connected components.</span>

<span class="sd">        This implementation makes no assumption on the surface and can be very</span>
<span class="sd">        slow to answer, e.g., containment or compute the number of labels in</span>
<span class="sd">        the surface (because it needs to iterate over the entire surface.)</span>

<span class="sd">        When possible, a faster implementation should be used such as</span>
<span class="sd">        :class:`LabelsFromView`.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import polygons, similarity_surfaces</span>
<span class="sd">        sage: T = polygons.triangle(1, 2, 5)</span>
<span class="sd">        sage: S = similarity_surfaces.billiard(T)</span>
<span class="sd">        sage: S = S.minimal_cover(&quot;translation&quot;)</span>

<span class="sd">        sage: labels = S.labels()</span>
<span class="sd">        sage: labels</span>
<span class="sd">        ((0, 1, 0), (1, 1, 0), (1, 0, -1), (1, 1/2*c0, 1/2*c0), (0, 1/2*c0, -1/2*c0), (0, 0, 1), (0, -1/2*c0, -1/2*c0), (0, 0, -1), (0, -1/2*c0, 1/2*c0), (0, 1/2*c0, 1/2*c0),</span>
<span class="sd">         (1, 1/2*c0, -1/2*c0), (1, -1/2*c0, -1/2*c0), (1, 0, 1), (1, -1/2*c0, 1/2*c0), (1, -1, 0), (0, -1, 0))</span>

<span class="sd">    TESTS::</span>

<span class="sd">        sage: from flatsurf.geometry.surface import Labels</span>
<span class="sd">        sage: type(labels) == Labels</span>
<span class="sd">        True</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Labels.__iter__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.Labels.__iter__">[docs]</a>    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_surface</span><span class="o">.</span><span class="n">components</span><span class="p">():</span>
            <span class="k">yield from</span> <span class="n">component</span></div></div>


<div class="viewcode-block" id="LabelsFromView"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.LabelsFromView">[docs]</a><span class="k">class</span> <span class="nc">LabelsFromView</span><span class="p">(</span><span class="n">Labels</span><span class="p">,</span> <span class="n">LabeledView</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The labels of a surface backed by another set that can quickly compute the</span>
<span class="sd">    length of the labels and decide containment in the set.</span>

<span class="sd">    .. NOTE::</span>

<span class="sd">        Iteration of the view collection does not have to be in breadth-first</span>
<span class="sd">        search order in the surface since this class is picking up the generic</span>
<span class="sd">        :meth:`Labels.__iter__`.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import translation_surfaces</span>
<span class="sd">        sage: C = translation_surfaces.cathedral(1, 2)</span>
<span class="sd">        sage: labels = C.labels()</span>

<span class="sd">        sage: from flatsurf.geometry.surface import LabelsFromView</span>
<span class="sd">        sage: type(labels) == LabelsFromView</span>
<span class="sd">        True</span>

<span class="sd">    &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="Polygons"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.Polygons">[docs]</a><span class="k">class</span> <span class="nc">Polygons</span><span class="p">(</span><span class="n">LabeledCollection</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Collection</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The collection of polygons of a surface.</span>

<span class="sd">    The polygons are returned in the same order as labels of the surface are</span>
<span class="sd">    returned by :class:`.Labels`.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import translation_surfaces</span>
<span class="sd">        sage: C = translation_surfaces.cathedral(1, 2)</span>
<span class="sd">        sage: polygons = C.polygons()</span>

<span class="sd">        sage: from flatsurf.geometry.surface import Polygons</span>
<span class="sd">        sage: isinstance(polygons, Polygons)</span>
<span class="sd">        True</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Polygons.__iter__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.Polygons.__iter__">[docs]</a>    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over the polygons in the same order as ``labels()`` does.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import translation_surfaces</span>
<span class="sd">            sage: C = translation_surfaces.cathedral(1, 2)</span>
<span class="sd">            sage: labels = C.labels()</span>
<span class="sd">            sage: polygons = C.polygons()</span>

<span class="sd">            sage: for entry in zip(labels, polygons):</span>
<span class="sd">            ....:     print(entry)</span>
<span class="sd">            (0, Polygon(vertices=[(0, 0), (1, 0), (1, 1), (0, 1)]))</span>
<span class="sd">            (1, Polygon(vertices=[(1, 0), (1, -2), (3/2, -5/2), (2, -2), (2, 0), (2, 1), (2, 3), (3/2, 7/2), (1, 3), (1, 1)]))</span>
<span class="sd">            (3, Polygon(vertices=[(3, 0), (7/2, -1/2), (11/2, -1/2), (6, 0), (6, 1), (11/2, 3/2), (7/2, 3/2), (3, 1)]))</span>
<span class="sd">            (2, Polygon(vertices=[(2, 0), (3, 0), (3, 1), (2, 1)]))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_surface</span><span class="o">.</span><span class="n">labels</span><span class="p">():</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_surface</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span></div>

<div class="viewcode-block" id="Polygons.__len__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.Polygons.__len__">[docs]</a>    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of polygons in this surface.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import translation_surfaces</span>
<span class="sd">            sage: C = translation_surfaces.cathedral(1, 2)</span>
<span class="sd">            sage: polygons = C.polygons()</span>
<span class="sd">            sage: len(polygons)</span>
<span class="sd">            4</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_surface</span><span class="o">.</span><span class="n">labels</span><span class="p">())</span></div></div>


<div class="viewcode-block" id="Polygons_MutableOrientedSimilaritySurface"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.Polygons_MutableOrientedSimilaritySurface">[docs]</a><span class="k">class</span> <span class="nc">Polygons_MutableOrientedSimilaritySurface</span><span class="p">(</span><span class="n">Polygons</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The collection of polygons of a :class:`MutableOrientedSimilaritySurface`.</span>

<span class="sd">    This is a faster version of :class:`Polygons`.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import translation_surfaces</span>
<span class="sd">        sage: C = translation_surfaces.cathedral(1, 2)</span>
<span class="sd">        sage: polygons = C.polygons()</span>

<span class="sd">        sage: from flatsurf.geometry.surface import Polygons_MutableOrientedSimilaritySurface</span>
<span class="sd">        sage: isinstance(polygons, Polygons_MutableOrientedSimilaritySurface)</span>
<span class="sd">        True</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Polygons_MutableOrientedSimilaritySurface.__init__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.Polygons_MutableOrientedSimilaritySurface.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surface</span><span class="p">):</span>
        <span class="c1"># This hack makes __len__ 20% faster (it saves one attribute lookup.)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">_polygons</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span></div>

<div class="viewcode-block" id="Polygons_MutableOrientedSimilaritySurface.__len__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.Polygons_MutableOrientedSimilaritySurface.__len__">[docs]</a>    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Edges"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.Edges">[docs]</a><span class="k">class</span> <span class="nc">Edges</span><span class="p">(</span><span class="n">LabeledCollection</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Set</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The set of edges of a surface.</span>

<span class="sd">    The set of edges contains of pairs (label, index) with the labels of the</span>
<span class="sd">    polygons and the actual edges indexed from 0 in the second component.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import translation_surfaces</span>
<span class="sd">        sage: C = translation_surfaces.cathedral(1, 2)</span>
<span class="sd">        sage: edges = C.edges()</span>
<span class="sd">        sage: edges</span>
<span class="sd">        ((0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9), (3, 0), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7), (2, 0), (2, 1), (2, 2), (2, 3))</span>

<span class="sd">    TESTS::</span>

<span class="sd">        sage: from flatsurf.geometry.surface import Edges</span>
<span class="sd">        sage: isinstance(edges, Edges)</span>
<span class="sd">        True</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Edges.__iter__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.Edges.__iter__">[docs]</a>    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_surface</span><span class="o">.</span><span class="n">labels</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_surface</span><span class="o">.</span><span class="n">polygons</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">vertices</span><span class="p">())):</span>
                <span class="k">yield</span> <span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span></div>

<div class="viewcode-block" id="Edges.__contains__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.Edges.__contains__">[docs]</a>    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">label</span><span class="p">,</span> <span class="n">edge</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_surface</span><span class="o">.</span><span class="n">labels</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">polygon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_surface</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">edge</span></div></div>


<div class="viewcode-block" id="Gluings"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.Gluings">[docs]</a><span class="k">class</span> <span class="nc">Gluings</span><span class="p">(</span><span class="n">LabeledCollection</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Set</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The set of gluings of the surface.</span>

<span class="sd">    Each gluing consists of two pairs (label, index) that describe the edges</span>
<span class="sd">    being glued.</span>

<span class="sd">    Note that each gluing (that is not a self-gluing) is reported twice.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import translation_surfaces</span>
<span class="sd">        sage: S = translation_surfaces.square_torus()</span>
<span class="sd">        sage: gluings = S.gluings()</span>
<span class="sd">        sage: gluings</span>
<span class="sd">        (((0, 0), (0, 2)), ((0, 1), (0, 3)), ((0, 2), (0, 0)), ((0, 3), (0, 1)))</span>

<span class="sd">    TESTS::</span>

<span class="sd">        sage: from flatsurf.geometry.surface import Gluings</span>
<span class="sd">        sage: isinstance(gluings, Gluings)</span>
<span class="sd">        True</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Gluings.__iter__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.Gluings.__iter__">[docs]</a>    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_surface</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
            <span class="n">cross</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_surface</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cross</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">edge</span><span class="p">),</span> <span class="n">cross</span></div>

<div class="viewcode-block" id="Gluings.__contains__"><a class="viewcode-back" href="../../../geometry/surface.html#flatsurf.geometry.surface.Gluings.__contains__">[docs]</a>    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span>

        <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_surface</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">cross</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_surface</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cross</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">y</span> <span class="o">==</span> <span class="n">cross</span></div></div>


<span class="c1"># Import deprecated symbols so imports using flatsurf.geometry.surface do not break.</span>
<span class="kn">from</span> <span class="nn">flatsurf.geometry.surface_legacy</span> <span class="kn">import</span> <span class="p">(</span>  <span class="c1"># noqa, we import at the bottom of the file to break a circular import  # pylint: disable=wrong-import-position</span>
    <span class="n">Surface</span><span class="p">,</span>
    <span class="n">Surface_list</span><span class="p">,</span>
    <span class="n">Surface_dict</span><span class="p">,</span>
    <span class="n">surface_list_from_polygons_and_gluings</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2016-2024, the sage-flatsurf authors
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/scripts/furo.js"></script>
    <script src="../../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    </body>
</html>