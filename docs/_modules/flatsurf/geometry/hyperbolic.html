<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" />

    <!-- Generated with Sphinx 5.3.0 and Furo 2023.05.20 -->
        <title>flatsurf.geometry.hyperbolic - sage-flatsurf 0.5.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?digest=e6660623a769aa55fea372102b9bf3151b292993" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="https://doc.sagemath.org/html/en/reference/_static/custom-furo.css" />
    <link rel="stylesheet" type="text/css" href="https://doc.sagemath.org/html/en/reference/_static/custom-jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="https://doc.sagemath.org/html/en/reference/_static/custom-codemirror-monokai.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/jupyter_execute.css" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  --color-brand-primary: #0f0fff;
  --color-brand-content: #0f0fff;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">sage-flatsurf 0.5.2 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../../_static/logo.svg" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../../_static/logo.svg" alt="Dark Logo"/>
  </div>
  
  <span class="sidebar-brand-text">sage-flatsurf 0.5.2 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installing sage-flatsurf</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer.html">The Developer’s Guide for sage-flatsurf</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/tour.html">A Tour of the flatsurf Suite</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/defining_surfaces.html">Defining Surfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/graphics_configuration.html">Graphics Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/linear_action_and_delaunay.html">The GL(2,R) Action, the Veech Group, Delaunay Decomposition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/rel_deformations.html">Relative Period Deformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/saddle_connections.html">Working with Saddle Connections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/apisa_wright.html">Exploring Orbit Closures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/siegel_veech.html">Siegel-Veech Constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/straight_line_flow.html">Straight-Line Flow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/warwick-2017.html">Notes from the Warwick EPSRC Symposium on “Computation in geometric topology”</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/boshernitzan_conjecture.html">Boshernitzan’s Conjectures</a></li>
</ul>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../geometry.html">The flatsurf.geometry Package</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of The flatsurf.geometry Package</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/categories.html"><code class="docutils literal notranslate"><span class="pre">categories</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/chamanara.html"><code class="docutils literal notranslate"><span class="pre">chamanara</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/circle.html"><code class="docutils literal notranslate"><span class="pre">circle</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/cone_surfaces.html"><code class="docutils literal notranslate"><span class="pre">cone_surfaces</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/delaunay.html"><code class="docutils literal notranslate"><span class="pre">delaunay</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/dilation_surfaces.html"><code class="docutils literal notranslate"><span class="pre">dilation_surfaces</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/euclidean.html"><code class="docutils literal notranslate"><span class="pre">euclidean</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/finitely_generated_matrix_group.html"><code class="docutils literal notranslate"><span class="pre">finitely_generated_matrix_group</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/fundamental_group.html"><code class="docutils literal notranslate"><span class="pre">fundamental_group</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/gl2r_orbit_closure.html"><code class="docutils literal notranslate"><span class="pre">gl2r_orbit_closure</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/half_dilation_surface.html"><code class="docutils literal notranslate"><span class="pre">half_dilation_surface</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/half_translation_surfaces.html"><code class="docutils literal notranslate"><span class="pre">half_translation_surfaces</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/hyperbolic.html"><code class="docutils literal notranslate"><span class="pre">hyperbolic</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/hyperbolic_polygons.html"><code class="docutils literal notranslate"><span class="pre">hyperbolic_polygons</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/interval_exchange_transformation.html"><code class="docutils literal notranslate"><span class="pre">interval_exchange_transformation</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/l_infinity_delaunay_cells.html"><code class="docutils literal notranslate"><span class="pre">l_infinity_delaunay_cells</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/mappings.html"><code class="docutils literal notranslate"><span class="pre">mappings</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/mega_wollmilchsau.html"><code class="docutils literal notranslate"><span class="pre">mega_wollmilchsau</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/minimal_cover.html"><code class="docutils literal notranslate"><span class="pre">minimal_cover</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/origami.html"><code class="docutils literal notranslate"><span class="pre">origami</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/polygon.html"><code class="docutils literal notranslate"><span class="pre">polygon</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/polygonal_surfaces.html"><code class="docutils literal notranslate"><span class="pre">polygonal_surfaces</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/polygons.html"><code class="docutils literal notranslate"><span class="pre">polygons</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/polyhedra.html"><code class="docutils literal notranslate"><span class="pre">polyhedra</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/pyflatsurf_conversion.html"><code class="docutils literal notranslate"><span class="pre">pyflatsurf_conversion</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/euclidean_polygonal_surfaces.html"><code class="docutils literal notranslate"><span class="pre">euclidean_polygonal_surfaces</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/euclidean_polygons.html"><code class="docutils literal notranslate"><span class="pre">euclidean_polygons</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/euclidean_polygons_with_angles.html"><code class="docutils literal notranslate"><span class="pre">euclidean_polygons_with_angles</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/relative_homology.html"><code class="docutils literal notranslate"><span class="pre">relative_homology</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/similarity.html"><code class="docutils literal notranslate"><span class="pre">similarity</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/similarity_surfaces.html"><code class="docutils literal notranslate"><span class="pre">similarity_surfaces</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/similarity_surface_generators.html"><code class="docutils literal notranslate"><span class="pre">similarity_surface_generators</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/straight_line_trajectory.html"><code class="docutils literal notranslate"><span class="pre">straight_line_trajectory</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/subfield.html"><code class="docutils literal notranslate"><span class="pre">subfield</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/surface_category.html"><code class="docutils literal notranslate"><span class="pre">surface_category</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/surface_legacy.html"><code class="docutils literal notranslate"><span class="pre">surface_legacy</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/surface_objects.html"><code class="docutils literal notranslate"><span class="pre">surface_objects</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/surface.html"><code class="docutils literal notranslate"><span class="pre">surface</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/tangent_bundle.html"><code class="docutils literal notranslate"><span class="pre">tangent_bundle</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/thurston_veech.html"><code class="docutils literal notranslate"><span class="pre">thurston_veech</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/topological_surfaces.html"><code class="docutils literal notranslate"><span class="pre">topological_surfaces</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../geometry/translation_surfaces.html"><code class="docutils literal notranslate"><span class="pre">translation_surfaces</span></code></a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../graphical.html">The flatsurf.graphical Package</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of The flatsurf.graphical Package</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../graphical/hyperbolic.html"><code class="docutils literal notranslate"><span class="pre">hyperbolic</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../graphical/polygon.html"><code class="docutils literal notranslate"><span class="pre">polygon</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../graphical/straight_line_trajectory.html"><code class="docutils literal notranslate"><span class="pre">straight_line_trajectory</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../graphical/surface_point.html"><code class="docutils literal notranslate"><span class="pre">surface_point</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../graphical/surface.html"><code class="docutils literal notranslate"><span class="pre">surface</span></code></a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for flatsurf.geometry.hyperbolic</h1><div class="highlight"><pre>
<span></span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Two dimensional hyperbolic geometry.</span>

<span class="sd">.. jupyter-execute::</span>
<span class="sd">    :hide-code:</span>

<span class="sd">    # Allow jupyter-execute blocks in this module to contain doctests</span>
<span class="sd">    import jupyter_doctest_tweaks</span>

<span class="sd">EXAMPLES::</span>

<span class="sd">    sage: from flatsurf import HyperbolicPlane</span>

<span class="sd">    sage: H = HyperbolicPlane()</span>

<span class="sd">Points in the hyperbolic plane can be specified directly with coordinates</span>
<span class="sd">in the upper (complex) half plane::</span>

<span class="sd">    sage: H(1 + I)</span>
<span class="sd">    1 + I</span>

<span class="sd">The hyperbolic plane is defined over a fixed base ring; the rationals if no</span>
<span class="sd">base has been specified explicitly::</span>

<span class="sd">    sage: H(sqrt(2) + I)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    TypeError: unable to convert sqrt(2) to a rational</span>

<span class="sd">We can use a bigger field instead::</span>

<span class="sd">    sage: H_algebraic = HyperbolicPlane(AA)</span>
<span class="sd">    sage: H_algebraic(sqrt(2) + I)</span>
<span class="sd">    1.414213562373095? + 1.000000000000000?*I</span>

<span class="sd">Given two points in the hyperbolic plane, we can form the geodesic they lay on::</span>

<span class="sd">    sage: a = H(I)</span>
<span class="sd">    sage: b = H(2*I)</span>
<span class="sd">    sage: ab = H.geodesic(a, b)</span>
<span class="sd">    sage: ab</span>
<span class="sd">    {-x = 0}</span>

<span class="sd">Note that such a geodesic is oriented. The orientation is such that when we</span>
<span class="sd">replace the ``=`` in the above representation with a ``≥``, we obtain the half</span>
<span class="sd">space on its left::</span>

<span class="sd">    sage: H.geodesic(a, b).left_half_space()</span>
<span class="sd">    {x ≤ 0}</span>

<span class="sd">We can pass explicitly to the unoriented geodesic. Note that the oriented and</span>
<span class="sd">the unoriented version of a geodesic are not considered equal::</span>

<span class="sd">    sage: ab.unoriented()</span>
<span class="sd">    {x = 0}</span>
<span class="sd">    sage: ab == ab.unoriented()</span>
<span class="sd">    False</span>
<span class="sd">    sage: ab.is_subset(ab.unoriented())</span>
<span class="sd">    True</span>
<span class="sd">    sage: ab.unoriented().is_subset(ab)</span>
<span class="sd">    True</span>

<span class="sd">A vertical can also be specified directly::</span>

<span class="sd">    sage: H.vertical(0)</span>
<span class="sd">    {-x = 0}</span>

<span class="sd">We can also create ideal, i.e., infinite, points in the hyperbolic plane and</span>
<span class="sd">construct the geodesic that connects them::</span>

<span class="sd">    sage: H(1)</span>
<span class="sd">    1</span>

<span class="sd">    sage: H(oo)</span>
<span class="sd">    ∞</span>

<span class="sd">    sage: H.geodesic(1, oo)</span>
<span class="sd">    {-x + 1 = 0}</span>

<span class="sd">The geodesic that is given by a half circle in the upper half plane can be</span>
<span class="sd">created directly by providing its midpoint and the square of its radius::</span>

<span class="sd">    sage: H.half_circle(0, 1)</span>
<span class="sd">    {(x^2 + y^2) - 1 = 0}</span>

<span class="sd">Geodesics can be intersected::</span>

<span class="sd">    sage: H.half_circle(0, 1).intersection(H.vertical(0))</span>
<span class="sd">    I</span>

<span class="sd">    sage: H.half_circle(0, 1).intersection(H.half_circle(0, 2))</span>
<span class="sd">    {}</span>

<span class="sd">The intersection of two geodesics might be an ideal point::</span>

<span class="sd">    sage: H.vertical(-1).intersection(H.vertical(1))</span>
<span class="sd">    ∞</span>

<span class="sd">General convex subsets of the hyperbolic plane can be constructed by</span>
<span class="sd">intersecting half spaces; this way we can construct (possibly unbounded) convex</span>
<span class="sd">polygons::</span>

<span class="sd">    sage: P = H.intersection(</span>
<span class="sd">    ....:   H.vertical(-1).right_half_space(),</span>
<span class="sd">    ....:   H.vertical(1).left_half_space(),</span>
<span class="sd">    ....:   H.half_circle(0, 2).left_half_space())</span>

<span class="sd">    sage: P</span>
<span class="sd">    {x - 1 ≤ 0} ∩ {x + 1 ≥ 0} ∩ {(x^2 + y^2) - 2 ≥ 0}</span>

<span class="sd">We can also intersect objects that are not half spaces::</span>

<span class="sd">    sage: P.intersection(H.vertical(0))</span>
<span class="sd">    {x = 0} ∩ {(x^2 + y^2) - 2 ≥ 0}</span>

<span class="sd">.. WARNING::</span>

<span class="sd">    Our implementation was not conceived with inexact rings in mind. Due to</span>
<span class="sd">    popular demand, we do allow inexact base rings but many operations have</span>
<span class="sd">    not been tuned for numerical stability, yet.</span>

<span class="sd">    To make our implementation work for a variety of (inexact) base rings, we</span>
<span class="sd">    delegate some numerically critical bits to a separate &quot;geometry&quot; class that</span>
<span class="sd">    can be specified when creating a hyperbolic plane. For exact base rings,</span>
<span class="sd">    this defaults to the :class:`HyperbolicExactGeometry` which uses exact text</span>
<span class="sd">    book algorithms.</span>

<span class="sd">    Over inexact rings, we implement a :class:`HyperbolicEpsilonGeometry` which</span>
<span class="sd">    considers two numbers two be equal if they differ only by a small</span>
<span class="sd">    (relative) error. This should work reasonably well for inexact base rings</span>
<span class="sd">    that have no denormalized numbers, i.e., it will work well for ``RR`` and</span>
<span class="sd">    general ``RealField``.</span>

<span class="sd">    sage: HyperbolicPlane(RR)</span>
<span class="sd">    Hyperbolic Plane over Real Field with 53 bits of precision</span>

<span class="sd">    There is currently no implementation that works well with ``RDF``. It</span>
<span class="sd">    should be easy to adapt :class:`HyperbolicEpsilonGeometry` for that purpose</span>
<span class="sd">    to take into account denormalized numbers::</span>

<span class="sd">        sage: HyperbolicPlane(RDF)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError: geometry must be specified for HyperbolicPlane over inexact rings</span>

<span class="sd">    There is currently no implementation that works for ball arithmetic::</span>

<span class="sd">        sage: HyperbolicPlane(RBF)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError: geometry must be specified for HyperbolicPlane over inexact rings</span>

<span class="sd">.. NOTE::</span>

<span class="sd">    This module implements different kinds of convex subsets as different</span>
<span class="sd">    classes. The alternative would have been to represent all subsets as</span>
<span class="sd">    collections of (in)equalities in some hyperbolic model. There is for</span>
<span class="sd">    example a :class:`HyperbolicUnorientedSegment` and a</span>
<span class="sd">    :class:`HyperbolicConvexPolygon` even though the former could in principle</span>
<span class="sd">    be expressed as the latter. The advantage of this approach is that we can</span>
<span class="sd">    provide a more natural user interface, e.g., a segment has a single</span>
<span class="sd">    underlying geodesic whereas the corresponding convex polygon would have</span>
<span class="sd">    four (or three.) Similarly, an oriented geodesic (which cannot really be</span>
<span class="sd">    expressed as a convex polygon due to the orientation) has a left and a</span>
<span class="sd">    right associated half spaces.</span>

<span class="sd">    Sometimes it can, however, be beneficial to treat each subset as a convex</span>
<span class="sd">    polygon. In such a case, one can explicitly create polygons from subsets by</span>
<span class="sd">    intersecting their :meth:`HyperbolicConvexSet.half_spaces`::</span>

<span class="sd">        sage: g = H.vertical(0)</span>
<span class="sd">        sage: P = H.polygon(g.half_spaces(), check=False, assume_minimal=True)</span>
<span class="sd">        sage: P</span>
<span class="sd">        {x ≤ 0} ∩ {x ≥ 0}</span>

<span class="sd">    Note that such an object might not be fully functional since some methods</span>
<span class="sd">    may assume that the object is an actual polygon::</span>

<span class="sd">        sage: P.dimension()</span>
<span class="sd">        2</span>

<span class="sd">    Similarly, a geodesic can be treated as a segment without endpoints::</span>

<span class="sd">        sage: H.segment(g, start=None, end=None, check=False, assume_normalized=True)</span>
<span class="sd">        {-x = 0}</span>

<span class="sd">.. NOTE::</span>

<span class="sd">    This implementation is an alternative to the one that comes with SageMath.</span>
<span class="sd">    The one in SageMath has a number of issues, see e.g.</span>
<span class="sd">    https://trac.sagemath.org/ticket/32400. The implementation here tries very</span>
<span class="sd">    hard to perform all operations over the same base ring, have the best</span>
<span class="sd">    complexities possible, keep all objects in the same (Klein) model, is not</span>
<span class="sd">    using any symbolic expressions, and tries to produce better plots.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># ****************************************************************************</span>
<span class="c1">#  This file is part of sage-flatsurf.</span>
<span class="c1">#</span>
<span class="c1">#        Copyright (C) 2022-2023 Julian Rüth</span>
<span class="c1">#                           2022 Sam Freedman</span>
<span class="c1">#                           2022 Vincent Delecroix</span>
<span class="c1">#</span>
<span class="c1">#  sage-flatsurf is free software: you can redistribute it and/or modify</span>
<span class="c1">#  it under the terms of the GNU General Public License as published by</span>
<span class="c1">#  the Free Software Foundation, either version 2 of the License, or</span>
<span class="c1">#  (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1">#  sage-flatsurf is distributed in the hope that it will be useful,</span>
<span class="c1">#  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1">#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1">#  GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1">#  You should have received a copy of the GNU General Public License</span>
<span class="c1">#  along with sage-flatsurf. If not, see &lt;https://www.gnu.org/licenses/&gt;.</span>
<span class="c1"># ****************************************************************************</span>

<span class="kn">import</span> <span class="nn">collections.abc</span>

<span class="kn">from</span> <span class="nn">sage.structure.sage_object</span> <span class="kn">import</span> <span class="n">SageObject</span>
<span class="kn">from</span> <span class="nn">sage.structure.parent</span> <span class="kn">import</span> <span class="n">Parent</span>
<span class="kn">from</span> <span class="nn">sage.structure.element</span> <span class="kn">import</span> <span class="n">Element</span>
<span class="kn">from</span> <span class="nn">sage.structure.unique_representation</span> <span class="kn">import</span> <span class="n">UniqueRepresentation</span>
<span class="kn">from</span> <span class="nn">sage.misc.cachefunc</span> <span class="kn">import</span> <span class="n">cached_method</span>


<div class="viewcode-block" id="HyperbolicPlane"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane">[docs]</a><span class="k">class</span> <span class="nc">HyperbolicPlane</span><span class="p">(</span><span class="n">Parent</span><span class="p">,</span> <span class="n">UniqueRepresentation</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The hyperbolic plane.</span>

<span class="sd">    All objects in the plane must be specified over the given base ring. Note</span>
<span class="sd">    that, in some representations, objects might appear to live in a larger</span>
<span class="sd">    ring. E.g., when specifying a line by giving a center and the square of</span>
<span class="sd">    its radius in the half plane model, then the ideal endpoints of this line</span>
<span class="sd">    might have coordinates in the ring after adjoining a square root.</span>

<span class="sd">    The implemented elements of the plane are convex subsets such as (finite</span>
<span class="sd">    and infinite) points, geodesics, closed half planes, and closed convex</span>
<span class="sd">    polygons.</span>

<span class="sd">    ALGORITHM:</span>

<span class="sd">    We usually display objects as if they were defined in the upper half plane</span>
<span class="sd">    model. However, internally, we store most objects in a representation in</span>
<span class="sd">    the Klein model. In that model it tends to be easier to perform</span>
<span class="sd">    computations without having to extend the base ring and we can also rely on</span>
<span class="sd">    standard algorithms for geometry in the Euclidean plane.</span>

<span class="sd">    For the Klein model, we use a unit disk centered at (0, 0). The map from</span>
<span class="sd">    the upper half plane sends the imaginary unit `i` to the center at the</span>
<span class="sd">    origin, and sends 0 to (0, -1), 1 to (1, 0), -1 to (-1, 0) and infinity to</span>
<span class="sd">    (0, 1). The Möbius transformation</span>

<span class="sd">    .. MATH::</span>

<span class="sd">        z \mapsto \frac{z-i}{1 - iz}</span>

<span class="sd">    maps from the half plane model to the Poincaré disk model. We then</span>
<span class="sd">    post-compose this with the map that goes from the Poincaré disk model to</span>
<span class="sd">    the Klein model, which in polar coordinates sends</span>

<span class="sd">    .. MATH::</span>

<span class="sd">        (\phi, r)\mapsto \left(\phi, \frac{2r}{1 + r^2}\right).</span>

<span class="sd">    When we write out the full map explicitly in Euclidean coordinates, we get</span>

<span class="sd">    .. MATH::</span>

<span class="sd">        (x, y) \mapsto \frac{1}{1 + x^2 + y^2}\left(2x, -1 + x^2 + y^2\right)</span>

<span class="sd">    and</span>

<span class="sd">    .. MATH::</span>

<span class="sd">        (x, y) \mapsto \frac{1}{1 - y}\left(x, \sqrt{1 - x^2 - y^2}\right),</span>

<span class="sd">    for its inverse.</span>

<span class="sd">    A geodesic in the upper half plane is given by an equation of the form</span>

<span class="sd">    .. MATH::</span>

<span class="sd">        a(x^2 + y^2) + bx + c = 0</span>

<span class="sd">    which converts to an equation in the Klein model as</span>

<span class="sd">    .. MATH::</span>

<span class="sd">        (a + c) + bx + (a - c)y = 0.</span>

<span class="sd">    Conversely, a geodesic&#39;s equation in the Klein model</span>

<span class="sd">    .. MATH::</span>

<span class="sd">        a + bx + cy = 0</span>

<span class="sd">    corresponds to the equation</span>

<span class="sd">    .. MATH::</span>

<span class="sd">        (a + c)(x^2 + y^2) + 2bx + (a - c) = 0</span>

<span class="sd">    in the upper half plane model.</span>

<span class="sd">    Note that the intersection of two geodesics defined by coefficients in a</span>
<span class="sd">    field `K` in the Klein model has coordinates in `K` in the Klein model.</span>
<span class="sd">    The corresponding statement is not true for the upper half plane model.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``base_ring`` -- a base ring for the coefficients defining the equations</span>
<span class="sd">      of geodesics in the plane; defaults to the rational field if not</span>
<span class="sd">      specified.</span>

<span class="sd">    - ``geometry`` -- an implementation of the geometric primitives specified</span>
<span class="sd">      by :class:`HyperbolicExactGeometry`. If the ``base_ring`` is exact, this</span>
<span class="sd">      defaults to :class:`HyperbolicExactGeometry` over that base ring. If the</span>
<span class="sd">      base ring is ``RR`` or ``RealField``, this defaults to the</span>
<span class="sd">      :class:`HyperbolicEpsilonGeometry` over that ring. For other rings, a</span>
<span class="sd">      geometry must be explicitly provided.</span>

<span class="sd">    - ``category`` -- the category for this object; if not specified, defaults</span>
<span class="sd">      to sets. Note that we do not use metric spaces here since the elements</span>
<span class="sd">      are convex subsets of the hyperbolic plane and not just points and do</span>
<span class="sd">      therefore not satisfy the assumptions of a metric space.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import HyperbolicPlane</span>

<span class="sd">        sage: HyperbolicPlane()</span>
<span class="sd">        Hyperbolic Plane over Rational Field</span>

<span class="sd">    ::</span>

<span class="sd">        sage: HyperbolicPlane(AA)</span>
<span class="sd">        Hyperbolic Plane over Algebraic Real Field</span>

<span class="sd">    ::</span>

<span class="sd">        sage: HyperbolicPlane(RR)</span>
<span class="sd">        Hyperbolic Plane over Real Field with 53 bits of precision</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="HyperbolicPlane.__classcall__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane.__classcall__">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__classcall__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the hyperbolic plane with normalized arguments to make it a</span>
<span class="sd">        unique SageMath parent.</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicExactGeometry</span>

<span class="sd">            sage: HyperbolicPlane() is HyperbolicPlane(QQ)</span>
<span class="sd">            True</span>

<span class="sd">            sage: HyperbolicPlane() is HyperbolicPlane(geometry=HyperbolicExactGeometry(QQ))</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">QQ</span>

        <span class="n">base_ring</span> <span class="o">=</span> <span class="n">base_ring</span> <span class="ow">or</span> <span class="n">QQ</span>

        <span class="k">if</span> <span class="n">geometry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">RR</span>

            <span class="k">if</span> <span class="n">base_ring</span> <span class="ow">is</span> <span class="n">RR</span><span class="p">:</span>
                <span class="n">geometry</span> <span class="o">=</span> <span class="n">HyperbolicExactGeometry</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">base_ring</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">base_ring</span><span class="o">.</span><span class="n">is_exact</span><span class="p">():</span>
                <span class="n">geometry</span> <span class="o">=</span> <span class="n">HyperbolicExactGeometry</span><span class="p">(</span><span class="n">base_ring</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;geometry must be specified for HyperbolicPlane over inexact rings&quot;</span>
                <span class="p">)</span>

        <span class="kn">from</span> <span class="nn">sage.categories.all</span> <span class="kn">import</span> <span class="n">Sets</span>

        <span class="n">category</span> <span class="o">=</span> <span class="n">category</span> <span class="ow">or</span> <span class="n">Sets</span><span class="p">()</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__classcall__</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">base_ring</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">geometry</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">category</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicPlane.__init__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_ring</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">category</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the hyperbolic plane over ``base_ring``.</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>

<span class="sd">            sage: TestSuite(HyperbolicPlane(QQ)).run()</span>
<span class="sd">            sage: TestSuite(HyperbolicPlane(AA)).run()  # long time (.5s)</span>
<span class="sd">            sage: TestSuite(HyperbolicPlane(RR)).run()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">RR</span>

        <span class="k">if</span> <span class="n">geometry</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">base_ring</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;geometry base ring must be base ring of hyperbolic plane but </span><span class="si">{</span><span class="n">geometry</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="si">}</span><span class="s2"> is not </span><span class="si">{</span><span class="n">base_ring</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">RR</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()):</span>
            <span class="c1"># We should check that the coercion is an embedding but this is not possible currently.</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;base ring must embed into the reals&quot;</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">category</span><span class="o">=</span><span class="n">category</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base_ring</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span> <span class="o">=</span> <span class="n">geometry</span></div>

    <span class="k">def</span> <span class="nf">_coerce_map_from_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a coercion map from ``other`` to this hyperbolic plane.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Coercions between base rings induce coercion between hyperbolic planes::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>

<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: HyperbolicPlane(AA).has_coerce_map_from(H)</span>
<span class="sd">            True</span>

<span class="sd">        Base ring elements coerce as points on the real line::</span>

<span class="sd">            sage: H.has_coerce_map_from(QQ)</span>
<span class="sd">            True</span>
<span class="sd">            sage: H.has_coerce_map_from(ZZ)</span>
<span class="sd">            True</span>

<span class="sd">        Complex numbers do not coerce into the hyperbolic plane since that</span>
<span class="sd">        coercion would not be total::</span>

<span class="sd">            sage: H.has_coerce_map_from(CC)</span>
<span class="sd">            False</span>
<span class="sd">            sage: H.has_coerce_map_from(I.parent())</span>
<span class="sd">            False</span>
<span class="sd">            sage: HyperbolicPlane(RR).has_coerce_map_from(CC)</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">HyperbolicPlane</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">base_ring</span><span class="p">())</span>

        <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="HyperbolicPlane.__contains__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane.__contains__">[docs]</a>    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether the hyperbolic plane contains ``x``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>

<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        We mostly rely on the standard implementation in SageMath, i.e., the</span>
<span class="sd">        interplay between the operator ``==`` and the coercion model::</span>

<span class="sd">            sage: 0 in H</span>
<span class="sd">            True</span>

<span class="sd">        However, we override that logic for complex numbers. There cannot be a</span>
<span class="sd">        coercion from the complex number to the hyperbolic plane since that map</span>
<span class="sd">        would not be total but we want the following to work::</span>

<span class="sd">            sage: I in H</span>
<span class="sd">            True</span>

<span class="sd">        We do not support such containment checks when conversion of the</span>
<span class="sd">        element could lead to a loss of precision::</span>

<span class="sd">            sage: CC(I) in H</span>
<span class="sd">            False</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            There is currently no way to check whether a point is in the</span>
<span class="sd">            interior of a set.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicConvexSet.__contains__` to check containment of a</span>
<span class="sd">            point in subsets of the hyperbolic plane.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.categories.all</span> <span class="kn">import</span> <span class="n">NumberFields</span>

        <span class="kn">import</span> <span class="nn">sage.structure.element</span>
        <span class="kn">from</span> <span class="nn">sage.structure.parent</span> <span class="kn">import</span> <span class="n">Parent</span>
        <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">SR</span>

        <span class="c1"># pylint does not see the Cython parent() so we disable the import check.</span>
        <span class="c1"># pylint: disable=c-extension-no-member</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># pylint: enable=c-extension-no-member</span>

        <span class="c1"># Note that in old versions of SageMath (9.1 e.g.), I is not a number field element but a symbolic ring element.</span>
        <span class="c1"># The &quot;parent is SR&quot; part can probably removed at some point.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">Parent</span><span class="p">)</span> <span class="ow">and</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">NumberFields</span><span class="p">()</span> <span class="ow">or</span> <span class="n">parent</span> <span class="ow">is</span> <span class="n">SR</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">x</span><span class="o">.</span><span class="n">real</span><span class="p">()</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>
                <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">imag</span><span class="p">()</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>
                <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">imag</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">0</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicPlane.change_ring"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane.change_ring">[docs]</a>    <span class="k">def</span> <span class="nf">change_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the hyperbolic plane over a different base ``ring``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``ring`` -- a ring or ``None``; if ``None``, uses the current</span>
<span class="sd">          :meth:`~HyperbolicPlane.base_ring`.</span>

<span class="sd">        - ``geometry`` -- a geometry or ``None``; if ``None``, tries to convert</span>
<span class="sd">          the existing geometry to ``ring``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>

<span class="sd">            sage: HyperbolicPlane(QQ).change_ring(AA) is HyperbolicPlane(AA)</span>
<span class="sd">            True</span>

<span class="sd">        When changing to the ring ``RR`` and no geometry has been specified</span>
<span class="sd">        explicitly, the :class:`HyperbolicExactGeometry` changes to the</span>
<span class="sd">        :class:`HyperbolicEpsilonGeometry`, see</span>
<span class="sd">        :meth:`HyperbolicExactGeometry.change_ring`::</span>

<span class="sd">            sage: HyperbolicPlane(QQ).change_ring(RR) is HyperbolicPlane(RR)</span>
<span class="sd">            True</span>

<span class="sd">        In the opposite direction, the geometry cannot be determined automatically::</span>

<span class="sd">            sage: HyperbolicPlane(RR).change_ring(QQ)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: cannot change_ring() to an exact ring</span>

<span class="sd">        So the geometry has to be specified explicitly::</span>

<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicExactGeometry</span>
<span class="sd">            sage: HyperbolicPlane(RR).change_ring(QQ, geometry=HyperbolicExactGeometry(QQ)) is HyperbolicPlane(QQ)</span>
<span class="sd">            True</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicConvexSet.change_ring` or more generally</span>
<span class="sd">            :meth:`HyperbolicConvexSet.change` to change the ring and geometry</span>
<span class="sd">            a set is defined over.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ring</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">geometry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="n">ring</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ring</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">geometry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">HyperbolicPlane</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_an_element_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an element of the hyperbolic plane (mostly for testing.)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>

<span class="sd">            sage: HyperbolicPlane().an_element()</span>
<span class="sd">            0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<div class="viewcode-block" id="HyperbolicPlane.some_subsets"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane.some_subsets">[docs]</a>    <span class="k">def</span> <span class="nf">some_subsets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return some subsets of the hyperbolic plane for testing.</span>

<span class="sd">        Some of the returned sets are elements of the hyperbolic plane (i.e.,</span>
<span class="sd">        points) some are parents themselves, e.g., polygons.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>

<span class="sd">            sage: HyperbolicPlane().some_elements()</span>
<span class="sd">            [∞, 0, 1, -1, ...]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">ZZ</span>

        <span class="n">elements</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">some_elements</span><span class="p">()</span>

        <span class="n">elements</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">empty_set</span><span class="p">(),</span>
            <span class="c1"># Oriented Geodesics</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertical</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">half_circle</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">half_circle</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
            <span class="c1"># Unoriented Geodesics</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertical</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">unoriented</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">half_circle</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">unoriented</span><span class="p">(),</span>
            <span class="c1"># Half spaces</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertical</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">left_half_space</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">half_circle</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">left_half_space</span><span class="p">(),</span>
        <span class="p">]</span>

        <span class="c1"># The intersection algorithm is only implemented over exact rings.</span>
        <span class="n">elements</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="c1"># An unbounded polygon</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertical</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="o">.</span><span class="n">left_half_space</span><span class="p">()</span>
            <span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertical</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">right_half_space</span><span class="p">()),</span>
            <span class="c1"># An unbounded polygon which is bounded in the Euclidean plane</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertical</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="o">.</span><span class="n">left_half_space</span><span class="p">()</span>
            <span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertical</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">right_half_space</span><span class="p">())</span>
            <span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">left_half_space</span><span class="p">())</span>
            <span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">right_half_space</span><span class="p">()),</span>
            <span class="c1"># A bounded polygon</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span><span class="o">-</span><span class="n">ZZ</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="o">.</span><span class="n">left_half_space</span><span class="p">()</span>
            <span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span><span class="n">ZZ</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">right_half_space</span><span class="p">())</span>
            <span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span><span class="o">-</span><span class="n">ZZ</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">right_half_space</span><span class="p">())</span>
            <span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span><span class="n">ZZ</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">left_half_space</span><span class="p">()),</span>
            <span class="c1"># An unbounded oriented segment</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertical</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">left_half_space</span><span class="p">()),</span>
            <span class="c1"># A bounded oriented segment</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertical</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">right_half_space</span><span class="p">())</span>
            <span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span><span class="o">-</span><span class="n">ZZ</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">left_half_space</span><span class="p">()),</span>
            <span class="c1"># An unbounded unoriented segment</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertical</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">left_half_space</span><span class="p">())</span>
            <span class="o">.</span><span class="n">unoriented</span><span class="p">(),</span>
            <span class="c1"># A bounded unoriented segment</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertical</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">right_half_space</span><span class="p">())</span>
            <span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span><span class="o">-</span><span class="n">ZZ</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">left_half_space</span><span class="p">())</span>
            <span class="o">.</span><span class="n">unoriented</span><span class="p">(),</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="n">elements</span></div>

<div class="viewcode-block" id="HyperbolicPlane.some_elements"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane.some_elements">[docs]</a>    <span class="k">def</span> <span class="nf">some_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return some representative elements, i.e., points of the hyperbolic</span>
<span class="sd">        plane for testing.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>

<span class="sd">            sage: HyperbolicPlane().some_elements()</span>
<span class="sd">            [∞, 0, 1, -1, ...]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">infinity</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">half_circle</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span>
        <span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_test_some_subsets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tester</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run test suite on some representative convex subsets.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>

<span class="sd">            sage: HyperbolicPlane()._test_some_subsets()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_sub_testsuite</span> <span class="o">=</span> <span class="n">tester</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">tester</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tester</span><span class="p">(</span><span class="n">tester</span><span class="o">=</span><span class="n">tester</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">some_elements</span><span class="p">():</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  Running the test suite of </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">TestSuite</span>

            <span class="n">TestSuite</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">(</span>
                <span class="n">verbose</span><span class="o">=</span><span class="n">tester</span><span class="o">.</span><span class="n">_verbose</span><span class="p">,</span>
                <span class="n">prefix</span><span class="o">=</span><span class="n">tester</span><span class="o">.</span><span class="n">_prefix</span> <span class="o">+</span> <span class="s2">&quot;  &quot;</span><span class="p">,</span>
                <span class="n">raise_on_failure</span><span class="o">=</span><span class="n">is_sub_testsuite</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">tester</span><span class="o">.</span><span class="n">_prefix</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="HyperbolicPlane.random_element"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane.random_element">[docs]</a>    <span class="k">def</span> <span class="nf">random_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a random convex subset of this hyperbolic plane.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``kind`` -- one of ``&quot;empty_set&quot;```, ``&quot;point&quot;```, ``&quot;oriented geodesic&quot;```,</span>
<span class="sd">          ``&quot;unoriented geodesic&quot;```, ``&quot;half_space&quot;```, ``&quot;oriented segment&quot;``,</span>
<span class="sd">          ``&quot;unoriented segment&quot;``, ``&quot;polygon&quot;``; the kind of set to produce.</span>
<span class="sd">          If not specified, the kind of set is chosen</span>
<span class="sd">          randomly.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        Make the following randomized tests reproducible::</span>

<span class="sd">            sage: set_random_seed(0)</span>

<span class="sd">        ::</span>

<span class="sd">            sage: H.random_element()</span>
<span class="sd">            {}</span>

<span class="sd">        Specific types of random subsets can be requested::</span>

<span class="sd">            sage: H.random_element(&quot;point&quot;)</span>
<span class="sd">            -1/2 + 1/95*I</span>

<span class="sd">            sage: H.random_element(&quot;oriented geodesic&quot;)</span>
<span class="sd">            {-12*(x^2 + y^2) + 1144*x + 1159 = 0}</span>

<span class="sd">            sage: H.random_element(&quot;unoriented geodesic&quot;)</span>
<span class="sd">            {648*(x^2 + y^2) + 1654*x + 85 = 0}</span>

<span class="sd">            sage: H.random_element(&quot;half_space&quot;)</span>
<span class="sd">            {3*(x^2 + y^2) - 5*x - 1 ≥ 0}</span>

<span class="sd">            sage: H.random_element(&quot;oriented segment&quot;)</span>
<span class="sd">            {-3*(x^2 + y^2) + x + 3 = 0} ∩ {9*(x^2 + y^2) - 114*x + 28 ≥ 0} ∩ {(x^2 + y^2) + 12*x - 1 ≥ 0}</span>

<span class="sd">            sage: H.random_element(&quot;unoriented segment&quot;)</span>
<span class="sd">            {16*(x^2 + y^2) - x - 16 = 0} ∩ {(x^2 + y^2) + 64*x - 1 ≥ 0} ∩ {496*(x^2 + y^2) - 1056*x + 529 ≥ 0}</span>

<span class="sd">            sage: H.random_element(&quot;polygon&quot;)</span>
<span class="sd">            {56766100*(x^2 + y^2) - 244977117*x + 57459343 ≥ 0} ∩ {822002048*(x^2 + y^2) - 3988505279*x + 2596487836 ≥ 0} ∩ {464*(x^2 + y^2) + 9760*x + 11359 ≥ 0} ∩ {4*(x^2 + y^2) + 45*x + 49 ≥ 0}</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`some_elements` for a curated list of representative subsets.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kinds</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;empty_set&quot;</span><span class="p">:</span> <span class="n">HyperbolicEmptySet</span><span class="p">,</span>
            <span class="s2">&quot;point&quot;</span><span class="p">:</span> <span class="n">HyperbolicPointFromCoordinates</span><span class="p">,</span>
            <span class="s2">&quot;oriented geodesic&quot;</span><span class="p">:</span> <span class="n">HyperbolicOrientedGeodesic</span><span class="p">,</span>
            <span class="s2">&quot;unoriented geodesic&quot;</span><span class="p">:</span> <span class="n">HyperbolicUnorientedGeodesic</span><span class="p">,</span>
            <span class="s2">&quot;half_space&quot;</span><span class="p">:</span> <span class="n">HyperbolicHalfSpace</span><span class="p">,</span>
            <span class="s2">&quot;oriented segment&quot;</span><span class="p">:</span> <span class="n">HyperbolicOrientedSegment</span><span class="p">,</span>
            <span class="s2">&quot;unoriented segment&quot;</span><span class="p">:</span> <span class="n">HyperbolicUnorientedSegment</span><span class="p">,</span>
            <span class="s2">&quot;polygon&quot;</span><span class="p">:</span> <span class="n">HyperbolicConvexPolygon</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">kind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">randint</span>

            <span class="n">kind</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">kinds</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">kinds</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kinds</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;kind must be one of </span><span class="si">{</span><span class="n">kinds</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">kinds</span><span class="p">[</span><span class="n">kind</span><span class="p">]</span><span class="o">.</span><span class="n">random_set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicPlane.__call__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return ``x`` as an element of the hyperbolic plane.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>

<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H(1)</span>
<span class="sd">            1</span>

<span class="sd">        We need to override this method. The normal code path in SageMath</span>
<span class="sd">        requires the argument to be an Element but facade sets are not</span>
<span class="sd">        elements::</span>

<span class="sd">            sage: v = H.vertical(0)</span>

<span class="sd">            sage: Parent.__call__(H, v)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            TypeError: Cannot convert HyperbolicOrientedGeodesic_with_category_with_category to sage.structure.element.Element</span>

<span class="sd">            sage: H(v)</span>
<span class="sd">            {-x = 0}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">HyperbolicConvexFacade</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element_constructor_</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_element_constructor_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return ``x`` as an element of the hyperbolic plane.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>

<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H(H.an_element()) in H</span>
<span class="sd">            True</span>

<span class="sd">        Base ring elements can be converted to ideal points::</span>

<span class="sd">            sage: H(1)</span>
<span class="sd">            1</span>

<span class="sd">        The point at infinity in the half plane model can be written directly::</span>

<span class="sd">            sage: H(oo)</span>
<span class="sd">            ∞</span>

<span class="sd">        Complex numbers in the upper half plane can be converted to points in</span>
<span class="sd">        the hyperbolic plane::</span>

<span class="sd">            sage: H(I)</span>
<span class="sd">            I</span>

<span class="sd">        Elements can be converted between hyperbolic planes with compatible base rings::</span>

<span class="sd">            sage: HyperbolicPlane(AA)(H(1))</span>
<span class="sd">            1</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: H(-I)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: point (0, -1) not in the upper half plane</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">parent</span>

        <span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>

        <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">Infinity</span>

        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="n">Infinity</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">infinity</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">HyperbolicConvexSet</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="n">ring</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">(),</span> <span class="n">geometry</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">sage.categories.all</span> <span class="kn">import</span> <span class="n">NumberFields</span>

        <span class="k">if</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">NumberFields</span><span class="p">():</span>
            <span class="n">K</span> <span class="o">=</span> <span class="n">parent</span>

            <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">I</span>

            <span class="k">if</span> <span class="n">I</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">K</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;cannot create a hyperbolic point from an element in a number field that does not contain the imaginary unit&quot;</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">real</span><span class="p">(),</span> <span class="n">x</span><span class="o">.</span><span class="n">imag</span><span class="p">(),</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">SR</span>

        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="n">SR</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">real</span><span class="p">(),</span> <span class="n">x</span><span class="o">.</span><span class="n">imag</span><span class="p">(),</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">sage.categories.all</span> <span class="kn">import</span> <span class="n">Rings</span>

        <span class="k">if</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">Rings</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;cannot convert this element in </span><span class="si">{</span><span class="n">parent</span><span class="si">}</span><span class="s2"> to the hyperbolic plane over </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;cannot create a subset of the hyperbolic plane from this element yet.&quot;</span>
        <span class="p">)</span>

<div class="viewcode-block" id="HyperbolicPlane.base_ring"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane.base_ring">[docs]</a>    <span class="k">def</span> <span class="nf">base_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the base ring over which objects in the plane are defined.</span>

<span class="sd">        More specifically, all geodesics must have an equation `a + bx + cy =</span>
<span class="sd">        0` in the Klein model with coefficients in this ring, and all points</span>
<span class="sd">        must have coordinates in this ring when written in the Klein model, or</span>
<span class="sd">        be the end point of a geodesic. All other objects are built from these</span>
<span class="sd">        primitives.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>

<span class="sd">            sage: HyperbolicPlane().base_ring()</span>
<span class="sd">            Rational Field</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicConvexSet.change_ring` to change the ring a set is defined over</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_ring</span></div>

<div class="viewcode-block" id="HyperbolicPlane.is_exact"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane.is_exact">[docs]</a>    <span class="k">def</span> <span class="nf">is_exact</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether hyperbolic subsets have exact coordinates.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>

<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: H.is_exact()</span>
<span class="sd">            True</span>

<span class="sd">            sage: H = HyperbolicPlane(RR)</span>
<span class="sd">            sage: H.is_exact()</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">is_exact</span><span class="p">()</span></div>

<div class="viewcode-block" id="HyperbolicPlane.infinity"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane.infinity">[docs]</a>    <span class="k">def</span> <span class="nf">infinity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the point at infinity in the upper half plane model.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>

<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: p = H.infinity()</span>
<span class="sd">            sage: p</span>
<span class="sd">            ∞</span>

<span class="sd">            sage: p == H(oo)</span>
<span class="sd">            True</span>
<span class="sd">            sage: p.is_ideal()</span>
<span class="sd">            True</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`point` to create points in general.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">projective</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicPlane.real"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane.real">[docs]</a>    <span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the ideal point ``r`` on the real axis in the upper half</span>
<span class="sd">        plane model.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``r`` -- an element of the :meth:`base_ring`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>

<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: p = H.real(-2)</span>
<span class="sd">            sage: p</span>
<span class="sd">            -2</span>

<span class="sd">            sage: p == H(-2)</span>
<span class="sd">            True</span>
<span class="sd">            sage: p.is_ideal()</span>
<span class="sd">            True</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`point` to create points in general.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">projective</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicPlane.projective"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane.projective">[docs]</a>    <span class="k">def</span> <span class="nf">projective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the ideal point with projective coordinates ``[p: q]`` in the</span>
<span class="sd">        upper half plane model.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``p`` -- an element of the :meth:`base_ring`.</span>

<span class="sd">        - ``q`` -- an element of the :meth:`base_ring`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>

<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: H.projective(0, 1)</span>
<span class="sd">            0</span>

<span class="sd">            sage: H.projective(-1, 0)</span>
<span class="sd">            ∞</span>

<span class="sd">            sage: H.projective(0, 0)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: one of p and q must not be zero</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`point` to create points in general.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()(</span><span class="n">q</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">projective</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicPlane.start"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane.start">[docs]</a>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geodesic</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the ideal starting point of ``geodesic``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``geodesic`` -- an oriented geodesic</span>

<span class="sd">        - ``check`` -- whether to verify that ``geodesic`` is valid</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            This method exists to keep all the methods that actually create</span>
<span class="sd">            hyperbolic sets on the lowest level in the</span>
<span class="sd">            :class:`HyperbolicPlane`. It is otherwise identical to</span>
<span class="sd">            :meth:`HyperbolicOrientedGeodesic.start`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: p = H.start(H.vertical(0))</span>
<span class="sd">            sage: p</span>
<span class="sd">            0</span>

<span class="sd">            sage: H.vertical(0).start() == p</span>
<span class="sd">            True</span>

<span class="sd">        Points created this way might have coordinates that cannot be</span>
<span class="sd">        represented in the base ring::</span>

<span class="sd">            sage: p = H.half_circle(0, 2).start()</span>
<span class="sd">            sage: p.coordinates(model=&quot;klein&quot;)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: square root of 32 ...</span>

<span class="sd">            sage: p.coordinates(model=&quot;half_plane&quot;)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: square root of 32 ...</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geodesic</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">geodesic</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geodesic</span><span class="p">,</span> <span class="n">HyperbolicOrientedGeodesic</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;geodesic must be an oriented geodesic&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">check</span> <span class="ow">and</span> <span class="n">geodesic</span><span class="o">.</span><span class="n">is_ultra_ideal</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;geodesic does not intersect the Klein disk&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__make_element_class__</span><span class="p">(</span><span class="n">HyperbolicPointFromGeodesic</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geodesic</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicPlane.point"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane.point">[docs]</a>    <span class="k">def</span> <span class="nf">point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the point with coordinates (x, y) in the given model.</span>

<span class="sd">        When ``model`` is ``&quot;half_plane&quot;``, return the point `x + iy` in the upper half plane.</span>

<span class="sd">        When ``model`` is ``&quot;klein&quot;``, return the point (x, y) in the Klein model.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``x`` -- an element of the :meth:`base_ring`</span>

<span class="sd">        - ``y`` -- an element of the :meth:`base_ring`</span>

<span class="sd">        - ``model`` -- one of ``&quot;half_plane&quot;`` or ``&quot;klein&quot;``</span>

<span class="sd">        - ``check`` -- whether to validate the inputs (default: ``True``); set</span>
<span class="sd">          this to ``False``, to create an ultra-ideal point, i.e., a point</span>
<span class="sd">          outside the unit circle in the Klein model.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.point(0, 1, model=&quot;half_plane&quot;)</span>
<span class="sd">            I</span>

<span class="sd">            sage: H.point(1, 2, model=&quot;half_plane&quot;)</span>
<span class="sd">            1 + 2*I</span>

<span class="sd">            sage: H.point(0, 1, model=&quot;klein&quot;)</span>
<span class="sd">            ∞</span>

<span class="sd">        An ultra-ideal point::</span>

<span class="sd">            sage: H.point(2, 3, model=&quot;klein&quot;)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: point (2, 3) is not in the unit disk in the Klein model</span>

<span class="sd">            sage: H.point(2, 3, model=&quot;klein&quot;, check=False)</span>
<span class="sd">            (2, 3)</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicOrientedGeodesic.start` and</span>
<span class="sd">            :meth:`HyperbolicOrientedGeodesic.end` to generate points that do</span>
<span class="sd">            not have coordinates over the base ring.</span>
<span class="sd">            :meth:`infinity`, :meth:`real`, and :meth:`projective` as shortcuts</span>
<span class="sd">            to generate ideal points.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()(</span><span class="n">y</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s2">&quot;klein&quot;</span><span class="p">:</span>
            <span class="n">point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__make_element_class__</span><span class="p">(</span><span class="n">HyperbolicPointFromCoordinates</span><span class="p">)(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">model</span> <span class="o">==</span> <span class="s2">&quot;half_plane&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">classify_point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;point </span><span class="si">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="si">}</span><span class="s2"> not in the upper half plane&quot;</span><span class="p">)</span>

            <span class="n">denominator</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="p">(</span>
                <span class="n">x</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">/</span> <span class="n">denominator</span><span class="p">,</span>
                <span class="n">y</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="n">denominator</span><span class="p">,</span>
                <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span>
                <span class="n">check</span><span class="o">=</span><span class="n">check</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;unsupported model&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
            <span class="n">point</span><span class="o">.</span><span class="n">_check</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">point</span></div>

<div class="viewcode-block" id="HyperbolicPlane.half_circle"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane.half_circle">[docs]</a>    <span class="k">def</span> <span class="nf">half_circle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">radius_squared</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the geodesic centered around the real ``center`` and with</span>
<span class="sd">        ``radius_squared`` in the upper half plane model. The geodesic is</span>
<span class="sd">        oriented such that the point at infinity is to its left.</span>

<span class="sd">        Use the ``-`` operator to pass to the geodesic with opposite</span>
<span class="sd">        orientation.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``center`` -- an element of the :meth:`base_ring`, the center of the</span>
<span class="sd">          half circle on the real axis</span>

<span class="sd">        - ``radius_squared`` -- a positive element of the :meth:`base_ring`,</span>
<span class="sd">          the square of the radius of the half circle</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.half_circle(0, 1)</span>
<span class="sd">            {(x^2 + y^2) - 1 = 0}</span>

<span class="sd">            sage: H.half_circle(1, 3)</span>
<span class="sd">            {(x^2 + y^2) - 2*x - 2 = 0}</span>

<span class="sd">            sage: H.half_circle(1/3, 1/2)</span>
<span class="sd">            {18*(x^2 + y^2) - 12*x - 7 = 0}</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: H.half_circle(0, 0)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: radius must be positive</span>

<span class="sd">            sage: H.half_circle(0, -1)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: radius must be positive</span>

<span class="sd">            sage: H.half_circle(oo, 1)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            TypeError: unable to convert +Infinity to a rational</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`vertical` to get an oriented vertical in the</span>
<span class="sd">            half plane model and :meth:`geodesic` for the general</span>
<span class="sd">            interface, producing a geodesic from an equation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()(</span><span class="n">center</span><span class="p">)</span>
        <span class="n">radius_squared</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()(</span><span class="n">radius_squared</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">half_circle</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">radius_squared</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodesic</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicPlane.vertical"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane.vertical">[docs]</a>    <span class="k">def</span> <span class="nf">vertical</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">real</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the vertical geodesic at the ``real`` ideal point in the</span>
<span class="sd">        upper half plane model. The geodesic is oriented such that it goes</span>
<span class="sd">        from ``real`` to the point at infinity.</span>

<span class="sd">        Use the ``-`` operator to pass to the geodesic with opposite</span>
<span class="sd">        orientation.</span>

<span class="sd">        Use :meth:`HyperbolicConvexSet.unoriented` to get the unoriented</span>
<span class="sd">        vertical.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``real`` -- an element of the :meth:`base_ring`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.vertical(0)</span>
<span class="sd">            {-x = 0}</span>

<span class="sd">            sage: H.vertical(1)</span>
<span class="sd">            {-x + 1 = 0}</span>

<span class="sd">            sage: H.vertical(-1)</span>
<span class="sd">            {-x - 1 = 0}</span>

<span class="sd">        We can also create an unoriented geodesic::</span>

<span class="sd">            sage: v = H.vertical(0)</span>
<span class="sd">            sage: v.unoriented() == v</span>
<span class="sd">            False</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`half_circle` to get an oriented geodesic that is not a</span>
<span class="sd">            vertical and :meth:`geodesic` for the general interface, producing</span>
<span class="sd">            a geodesic from an equation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">real</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()(</span><span class="n">real</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">vertical</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodesic</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicPlane.geodesic"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane.geodesic">[docs]</a>    <span class="k">def</span> <span class="nf">geodesic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">oriented</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a geodesic in the hyperbolic plane.</span>

<span class="sd">        If only ``a`` and ``b`` are given, return the geodesic going through the points</span>
<span class="sd">        ``a`` and then ``b``.</span>

<span class="sd">        If ``c`` is specified and ``model`` is ``&quot;half_plane&quot;``, return the</span>
<span class="sd">        geodesic given by the half circle</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            a(x^2 + y^2) + bx + c = 0</span>

<span class="sd">        oriented such that the half plane</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            a(x^2 + y^2) + bx + c \ge 0</span>

<span class="sd">        is to its left.</span>

<span class="sd">        If ``c`` is specified and ``model`` is ``&quot;klein&quot;``, return the</span>
<span class="sd">        geodesic given by the chord with the equation</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            a + bx + cy = 0</span>

<span class="sd">        oriented such that the half plane</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            a + bx + cy \ge 0</span>

<span class="sd">        is to its left.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``a`` -- a point in the hyperbolic plane or an element of the :meth:`base_ring`</span>

<span class="sd">        - ``b`` -- a point in the hyperbolic plane or an element of the :meth:`base_ring`</span>

<span class="sd">        - ``c`` -- ``None`` or an element of the :meth:`base_ring` (default: ``None``)</span>

<span class="sd">        - ``model`` -- ``None``, ``&quot;half_plane&quot;``, or ``&quot;klein&quot;`` (default:</span>
<span class="sd">          ``None``); when ``a``, ``b`` and ``c`` are elements of the</span>
<span class="sd">          :meth:`base_ring`, in which model they should be interpreted.</span>

<span class="sd">        - ``oriented`` -- whether the returned geodesic is oriented (default: ``True``)</span>

<span class="sd">        - ``check`` -- whether to verify that the arguments define a geodesic</span>
<span class="sd">          in the hyperbolic plane (default: ``True``)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.geodesic(-1, 1)</span>
<span class="sd">            {(x^2 + y^2) - 1 = 0}</span>

<span class="sd">            sage: H.geodesic(0, I)</span>
<span class="sd">            {-x = 0}</span>

<span class="sd">            sage: H.geodesic(-1, I + 1)</span>
<span class="sd">            {2*(x^2 + y^2) - x - 3 = 0}</span>

<span class="sd">            sage: H.geodesic(2, -1, -3, model=&quot;half_plane&quot;)</span>
<span class="sd">            {2*(x^2 + y^2) - x - 3 = 0}</span>

<span class="sd">            sage: H.geodesic(-1, -1, 5, model=&quot;klein&quot;)</span>
<span class="sd">            {2*(x^2 + y^2) - x - 3 = 0}</span>

<span class="sd">        Geodesics cannot be defined from points whose coordinates are over a</span>
<span class="sd">        quadratic field extension::</span>

<span class="sd">            sage: H.geodesic(H.half_circle(0, 2).start(), H.half_circle(1, 2).end())</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: square root of 32 not in Rational Field</span>

<span class="sd">        Except for some special cases::</span>

<span class="sd">            sage: H.geodesic(H.half_circle(0, 2).start(), H.half_circle(0, 2).end())</span>
<span class="sd">            {(x^2 + y^2) - 2 = 0}</span>

<span class="sd">        Disabling the ``check``, lets us define geodesics in the Klein model</span>
<span class="sd">        that lie outside the unit circle::</span>

<span class="sd">            sage: H.geodesic(2, 1, 0, model=&quot;klein&quot;)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: ...</span>

<span class="sd">            sage: geodesic = H.geodesic(2, 1, 0, model=&quot;klein&quot;, check=False)</span>
<span class="sd">            sage: geodesic</span>
<span class="sd">            {2 + x = 0}</span>

<span class="sd">            sage: geodesic.start()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: geodesic does not intersect the Klein disk</span>

<span class="sd">            sage: geodesic.end()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: geodesic does not intersect the Klein disk</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: H.geodesic(0, 0)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: points specifying a geodesic must be distinct</span>

<span class="sd">        ..SEEALSO::</span>

<span class="sd">            :meth:`half_circle` and :meth:`vertical`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;points specifying a geodesic must be distinct&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">HyperbolicPointFromGeodesic</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">HyperbolicPointFromGeodesic</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">_geodesic</span> <span class="o">==</span> <span class="o">-</span><span class="n">b</span><span class="o">.</span><span class="n">_geodesic</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">_geodesic</span>

            <span class="n">ax</span><span class="p">,</span> <span class="n">ay</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>
            <span class="n">bx</span><span class="p">,</span> <span class="n">by</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>

            <span class="n">C</span> <span class="o">=</span> <span class="n">bx</span> <span class="o">-</span> <span class="n">ax</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">ay</span> <span class="o">-</span> <span class="n">by</span>
            <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">B</span> <span class="o">*</span> <span class="n">ax</span> <span class="o">+</span> <span class="n">C</span> <span class="o">*</span> <span class="n">ay</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span> <span class="n">oriented</span><span class="o">=</span><span class="n">oriented</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="n">check</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;a model must be specified when specifying a geodesic with coefficients&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s2">&quot;half_plane&quot;</span><span class="p">:</span>
            <span class="c1"># Convert to the Klein model.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span>
                <span class="n">a</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">-</span> <span class="n">c</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span> <span class="n">oriented</span><span class="o">=</span><span class="n">oriented</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="n">check</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s2">&quot;klein&quot;</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()(</span><span class="n">c</span><span class="p">)</span>

            <span class="n">geodesic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__make_element_class__</span><span class="p">(</span>
                <span class="n">HyperbolicOrientedGeodesic</span> <span class="k">if</span> <span class="n">oriented</span> <span class="k">else</span> <span class="n">HyperbolicUnorientedGeodesic</span>
            <span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
                <span class="n">geodesic</span> <span class="o">=</span> <span class="n">geodesic</span><span class="o">.</span><span class="n">_normalize</span><span class="p">()</span>
                <span class="n">geodesic</span><span class="o">.</span><span class="n">_check</span><span class="p">()</span>

            <span class="k">return</span> <span class="n">geodesic</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;cannot create geodesic from coefficients in this model&quot;</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicPlane.half_space"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane.half_space">[docs]</a>    <span class="k">def</span> <span class="nf">half_space</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a closed half space from its equation in ``model``.</span>

<span class="sd">        If ``model`` is ``&quot;half_plane&quot;``, return the half space</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            a(x^2 + y^2) + bx + c \ge 0</span>

<span class="sd">        in the upper half plane.</span>

<span class="sd">        If ``model`` is ``&quot;klein&quot;``, return the half space</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            a + bx + cy \ge 0</span>

<span class="sd">        in the Klein model.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``a`` -- an element of the :meth:`base_ring`</span>

<span class="sd">        - ``b`` -- an element of the :meth:`base_ring`</span>

<span class="sd">        - ``c`` -- an element of the :meth:`base_ring`</span>

<span class="sd">        - ``model`` -- one of ``&quot;half_plane&quot;``` or ``&quot;klein&quot;``</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.half_space(0, -1, 0, model=&quot;half_plane&quot;)</span>
<span class="sd">            {x ≤ 0}</span>

<span class="sd">        It is often easier to construct a half space as the space bounded by a geodesic::</span>

<span class="sd">            sage: H.vertical(0).left_half_space()</span>
<span class="sd">            {x ≤ 0}</span>

<span class="sd">        The half space y ≥ 0 given by its equation in the Klein model::</span>

<span class="sd">            sage: H.half_space(0, 0, 1, model=&quot;klein&quot;)</span>
<span class="sd">            {(x^2 + y^2) - 1 ≥ 0}</span>

<span class="sd">        ..SEEALSO::</span>

<span class="sd">            :meth:`HperbolicGeodesic.left_half_space`</span>
<span class="sd">            :meth:`HperbolicGeodesic.right_half_space`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geodesic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="n">check</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__make_element_class__</span><span class="p">(</span><span class="n">HyperbolicHalfSpace</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geodesic</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicPlane.segment"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane.segment">[docs]</a>    <span class="k">def</span> <span class="nf">segment</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">geodesic</span><span class="p">,</span>
        <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">oriented</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">assume_normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the segment on the ``geodesic`` bounded by ``start`` and ``end``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``geodesic`` -- a :meth:`geodesic` in this space.</span>

<span class="sd">        - ``start`` -- ``None`` or a :meth:`point` on the ``geodesic``, e.g.,</span>
<span class="sd">          obtained from the :meth:`HyperbolicGeodesic._intersection` of</span>
<span class="sd">          ``geodesic`` with another geodesic. If ``None``, the segment starts</span>
<span class="sd">          at the infinite :meth:`HyperbolicOrientedGeodesic.start` point of the</span>
<span class="sd">          geodesic.</span>

<span class="sd">        - ``end`` -- ``None`` or a :meth:`point` on the ``geodesic``, as for</span>
<span class="sd">          ``start``; must be later on ``geodesic`` than ``start`` if the</span>
<span class="sd">          geodesic is oriented.</span>

<span class="sd">        - ``oriented`` -- whether to produce an oriented segment or an</span>
<span class="sd">          unoriented segment. The default (``None``) is to produce an oriented</span>
<span class="sd">          segment iff ``geodesic`` is oriented or both ``start`` and ``end``</span>
<span class="sd">          are provided so the orientation can be deduced from their order.</span>

<span class="sd">        - ``check`` -- boolean (default: ``True``), whether validation is</span>
<span class="sd">          performed on the arguments.</span>

<span class="sd">        - ``assume_normalized`` -- boolean (default: ``False``), if not set,</span>
<span class="sd">          the returned segment is normalized, i.e., if it is actually a</span>
<span class="sd">          geodesic, a :class:`HyperbolicGeodesic` is returned, if it is</span>
<span class="sd">          actually a point, a :class:`HyperbolicPoint` is returned.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        When neither ``start`` nor ``end`` are given, a geodesic is returned::</span>

<span class="sd">            sage: H.segment(H.vertical(0), start=None, end=None)</span>
<span class="sd">            {-x = 0}</span>

<span class="sd">        When only one endpoint is provided, the segment is infinite on one end::</span>

<span class="sd">            sage: H.segment(H.vertical(0), start=I, end=None)</span>
<span class="sd">            {-x = 0} ∩ {(x^2 + y^2) - 1 ≥ 0}</span>

<span class="sd">        When both endpoints are provided, a proper closed segment is returned::</span>

<span class="sd">            sage: H.segment(H.vertical(0), start=I, end=2*I)</span>
<span class="sd">            {-x = 0} ∩ {(x^2 + y^2) - 1 ≥ 0} ∩ {(x^2 + y^2) - 4 ≤ 0}</span>

<span class="sd">        However, ideal endpoints on the geodesic are ignored::</span>

<span class="sd">            sage: H.segment(H.vertical(0), start=0, end=oo)</span>
<span class="sd">            {-x = 0}</span>

<span class="sd">        A segment can be reduced to a single point::</span>

<span class="sd">            sage: H.segment(H.vertical(0), start=I, end=I)</span>
<span class="sd">            I</span>

<span class="sd">        The endpoints must have coordinates over the base ring::</span>

<span class="sd">            sage: H.segment(H.half_circle(0, 2), H.half_circle(0, 2).start(), H.half_circle(0, 2).end())</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: square root of 32 ...</span>

<span class="sd">        The produced segment is oriented if the ``geodesic`` is oriented::</span>

<span class="sd">            sage: H.segment(H.vertical(0)).is_oriented()</span>
<span class="sd">            True</span>

<span class="sd">            sage: H.segment(H.vertical(0).unoriented()).is_oriented()</span>
<span class="sd">            False</span>

<span class="sd">        The segment is oriented if both ``start`` and ``end`` are provided::</span>

<span class="sd">            sage: H.segment(H.vertical(0).unoriented(), start=0, end=oo).is_oriented()</span>
<span class="sd">            True</span>
<span class="sd">            sage: H.segment(H.vertical(0).unoriented(), start=2*I, end=I).is_oriented()</span>
<span class="sd">            True</span>
<span class="sd">            sage: H.segment(H.vertical(0), start=I) != H.segment(H.vertical(0), end=I)</span>
<span class="sd">            True</span>

<span class="sd">        TESTS:</span>

<span class="sd">        When only a ``start`` point is provided, we cannot deduce the orientation of the geodesic::</span>

<span class="sd">            sage: H.segment(H.vertical(0).unoriented(), start=0, oriented=False)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: cannot deduce segment from single endpoint on an unoriented geodesic</span>

<span class="sd">            sage: H.segment(H.vertical(0).unoriented(), start=0, oriented=True)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: cannot deduce segment from single endpoint on an unoriented geodesic</span>

<span class="sd">            sage: H.segment(H.vertical(0).unoriented(), start=I, oriented=True)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: cannot deduce segment from single endpoint on an unoriented geodesic</span>

<span class="sd">        When only an ``end`` point is provided, we cannot deduce the orientation of the geodesic::</span>

<span class="sd">            sage: H.segment(H.vertical(0).unoriented(), end=0, oriented=False)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: cannot deduce segment from single endpoint on an unoriented geodesic</span>

<span class="sd">            sage: H.segment(H.vertical(0).unoriented(), end=0, oriented=True)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: cannot deduce segment from single endpoint on an unoriented geodesic</span>

<span class="sd">            sage: H.segment(H.vertical(0).unoriented(), end=I, oriented=True)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: cannot deduce segment from single endpoint on an unoriented geodesic</span>

<span class="sd">        When ``start`` and ``end`` are given, they must be ordered correctly::</span>

<span class="sd">            sage: H.segment(H.vertical(0), start=0, end=oo)</span>
<span class="sd">            {-x = 0}</span>

<span class="sd">            sage: H.segment(H.vertical(0).unoriented(), start=oo, end=0)</span>
<span class="sd">            {x = 0}</span>

<span class="sd">            sage: H.segment(H.vertical(0), start=oo, end=0)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: end point of segment must not be before start point on the underlying geodesic</span>

<span class="sd">            sage: H.segment(H.vertical(0), start=I, end=2*I)</span>
<span class="sd">            {-x = 0} ∩ {(x^2 + y^2) - 1 ≥ 0} ∩ {(x^2 + y^2) - 4 ≤ 0}</span>

<span class="sd">            sage: H.segment(H.vertical(0).unoriented(), start=2*I, end=I)</span>
<span class="sd">            {x = 0} ∩ {(x^2 + y^2) - 4 ≤ 0} ∩ {(x^2 + y^2) - 1 ≥ 0}</span>

<span class="sd">            sage: H.segment(H.vertical(0), start=2*I, end=I)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: end point of segment must not be before start point on the underlying geodesic</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicPoint.segment`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geodesic</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">geodesic</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geodesic</span><span class="p">,</span> <span class="n">HyperbolicGeodesic</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;geodesic must be a geodesic&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">HyperbolicPoint</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;start must be a point&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">HyperbolicPoint</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;end must be a point&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">oriented</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">oriented</span> <span class="o">=</span> <span class="n">geodesic</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span><span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">geodesic</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">():</span>
            <span class="n">geodesic</span> <span class="o">=</span> <span class="n">geodesic</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="n">oriented</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># any orientation of the geodesic will do</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;cannot deduce segment from single endpoint on an unoriented geodesic&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">geodesic</span><span class="o">.</span><span class="n">parametrize</span><span class="p">(</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span> <span class="o">&gt;</span> <span class="n">geodesic</span><span class="o">.</span><span class="n">parametrize</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
                <span class="n">geodesic</span> <span class="o">=</span> <span class="o">-</span><span class="n">geodesic</span>

        <span class="n">segment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__make_element_class__</span><span class="p">(</span>
            <span class="n">HyperbolicOrientedSegment</span> <span class="k">if</span> <span class="n">oriented</span> <span class="k">else</span> <span class="n">HyperbolicUnorientedSegment</span>
        <span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geodesic</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
            <span class="n">segment</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="n">require_normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">assume_normalized</span><span class="p">:</span>
            <span class="n">segment</span> <span class="o">=</span> <span class="n">segment</span><span class="o">.</span><span class="n">_normalize</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
            <span class="n">segment</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="n">require_normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">segment</span></div>

<div class="viewcode-block" id="HyperbolicPlane.polygon"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane.polygon">[docs]</a>    <span class="k">def</span> <span class="nf">polygon</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">half_spaces</span><span class="p">,</span>
        <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">assume_minimal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">marked_vertices</span><span class="o">=</span><span class="p">(),</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the convex polygon obtained by intersecting ``half_spaces``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``half_spaces`` -- a non-empty iterable of</span>
<span class="sd">          :class:`HyperbolicHalfSpace`\ s of this hyperbolic plane.</span>

<span class="sd">        - ``check`` -- boolean (default: ``True``), whether the arguments are</span>
<span class="sd">          validated.</span>

<span class="sd">        - ``assume_sorted`` -- boolean (default: ``False``), whether to assume</span>
<span class="sd">          that the ``half_spaces`` are already sorted with respect to</span>
<span class="sd">          :meth:`HyperbolicHalfSpaces._lt_`. When set, we omit sorting the</span>
<span class="sd">          half spaces explicitly, which is asymptotically the most exponsive</span>
<span class="sd">          part of the process of creating a polygon.</span>

<span class="sd">        - ``assume_minimal`` -- boolean (default: ``False``), whether to assume</span>
<span class="sd">          that the ``half_spaces`` provide a minimal representation of the</span>
<span class="sd">          polygon, i.e., removing any of them describes a different polygon.</span>
<span class="sd">          When set, we omit searching for a minimal subset of half spaces to</span>
<span class="sd">          describe the polygon.</span>

<span class="sd">        - ``marked_vertices`` -- an iterable of vertices (default: an empty</span>
<span class="sd">          tuple), the vertices are included in the</span>
<span class="sd">          :meth:`HyperbolicConvexPolygon.vertices` even if they are not in the set of</span>
<span class="sd">          minimal vertices describing this polygon.</span>

<span class="sd">        ALGORITHM:</span>

<span class="sd">        See :meth:`intersection` for algorithmic details.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        A finite convex polygon::</span>

<span class="sd">            sage: H.polygon([</span>
<span class="sd">            ....:   H.vertical(1).left_half_space(),</span>
<span class="sd">            ....:   H.vertical(-1).right_half_space(),</span>
<span class="sd">            ....:   H.half_circle(0, 2).left_half_space(),</span>
<span class="sd">            ....:   H.half_circle(0, 4).right_half_space(),</span>
<span class="sd">            ....: ])</span>
<span class="sd">            {x - 1 ≤ 0} ∩ {(x^2 + y^2) - 4 ≤ 0} ∩ {x + 1 ≥ 0} ∩ {(x^2 + y^2) - 2 ≥ 0}</span>

<span class="sd">        Redundant half spaces are removed from the final representation::</span>

<span class="sd">            sage: H.polygon([</span>
<span class="sd">            ....:   H.vertical(1).left_half_space(),</span>
<span class="sd">            ....:   H.vertical(-1).right_half_space(),</span>
<span class="sd">            ....:   H.half_circle(0, 2).left_half_space(),</span>
<span class="sd">            ....:   H.half_circle(0, 4).right_half_space(),</span>
<span class="sd">            ....:   H.half_circle(0, 6).right_half_space(),</span>
<span class="sd">            ....: ])</span>
<span class="sd">            {x - 1 ≤ 0} ∩ {(x^2 + y^2) - 4 ≤ 0} ∩ {x + 1 ≥ 0} ∩ {(x^2 + y^2) - 2 ≥ 0}</span>

<span class="sd">        The vertices of the polygon can be at ideal points; this polygon has</span>
<span class="sd">        vertices at -1 and 1::</span>

<span class="sd">            sage: H.polygon([</span>
<span class="sd">            ....:   H.vertical(1).left_half_space(),</span>
<span class="sd">            ....:   H.vertical(-1).right_half_space(),</span>
<span class="sd">            ....:   H.half_circle(0, 1).left_half_space(),</span>
<span class="sd">            ....:   H.half_circle(0, 4).right_half_space(),</span>
<span class="sd">            ....: ])</span>
<span class="sd">            {x - 1 ≤ 0} ∩ {(x^2 + y^2) - 4 ≤ 0} ∩ {x + 1 ≥ 0} ∩ {(x^2 + y^2) - 1 ≥ 0}</span>

<span class="sd">        Any set of half spaces defines a polygon, even if the edges do not even</span>
<span class="sd">        meet at ideal points::</span>

<span class="sd">            sage: H.polygon([</span>
<span class="sd">            ....:   H.half_circle(0, 1).left_half_space(),</span>
<span class="sd">            ....:   H.half_circle(0, 2).right_half_space(),</span>
<span class="sd">            ....: ])</span>
<span class="sd">            {(x^2 + y^2) - 2 ≤ 0} ∩ {(x^2 + y^2) - 1 ≥ 0}</span>

<span class="sd">        However, when the resulting set is point, the result is not represented</span>
<span class="sd">        as a polygon anymore::</span>

<span class="sd">            sage: H.polygon([</span>
<span class="sd">            ....:   H.vertical(-1).left_half_space(),</span>
<span class="sd">            ....:   H.vertical(1).right_half_space(),</span>
<span class="sd">            ....: ])</span>
<span class="sd">            ∞</span>

<span class="sd">        We can force the creation of this set as a polygon which might be</span>
<span class="sd">        beneficial in some algorithmic applications::</span>

<span class="sd">            sage: H.polygon([</span>
<span class="sd">            ....:   H.vertical(-1).left_half_space(),</span>
<span class="sd">            ....:   H.vertical(1).right_half_space(),</span>
<span class="sd">            ....: ], check=False, assume_minimal=True)</span>
<span class="sd">            {x + 1 ≤ 0} ∩ {x - 1 ≥ 0}</span>

<span class="sd">        Note that forcing this mode does not remove redundant half spaces from</span>
<span class="sd">        the representation; we usually assume that the representation is</span>
<span class="sd">        minimal, so such a polygon might not behave correctly::</span>

<span class="sd">            sage: H.polygon([</span>
<span class="sd">            ....:   H.vertical(-1).left_half_space(),</span>
<span class="sd">            ....:   H.vertical(1).right_half_space(),</span>
<span class="sd">            ....:   H.vertical(2).right_half_space(),</span>
<span class="sd">            ....: ], check=False, assume_minimal=True)</span>
<span class="sd">            {x + 1 ≤ 0} ∩ {x - 1 ≥ 0} ∩ {x - 2 ≥ 0}</span>

<span class="sd">        We could manually pass to a minimal representation by rewriting the</span>
<span class="sd">        point as half spaces again::</span>

<span class="sd">            sage: minimal = H.polygon([</span>
<span class="sd">            ....:   H.vertical(-1).left_half_space(),</span>
<span class="sd">            ....:   H.vertical(1).right_half_space(),</span>
<span class="sd">            ....:   H.vertical(2).right_half_space(),</span>
<span class="sd">            ....: ])</span>
<span class="sd">            sage: H.polygon(minimal.half_spaces(), check=False, assume_minimal=True)</span>
<span class="sd">            {x ≤ 0} ∩ {x - 1 ≥ 0}</span>

<span class="sd">        Note that this chose half spaces not in the original set; you might</span>
<span class="sd">        also want to have a look at :meth:`HyperbolicConvexPolygon._normalize`</span>
<span class="sd">        for some ideas how to manually reduce the half spaces that are used in</span>
<span class="sd">        a polygon.</span>

<span class="sd">        Note that the same applies if the intersection of half spaces is empty</span>
<span class="sd">        or just a single half space::</span>

<span class="sd">            sage: empty = H.polygon([</span>
<span class="sd">            ....:   H.half_circle(0, 1).right_half_space(),</span>
<span class="sd">            ....:   H.half_circle(0, 2).left_half_space(),</span>
<span class="sd">            ....: ])</span>
<span class="sd">            sage: type(empty)</span>
<span class="sd">            &lt;class &#39;flatsurf.geometry.hyperbolic.HyperbolicEmptySet_with_category_with_category&#39;&gt;</span>

<span class="sd">        ::</span>

<span class="sd">            sage: half_space = H.polygon([</span>
<span class="sd">            ....:   H.half_circle(0, 1).right_half_space(),</span>
<span class="sd">            ....: ])</span>
<span class="sd">            sage: type(half_space)</span>
<span class="sd">            &lt;class &#39;flatsurf.geometry.hyperbolic.HyperbolicHalfSpace_with_category_with_category&#39;&gt;</span>

<span class="sd">        If we add a marked point to such a half space, the underlying type is a</span>
<span class="sd">        polygon again::</span>

<span class="sd">            sage: half_space = H.polygon([</span>
<span class="sd">            ....:   H.half_circle(0, 1).right_half_space(),</span>
<span class="sd">            ....: ], marked_vertices=[I])</span>
<span class="sd">            sage: half_space</span>
<span class="sd">            {(x^2 + y^2) - 1 ≤ 0} ∪ {I}</span>
<span class="sd">            sage: type(half_space)</span>
<span class="sd">            &lt;class &#39;flatsurf.geometry.hyperbolic.HyperbolicConvexPolygon_with_category_with_category&#39;&gt;</span>

<span class="sd">        Marked points that coincide with vertices are ignored::</span>

<span class="sd">            sage: half_space = H.polygon([</span>
<span class="sd">            ....:   H.half_circle(0, 1).right_half_space(),</span>
<span class="sd">            ....: ], marked_vertices=[-1])</span>
<span class="sd">            sage: half_space</span>
<span class="sd">            {(x^2 + y^2) - 1 ≤ 0}</span>
<span class="sd">            sage: type(half_space)</span>
<span class="sd">            &lt;class &#39;flatsurf.geometry.hyperbolic.HyperbolicHalfSpace_with_category_with_category&#39;&gt;</span>

<span class="sd">        Marked points must be on an edge of the polygon::</span>

<span class="sd">            sage: H.polygon([</span>
<span class="sd">            ....:   H.half_circle(0, 1).right_half_space(),</span>
<span class="sd">            ....: ], marked_vertices=[-2])</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: marked vertex must be on an edge of the polygon</span>

<span class="sd">            sage: H.polygon([</span>
<span class="sd">            ....:   H.half_circle(0, 1).right_half_space(),</span>
<span class="sd">            ....: ], marked_vertices=[2*I])</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: marked vertex must be on an edge of the polygon</span>

<span class="sd">        The intersection of the half spaces is computed in time quasi-linear in</span>
<span class="sd">        the number of half spaces. The limiting factor is sorting the half</span>
<span class="sd">        spaces by :meth:`HyperbolicHalfSpaces._lt_`. If we know that the</span>
<span class="sd">        half spaces are already sorted like that, we can make the process run</span>
<span class="sd">        in linear time by setting ``assume_sorted``.</span>

<span class="sd">            sage: H.polygon(H.infinity().half_spaces(), assume_sorted=True)</span>
<span class="sd">            ∞</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`intersection` to intersect arbitrary convex sets</span>
<span class="sd">            :meth:`convex_hull` to define a polygon by taking the convex hull</span>
<span class="sd">            of a union of convex sets</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">marked_vertices</span><span class="p">:</span>
            <span class="n">marked_vertices</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">half_spaces</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">(</span><span class="n">half_space</span><span class="p">)</span> <span class="k">for</span> <span class="n">half_space</span> <span class="ow">in</span> <span class="n">half_spaces</span><span class="p">]</span>
        <span class="n">marked_vertices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span> <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">marked_vertices</span><span class="p">]</span>

        <span class="n">half_spaces</span> <span class="o">=</span> <span class="n">HyperbolicHalfSpaces</span><span class="p">(</span><span class="n">half_spaces</span><span class="p">,</span> <span class="n">assume_sorted</span><span class="o">=</span><span class="n">assume_sorted</span><span class="p">)</span>

        <span class="n">polygon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__make_element_class__</span><span class="p">(</span><span class="n">HyperbolicConvexPolygon</span><span class="p">)(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">half_spaces</span><span class="p">,</span> <span class="n">marked_vertices</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
            <span class="n">polygon</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="n">require_normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">check</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">assume_minimal</span><span class="p">:</span>
            <span class="n">polygon</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">_normalize</span><span class="p">(</span><span class="n">marked_vertices</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">marked_vertices</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
            <span class="n">polygon</span><span class="o">.</span><span class="n">_check</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">polygon</span></div>

<div class="viewcode-block" id="HyperbolicPlane.convex_hull"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane.convex_hull">[docs]</a>    <span class="k">def</span> <span class="nf">convex_hull</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">subsets</span><span class="p">,</span> <span class="n">marked_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the convex hull of the ``subsets``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``subsets`` -- a sequence of subsets of this hyperbolic space.</span>

<span class="sd">        - ``marked_vertices`` -- a boolean (default: ``False``), whether to</span>
<span class="sd">          keep redundant vertices on the boundary.</span>

<span class="sd">        ALGORITHM:</span>

<span class="sd">        We use the standard Graham scan algorithm which runs in O(nlogn), see</span>
<span class="sd">        :meth:`HyperbolicHalfSpaces.convex_hull`.</span>

<span class="sd">        However, to get the unbounded bits of the convex hull right, we use a</span>
<span class="sd">        somewhat naive O(n²) algorithm which could probably be improved easily.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        A polygon can also be created as the convex hull of its vertices::</span>

<span class="sd">            sage: H.convex_hull(I - 1, I + 1, 2*I - 1, 2*I + 1)</span>
<span class="sd">            {x - 1 ≤ 0} ∩ {(x^2 + y^2) - 5 ≤ 0} ∩ {x + 1 ≥ 0} ∩ {(x^2 + y^2) - 2 ≥ 0}</span>

<span class="sd">        The vertices can also be infinite::</span>

<span class="sd">            sage: H.convex_hull(-1, 1, 2*I)</span>
<span class="sd">            {(x^2 + y^2) + 3*x - 4 ≤ 0} ∩ {(x^2 + y^2) - 3*x - 4 ≤ 0} ∩ {(x^2 + y^2) - 1 ≥ 0}</span>

<span class="sd">        Redundant vertices are removed. However, they can be kept by setting</span>
<span class="sd">        ``marked_vertices``::</span>

<span class="sd">            sage: H.convex_hull(-1, 1, I, 2*I)</span>
<span class="sd">            {(x^2 + y^2) + 3*x - 4 ≤ 0} ∩ {(x^2 + y^2) - 3*x - 4 ≤ 0} ∩ {(x^2 + y^2) - 1 ≥ 0}</span>

<span class="sd">            sage: polygon = H.convex_hull(-1, 1, I, 2*I, marked_vertices=True)</span>
<span class="sd">            sage: polygon</span>
<span class="sd">            {(x^2 + y^2) + 3*x - 4 ≤ 0} ∩ {(x^2 + y^2) - 3*x - 4 ≤ 0} ∩ {(x^2 + y^2) - 1 ≥ 0} ∪ {I}</span>

<span class="sd">            sage: polygon.vertices()</span>
<span class="sd">            {-1, I, 1, 2*I}</span>

<span class="sd">        The convex hull of a half space and a point::</span>

<span class="sd">            sage: H.convex_hull(H.half_circle(0, 1).right_half_space(), 0)</span>
<span class="sd">            {(x^2 + y^2) - 1 ≤ 0}</span>

<span class="sd">        To keep the additional vertices, again ``marked_vertices`` must be set::</span>

<span class="sd">            sage: H.convex_hull(H.half_circle(0, 1).left_half_space(), I, marked_vertices=True)</span>
<span class="sd">            {(x^2 + y^2) - 1 ≥ 0} ∪ {I}</span>

<span class="sd">            sage: H.convex_hull(H.vertical(0).left_half_space(), 0, I, oo, marked_vertices=True)</span>
<span class="sd">            {x ≤ 0} ∪ {I}</span>

<span class="sd">            sage: H.convex_hull(H.vertical(0).right_half_space(), I, marked_vertices=True)</span>
<span class="sd">            {x ≥ 0} ∪ {I}</span>

<span class="sd">        Note that this cannot be used to produce marked points on a geodesic::</span>

<span class="sd">            sage: H.convex_hull(-1, I, 1)</span>
<span class="sd">            {(x^2 + y^2) - 1 = 0}</span>

<span class="sd">            sage: H.convex_hull(-1, I, 1, marked_vertices=True)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            NotImplementedError: cannot add marked vertices to low dimensional objects</span>

<span class="sd">        Note that this cannot be used to produce marked points on a segment::</span>

<span class="sd">            sage: H.convex_hull(I, 2*I, 3*I)</span>
<span class="sd">            {x = 0}</span>

<span class="sd">            sage: H.convex_hull(I, 2*I, 3*I, marked_vertices=True)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            NotImplementedError: cannot add marked vertices to low dimensional objects</span>

<span class="sd">        The convex point of two polygons which contain infinitely many ideal points::</span>

<span class="sd">            sage: H.convex_hull(</span>
<span class="sd">            ....:     H.polygon([H.geodesic(-1, -1/4).left_half_space(), H.geodesic(0, -2).left_half_space()]),</span>
<span class="sd">            ....:     H.polygon([H.geodesic(4, 2).left_half_space(), H.geodesic(4, oo).left_half_space()]),</span>
<span class="sd">            ....:     H.polygon([H.geodesic(-1/2, 1/2).left_half_space(), H.geodesic(2, -2).left_half_space()])</span>
<span class="sd">            ....: )</span>
<span class="sd">            {2*(x^2 + y^2) - x ≥ 0} ∩ {(x^2 + y^2) - 2*x - 8 ≤ 0} ∩ {8*(x^2 + y^2) + 6*x + 1 ≥ 0}</span>

<span class="sd">        TESTS:</span>

<span class="sd">        A trivial case that did not work initially:</span>

<span class="sd">            sage: H.convex_hull(H(0), H(1), H(oo), H(I), H(I + 1))</span>
<span class="sd">            {(x^2 + y^2) - x ≥ 0} ∩ {x - 1 ≤ 0} ∩ {x ≥ 0}</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicHalfSpaces.convex_hull` for the underlying implementation</span>
<span class="sd">            :meth:`intersection` to compute the intersection of convex sets</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">subsets</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span> <span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="n">subsets</span><span class="p">]</span>

        <span class="n">vertices</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">subset</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span> <span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="n">subsets</span><span class="p">],</span> <span class="p">[])</span>

        <span class="n">polygon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">HyperbolicHalfSpaces</span><span class="o">.</span><span class="n">convex_hull</span><span class="p">(</span><span class="n">vertices</span><span class="p">))</span>

        <span class="n">half_spaces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="n">subsets</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">subset</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="n">HyperbolicHalfSpace</span><span class="p">):</span>
                    <span class="n">half_spaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="n">HyperbolicConvexPolygon</span><span class="p">):</span>
                    <span class="c1"># An infinity polygon is more than just the convex hull of</span>
                    <span class="c1"># its vertices, it may also contain entire half spaces,</span>
                    <span class="c1"># namely those that are between vertices that are not</span>
                    <span class="c1"># connected by an edge.</span>
                    <span class="n">edges</span> <span class="o">=</span> <span class="n">subset</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">subset</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span><span class="o">.</span><span class="n">pairs</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                            <span class="n">half_spaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">right_half_space</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                        <span class="s2">&quot;cannot form convex hull of this kind of set yet&quot;</span>
                    <span class="p">)</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">polygon</span><span class="o">.</span><span class="n">half_spaces</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">half_space</span> <span class="ow">in</span> <span class="n">half_spaces</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="n">edge</span><span class="p">)</span><span class="o">.</span><span class="n">is_subset</span><span class="p">(</span><span class="n">half_space</span><span class="p">):</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">marked_vertices</span><span class="p">:</span>
            <span class="n">marked_vertices</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">vertex</span>
                <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">vertices</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">vertex</span> <span class="ow">in</span> <span class="n">half_space</span><span class="o">.</span><span class="n">boundary</span><span class="p">()</span> <span class="k">for</span> <span class="n">half_space</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="n">polygon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">marked_vertices</span><span class="o">=</span><span class="n">marked_vertices</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">subset</span><span class="o">.</span><span class="n">is_subset</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span> <span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="n">subsets</span>
        <span class="p">),</span> <span class="s2">&quot;convex hull does not contain all the sets it is supposed to be the convex hull of&quot;</span>

        <span class="k">return</span> <span class="n">polygon</span></div>

<div class="viewcode-block" id="HyperbolicPlane.intersection"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane.intersection">[docs]</a>    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">subsets</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the intersection of convex ``subsets``.</span>

<span class="sd">        ALGORITHM:</span>

<span class="sd">        We compute the intersection of the</span>
<span class="sd">        :meth:`HyperbolicConvexSet.half_spaces` that make up the ``subsets``.</span>
<span class="sd">        That intersection can be computed in the Klein model where we can</span>
<span class="sd">        essentially reduce this problem to the intersection of half spaces in</span>
<span class="sd">        the Euclidean plane.</span>

<span class="sd">        The Euclidean intersection problem can be solved in time linear in the</span>
<span class="sd">        number of half spaces assuming that the half spaces are already sorted</span>
<span class="sd">        in a certain way. In particular, this is the case if there is only a</span>
<span class="sd">        constant number of ``subsets``. Otherwise, the algorithm is</span>
<span class="sd">        quasi-linear in the number of half spaces due to the added complexity</span>
<span class="sd">        of sorting.</span>

<span class="sd">        See :meth:`HyperbolicConvexPolygon._normalize` for more algorithmic details.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``subsets`` -- a non-empty sequence of subsets of this hyperbolic space.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.intersection(H.vertical(0).left_half_space())</span>
<span class="sd">            {x ≤ 0}</span>

<span class="sd">            sage: H.intersection(H.vertical(0).left_half_space(), H.vertical(0).right_half_space())</span>
<span class="sd">            {x = 0}</span>

<span class="sd">        We cannot form the intersection of no spaces yet::</span>

<span class="sd">            sage: H.intersection()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            NotImplementedError: the full hyperbolic space cannot be created as an intersection</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicPlane.polygon` for a specialized version for the intersection of half spaces</span>
<span class="sd">            :meth:`HyperbolicPlane.convex_hull` to compute the convex hull of subspaces</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">subsets</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span> <span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="n">subsets</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subsets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;the full hyperbolic space cannot be created as an intersection&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subsets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">subsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">unoriented</span><span class="p">()</span>

        <span class="n">half_spaces</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="p">[</span><span class="n">subset</span><span class="o">.</span><span class="n">half_spaces</span><span class="p">()</span> <span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="n">subsets</span><span class="p">],</span> <span class="n">HyperbolicHalfSpaces</span><span class="p">([])</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span>
            <span class="n">half_spaces</span><span class="p">,</span> <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">assume_minimal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span><span class="o">.</span><span class="n">unoriented</span><span class="p">()</span></div>

<div class="viewcode-block" id="HyperbolicPlane.empty_set"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane.empty_set">[docs]</a>    <span class="k">def</span> <span class="nf">empty_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an empty subset of this space.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>

<span class="sd">            sage: HyperbolicPlane().empty_set()</span>
<span class="sd">            {}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__make_element_class__</span><span class="p">(</span><span class="n">HyperbolicEmptySet</span><span class="p">)(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicPlane.isometry"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane.isometry">[docs]</a>    <span class="k">def</span> <span class="nf">isometry</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">preimage</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">,</span> <span class="n">on_right</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an isometry that maps ``preimage`` to ``image``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``preimage`` -- a convex set in the hyperbolic plane or a list of</span>
<span class="sd">          such convex sets.</span>

<span class="sd">        - ``image`` -- a convex set in the hyperbolic plane or a list of such</span>
<span class="sd">          convex sets.</span>

<span class="sd">        - ``model`` -- one of ``&quot;half_plane&quot;`` and ``&quot;klein&quot;``, the model in</span>
<span class="sd">          which this isometry applies.</span>

<span class="sd">        - ``on_right`` -- a boolean (default: ``False``); whether the returned</span>
<span class="sd">          isometry maps ``preimage`` to ``image`` when multiplied from the</span>
<span class="sd">          right; otherwise from the left.</span>

<span class="sd">        - ``normalized`` -- a boolean (default: ``False``); whether the</span>
<span class="sd">          returned matrix has determinant ±1.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        If ``model`` is ``&quot;half_plane&quot;``, returns a 2×2 matrix over the</span>
<span class="sd">        :meth:`base_ring`, if ``model`` is ``&quot;klein&quot;``, returns a 3×3 matrix</span>
<span class="sd">        over the base ring.</span>
<span class="sd">        See :meth:`HyperbolicConvexSet.apply_isometry` for meaning of this</span>
<span class="sd">        matrix.</span>

<span class="sd">        ALGORITHM:</span>

<span class="sd">        We compute an isometry with a very inefficient Gröbner basis approach.</span>

<span class="sd">        Essentially, we try to extract three points from the ``preimage`` with</span>
<span class="sd">        their prescribed images in ``image``, see :meth:`_isometry_conditions`</span>
<span class="sd">        and determine the unique isometry mapping the points by solving the</span>
<span class="sd">        corresponding polynomial system, see :meth:`_isometry_from_equations`</span>
<span class="sd">        for the hacky Gröbner basis bit.</span>

<span class="sd">        There are a lot of problems with this approach (apart from it being</span>
<span class="sd">        extremely slow.)</span>

<span class="sd">        Usually, we do not have access to meaningful points (the ideal end</span>
<span class="sd">        points of a geodesic do not typically live in the :meth:`base_ring`) so</span>
<span class="sd">        we have to map around geodesics instead. However, given two pairs of</span>
<span class="sd">        geodesics, there is in general not a unique isometry mapping one pair</span>
<span class="sd">        to the other, since there might be one isometry with positive and one</span>
<span class="sd">        with negative determinant with this property. This adds to the</span>
<span class="sd">        inefficiency because we have to try for both determinants and then</span>
<span class="sd">        check which isometry maps the actual objects in question correctly.</span>

<span class="sd">        Similarly, for more complex objects such as polygons, we do not know</span>
<span class="sd">        a-priori which edge of the preimage polygon can be mapped to which edge</span>
<span class="sd">        of the image polygon, so we have to try for all rotations of both</span>
<span class="sd">        polygons.</span>

<span class="sd">        Finally, the approach cannot work in general for certain</span>
<span class="sd">        undeterdetermined systems. We do not know how to determine an isometry</span>
<span class="sd">        that maps one geodesic to another geodesic. We can of course try to</span>
<span class="sd">        write down an isometry that maps a geodesic to the vertical at 0 but in</span>
<span class="sd">        general no such isometry is defined over the base ring. We can make the</span>
<span class="sd">        system determined by requiring that the midpoints of the geodesics map</span>
<span class="sd">        to each other but (apart from the midpoint not having coordinates in</span>
<span class="sd">        the base ring) that isometry might not be defined over the base ring</span>
<span class="sd">        even though there exists some isometry that maps the geodesics over the</span>
<span class="sd">        base ring.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        An isometry mapping one point to another; naturally this is not the</span>
<span class="sd">        unique isometry with this property::</span>

<span class="sd">            sage: m = H.isometry(0, 1)</span>
<span class="sd">            sage: H(0).apply_isometry(m)</span>
<span class="sd">            1</span>
<span class="sd">            sage: m</span>
<span class="sd">            [1 1]</span>
<span class="sd">            [0 1]</span>

<span class="sd">        ::</span>

<span class="sd">            sage: H.isometry(I, I+1)</span>
<span class="sd">            [1 1]</span>
<span class="sd">            [0 1]</span>
<span class="sd">            sage: H.isometry(0, oo)</span>
<span class="sd">            [ 0 -1]</span>
<span class="sd">            [-1  0]</span>

<span class="sd">        An isometry is uniquely determined by its image on three points::</span>

<span class="sd">            sage: H.isometry([0, 1, oo], [1, oo, 0])</span>
<span class="sd">            [ 0  1]</span>
<span class="sd">            [-1  1]</span>

<span class="sd">        It might be impossible to find an isometry with the prescribed mapping::</span>

<span class="sd">            sage: H.isometry(0, I)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: no isometry can map these objects to each other</span>

<span class="sd">            sage: H.isometry([0, 1, oo, I], [0, 1, oo, I + 1])  # long time (.4s)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: no isometry can map these objects to each other</span>

<span class="sd">        We can determine isometries by mapping more complex objects than</span>
<span class="sd">        points, e.g., geodesics::</span>

<span class="sd">            sage: H.isometry(H.geodesic(-1, 1), H.geodesic(1, -1))</span>
<span class="sd">            [ 0  1]</span>
<span class="sd">            [-1  0]</span>

<span class="sd">        We can also determine an isometry mapping polygons::</span>

<span class="sd">            sage: P = H.polygon([H.vertical(1).left_half_space(), H.vertical(-1).right_half_space(), H.geodesic(-1, 1).left_half_space()])</span>
<span class="sd">            sage: Q = H.polygon([H.geodesic(-1, 0).left_half_space(), H.geodesic(0, 1).left_half_space(), H.geodesic(1, -1).left_half_space()])</span>
<span class="sd">            sage: m = H.isometry(P, Q)</span>
<span class="sd">            sage: P.apply_isometry(m) == Q</span>
<span class="sd">            True</span>

<span class="sd">        When determining an isometry of polygons, marked vertices are mapped to</span>
<span class="sd">        marked vertices::</span>

<span class="sd">            sage: P = H.polygon(P.half_spaces(), marked_vertices=[1 + I])</span>
<span class="sd">            sage: Q = H.polygon(P.half_spaces(), marked_vertices=[])</span>
<span class="sd">            sage: H.isometry(P, Q)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: no isometry can map these objects to each other</span>

<span class="sd">            sage: Q = H.polygon(P.half_spaces(), marked_vertices=[1 + 2*I])</span>
<span class="sd">            sage: H.isometry(P, Q)  # long time (1s)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: no isometry can map these objects to each other</span>

<span class="sd">            sage: Q = H.polygon(P.half_spaces(), marked_vertices=[-1 + I])</span>
<span class="sd">            sage: H.isometry(P, Q)  # long time (1s)</span>
<span class="sd">            [ 1  0]</span>
<span class="sd">            [ 0 -1]</span>

<span class="sd">        We can explicitly ask for an isometry in the Klein model, given by a</span>
<span class="sd">        3×3 matrix::</span>

<span class="sd">            sage: H.isometry(P, Q, model=&quot;klein&quot;)  # long time (1s)</span>
<span class="sd">            [-1  0  0]</span>
<span class="sd">            [ 0  1  0]</span>
<span class="sd">            [ 0  0  1]</span>

<span class="sd">        The isometries are not returned as matrices of unit determinant since</span>
<span class="sd">        such an isometry might not exist without extending the base ring, we</span>
<span class="sd">        can, however, ask for an isometry of determinant ±1::</span>

<span class="sd">            sage: H.isometry(I, 2*I, normalized=True)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: not a perfect 2nd power</span>

<span class="sd">            sage: H.change_ring(AA).isometry(I, 2*I, normalized=True)</span>
<span class="sd">            [ 1.414213562373095?                   0]</span>
<span class="sd">            [                  0 0.7071067811865475?]</span>

<span class="sd">            sage: _.det()</span>
<span class="sd">            1.000000000000000?</span>

<span class="sd">        We can also explicitly ask for the isometry for the right action::</span>

<span class="sd">            sage: isometry = H.isometry(H.vertical(0), H.vertical(1), on_right=True)</span>
<span class="sd">            sage: isometry</span>
<span class="sd">            [ 1 -1]</span>
<span class="sd">            [ 0  1]</span>
<span class="sd">            sage: H.vertical(0).apply_isometry(isometry)</span>
<span class="sd">            {-x - 1 = 0}</span>
<span class="sd">            sage: H.vertical(0).apply_isometry(isometry, on_right=True)</span>
<span class="sd">            {-x + 1 = 0}</span>

<span class="sd">        TESTS:</span>

<span class="sd">        Points forming an ideal triangle with three ideal vertices::</span>

<span class="sd">            sage: preimage = H(-1), H(0), H(1)</span>
<span class="sd">            sage: image = H(0), H(1), H(2)</span>
<span class="sd">            sage: H.isometry(preimage, image, on_right=True)</span>
<span class="sd">            [ 1 -1]</span>
<span class="sd">            [ 0  1]</span>

<span class="sd">        Points forming an ideal triangle with two ideal vertices::</span>

<span class="sd">            sage: preimage = H(-1), H(2*I), H(1)</span>
<span class="sd">            sage: image = H(0), H(1 + 2*I), H(2)</span>
<span class="sd">            sage: H.isometry(preimage, image, on_right=True)</span>
<span class="sd">            [ 1 -1]</span>
<span class="sd">            [ 0  1]</span>

<span class="sd">        Points forming an ideal triangle with one ideal vertex::</span>

<span class="sd">            sage: preimage = H(I - 1), H(I + 1), H(oo)</span>
<span class="sd">            sage: image = H(I), H(I + 2), H(oo)</span>
<span class="sd">            sage: H.isometry(preimage, image, on_right=True)</span>
<span class="sd">            [ 1 -1]</span>
<span class="sd">            [ 0  1]</span>

<span class="sd">        Points forming a finite triangle::</span>

<span class="sd">            sage: preimage = H(I), H(2*I), H(2*I + 1)</span>
<span class="sd">            sage: image = H(I + 1), H(2*I + 1), H(2*I + 2)</span>
<span class="sd">            sage: H.isometry(preimage, image, on_right=True)</span>
<span class="sd">            [ 1 -1]</span>
<span class="sd">            [ 0  1]</span>

<span class="sd">        Points forming a degenerate ideal triangle::</span>

<span class="sd">            sage: preimage = H(-1), H(I), H(1)</span>
<span class="sd">            sage: image = H(0), H(I + 1), H(2)</span>
<span class="sd">            sage: H.isometry(preimage, image, on_right=True)</span>
<span class="sd">            [ 1 -1]</span>
<span class="sd">            [ 0  1]</span>

<span class="sd">        Another degenerate ideal triangle::</span>

<span class="sd">            sage: preimage = H(0), H(I), H(oo)</span>
<span class="sd">            sage: image = H(1), H(I + 1), H(oo)</span>
<span class="sd">            sage: H.isometry(preimage, image, on_right=True)</span>
<span class="sd">            [ 1 -1]</span>
<span class="sd">            [ 0  1]</span>

<span class="sd">        Points forming a finite degenerate triangle::</span>

<span class="sd">            sage: preimage = H(I), H(2*I), H(3*I)</span>
<span class="sd">            sage: image = H(I + 1), H(2*I + 1), H(3*I + 1)</span>
<span class="sd">            sage: H.isometry(preimage, image, on_right=True)</span>
<span class="sd">            [ 1 -1]</span>
<span class="sd">            [ 0  1]</span>

<span class="sd">        Impossible pairs of points (ideal and non-ideal) are detected::</span>

<span class="sd">            sage: preimage = H(-1), H(I), H(1)</span>
<span class="sd">            sage: image = H(0), H(1), H(2)</span>
<span class="sd">            sage: H.isometry(preimage, image)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: no isometry can map these objects to each other</span>

<span class="sd">            sage: preimage = H(0), H(1), H(2)</span>
<span class="sd">            sage: image = H(-1), H(I), H(1)</span>
<span class="sd">            sage: H.isometry(preimage, image)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: no isometry can map these objects to each other</span>

<span class="sd">        A case with d=0::</span>

<span class="sd">            sage: preimage = (H.geodesic(0, 1), H.geodesic(1, oo))</span>
<span class="sd">            sage: image = (H.geodesic(1, oo), H.geodesic(oo, 0))</span>
<span class="sd">            sage: H.isometry(preimage, image, on_right=True)</span>
<span class="sd">            [ 1 -1]</span>
<span class="sd">            [ 1  0]</span>

<span class="sd">        A case with no solution, such an isometry would map four ideal points</span>
<span class="sd">        in an impossible way::</span>

<span class="sd">            sage: preimage = (H.geodesic(0, 1), H.geodesic(2, 3))</span>
<span class="sd">            sage: image = (H.geodesic(0, 1), H.geodesic(3, 4))</span>
<span class="sd">            sage: H.isometry(preimage, image, on_right=True)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: no isometry can map these objects to each other</span>

<span class="sd">        An isometry that swaps end points but maps the corresponding oriented</span>
<span class="sd">        geodesics to themselves::</span>

<span class="sd">            sage: preimage = (-1, 1, -2, 2)</span>
<span class="sd">            sage: image = (1, -1, 2, -2)</span>
<span class="sd">            sage: H.isometry(preimage, image, on_right=True)</span>
<span class="sd">            [-1  0]</span>
<span class="sd">            [ 0  1]</span>

<span class="sd">        An example with negative determinant::</span>

<span class="sd">            sage: preimage = (I - 1, I + 1, I - 2, I + 2)</span>
<span class="sd">            sage: image = (I + 1, I - 1, I + 2, I - 2)</span>
<span class="sd">            sage: H.isometry(preimage, image, on_right=True)</span>
<span class="sd">            [-1  0]</span>
<span class="sd">            [ 0  1]</span>

<span class="sd">        A case that could initially not be solved over the rationals::</span>

<span class="sd">            sage: H.isometry((58*I, I + 1), (116*I - 1, 2*I + 1))</span>
<span class="sd">            [ 2 -1]</span>
<span class="sd">            [ 0  1]</span>

<span class="sd">        A case that caused problems at some point::</span>

<span class="sd">            sage: isometry = matrix([[1, 0], [0, -1/2]])</span>
<span class="sd">            sage: x = H(I/2 - 1)</span>
<span class="sd">            sage: y = H(I/3 - 1)</span>
<span class="sd">            sage: z = H(5/19 * I - 1/3)</span>
<span class="sd">            sage: H.isometry((x, y, z), (x.apply_isometry(isometry), y.apply_isometry(isometry), z.apply_isometry(isometry)))  # long time (.3s)</span>
<span class="sd">            [-2  0]</span>
<span class="sd">            [ 0  1]</span>

<span class="sd">        ::</span>

<span class="sd">            sage: preimage = (I - 1, I + 1, I + 1, oo)</span>
<span class="sd">            sage: image = (I, I + 2, I + 2, oo)</span>
<span class="sd">            sage: H.isometry(preimage, image, on_right=True)</span>
<span class="sd">            [ 1 -1]</span>
<span class="sd">            [ 0  1]</span>

<span class="sd">        ::</span>

<span class="sd">            sage: preimage = (H.geodesic(I - 1, I + 1), H.geodesic(I - 2, I + 1))</span>
<span class="sd">            sage: image = (H.geodesic(I + 1, I - 1), H.geodesic(I + 1, I - 2))</span>
<span class="sd">            sage: H.isometry(preimage, image, on_right=True)</span>
<span class="sd">            [-1  2]</span>
<span class="sd">            [-1  1]</span>

<span class="sd">        ::</span>

<span class="sd">            sage: isometry = matrix([[2, 0], [1, 2]])</span>
<span class="sd">            sage: x = H(0)</span>
<span class="sd">            sage: y = H(I/2 - 1)</span>
<span class="sd">            sage: z = H(0)</span>
<span class="sd">            sage: H.isometry((x, y, z), (x.apply_isometry(isometry), y.apply_isometry(isometry), z.apply_isometry(isometry)))</span>
<span class="sd">            [  1   0]</span>
<span class="sd">            [1/2   1]</span>

<span class="sd">        ::</span>

<span class="sd">            sage: H.isometry(I, 2*I)</span>
<span class="sd">            [  1   0]</span>
<span class="sd">            [  0 1/2]</span>

<span class="sd">        An underdetermined case::</span>

<span class="sd">            sage: P = H.geodesic(126, 4447, 6387, model=&quot;half_plane&quot;).right_half_space()</span>
<span class="sd">            sage: isometry = matrix([[-1, 2], [2, -1/2]])</span>
<span class="sd">            sage: Q = P.apply_isometry(isometry)</span>
<span class="sd">            sage: H.isometry(P, Q)</span>
<span class="sd">            [  126/8579 -4321/8579]</span>
<span class="sd">            [         0          1]</span>

<span class="sd">        Here, there is also an isometry of negative determinant that maps some</span>
<span class="sd">        of the half spaces correctly::</span>

<span class="sd">            sage: P = H.polygon([</span>
<span class="sd">            ....:    H.geodesic(1, -5, 5, model=&quot;half_plane&quot;).left_half_space(),</span>
<span class="sd">            ....:    H.geodesic(247, -957, -5156, model=&quot;half_plane&quot;).right_half_space(),</span>
<span class="sd">            ....:    H.geodesic(1, -120, -137, model=&quot;half_plane&quot;).right_half_space()])</span>
<span class="sd">            sage: isometry = matrix([[0, -2], [1, 2]])</span>
<span class="sd">            sage: Q = P.apply_isometry(isometry)</span>
<span class="sd">            sage: H.isometry(P, Q)  # long time (.4s)</span>
<span class="sd">            [  0  -1]</span>
<span class="sd">            [1/2   1]</span>

<span class="sd">        An isometry mapping unoriented segments, though not the most apparent</span>
<span class="sd">        one::</span>

<span class="sd">            sage: H.isometry(H(I).segment(2*I).unoriented(), H(2*I).segment(I).unoriented())</span>
<span class="sd">            [  0  -1]</span>
<span class="sd">            [1/2   0]</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicConvexSet.apply_isometry` to apply the returned</span>
<span class="sd">            isometry to a convex set.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">normalized</span><span class="p">:</span>
            <span class="n">isometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isometry</span><span class="p">(</span>
                <span class="n">preimage</span><span class="o">=</span><span class="n">preimage</span><span class="p">,</span>
                <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span>
                <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
                <span class="n">on_right</span><span class="o">=</span><span class="n">on_right</span><span class="p">,</span>
                <span class="n">normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">det</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">isometry</span><span class="o">.</span><span class="n">det</span><span class="p">())</span>
            <span class="n">λ</span> <span class="o">=</span> <span class="n">det</span><span class="o">.</span><span class="n">nth_root</span><span class="p">(</span><span class="n">isometry</span><span class="o">.</span><span class="n">nrows</span><span class="p">())</span>
            <span class="k">return</span> <span class="o">~</span><span class="n">λ</span> <span class="o">*</span> <span class="n">isometry</span>

        <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s2">&quot;klein&quot;</span><span class="p">:</span>
            <span class="n">isometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isometry</span><span class="p">(</span>
                <span class="n">preimage</span><span class="o">=</span><span class="n">preimage</span><span class="p">,</span>
                <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span>
                <span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">,</span>
                <span class="n">on_right</span><span class="o">=</span><span class="n">on_right</span><span class="p">,</span>
                <span class="n">normalized</span><span class="o">=</span><span class="n">normalized</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isometry_gl2_to_sim12</span><span class="p">(</span><span class="n">isometry</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">model</span> <span class="o">!=</span> <span class="s2">&quot;half_plane&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;unsupported model&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">on_right</span><span class="p">:</span>
            <span class="n">isometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isometry</span><span class="p">(</span>
                <span class="n">preimage</span><span class="o">=</span><span class="n">preimage</span><span class="p">,</span>
                <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span>
                <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
                <span class="n">on_right</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">normalized</span><span class="o">=</span><span class="n">normalized</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s2">&quot;half_plane&quot;</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">matrix</span>

                <span class="c1"># Pick a nice representative of the inverse matrix.</span>
                <span class="n">isometry</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="p">[</span><span class="n">isometry</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">isometry</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span>
                        <span class="p">[</span><span class="o">-</span><span class="n">isometry</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">isometry</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">isometry</span> <span class="o">=</span> <span class="o">~</span><span class="n">isometry</span>

            <span class="k">return</span> <span class="n">isometry</span>

        <span class="c1"># Normalize the arguments so that they are a list of convex sets.</span>
        <span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">preimage</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">preimage</span> <span class="o">=</span> <span class="p">[</span><span class="n">preimage</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="n">image</span><span class="p">]</span>

        <span class="n">preimage</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">preimage</span><span class="p">]</span>
        <span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">image</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">preimage</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;preimage and image must be the same size to determine an isometry between them&quot;</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">preimage</span><span class="p">,</span> <span class="n">image</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">dimension</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;preimage and image must be of the same dimensions to determine an isometry between them&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">()</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;preimage and image must be oriented or unoriented consistently&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Drop empty sets from the preimage and image to make our lives easier</span>
        <span class="n">preimage</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">preimage</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">image</span> <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># An isometry is uniquely determined by mapping three points.</span>
        <span class="c1"># In principle, we now just need to find three points in preimage, find</span>
        <span class="c1"># their corresponding images, construct the isometry, and then check</span>
        <span class="c1"># that it maps everything correctly.</span>
        <span class="c1"># However, there are objects that do not really define a mapping of</span>
        <span class="c1"># points. For example, when presented with an unoriented geodesic, we</span>
        <span class="c1"># can map its endpoints two possible ways (apart from that, an isometry</span>
        <span class="c1"># can swap the end points of a geodesic but map an oriented geodesic to</span>
        <span class="c1"># itself at the same time.) Similarly, when mapping a polygon, we can</span>
        <span class="c1"># permute the edges cyclically.</span>

        <span class="c1"># We need a mild form of backtracking to collect all possible triples</span>
        <span class="c1"># that define the isometry.</span>
        <span class="n">isometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isometry_from_pairs</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">preimage</span><span class="p">,</span> <span class="n">image</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">isometry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no isometry can map these objects to each other&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">isometry</span></div>

<div class="viewcode-block" id="HyperbolicPlane._isometry_gl2_to_sim12"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane._isometry_gl2_to_sim12">[docs]</a>    <span class="k">def</span> <span class="nf">_isometry_gl2_to_sim12</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">isometry</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a lift of the ``isometry`` to a 3×3 matrix in the similitude</span>
<span class="sd">        group `\mathrm{Sim}(1, 2)` describing an isometry in hyperboloid</span>
<span class="sd">        model.</span>

<span class="sd">        This is a helper method for :meth:`isometry` and</span>
<span class="sd">        :meth:`HyperbolicConvexSet.apply_isometry` since isometries in the</span>
<span class="sd">        hyperboloid model can be directly applied to our objects which we</span>
<span class="sd">        represent in the Klein model.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``isometry`` -- a 2×2 matrix with non-zero determinant</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H._isometry_gl2_to_sim12(matrix(2, [1,1,0,1]))</span>
<span class="sd">            [   1   -1    1]</span>
<span class="sd">            [   1  1/2  1/2]</span>
<span class="sd">            [   1 -1/2  3/2]</span>
<span class="sd">            sage: H._isometry_gl2_to_sim12(matrix(2, [1,0,1,1]))</span>
<span class="sd">            [   1    1    1]</span>
<span class="sd">            [  -1  1/2 -1/2]</span>
<span class="sd">            [   1  1/2  3/2]</span>
<span class="sd">            sage: H._isometry_gl2_to_sim12(matrix(2, [2,0,0,1/2]))</span>
<span class="sd">            [   1    0    0]</span>
<span class="sd">            [   0 17/8 15/8]</span>
<span class="sd">            [   0 15/8 17/8]</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`_isometry_sim12_to_gl2` for an inverse of this construction</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.matrix.constructor</span> <span class="kn">import</span> <span class="n">matrix</span>

        <span class="k">if</span> <span class="n">isometry</span><span class="o">.</span><span class="n">dimensions</span><span class="p">()</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;matrix does not encode an isometry in the half plane model&quot;</span>
            <span class="p">)</span>

        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">isometry</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">matrix</span><span class="p">(</span>
            <span class="mi">3</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="n">a</span> <span class="o">*</span> <span class="n">d</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span><span class="p">,</span>
                <span class="n">a</span> <span class="o">*</span> <span class="n">c</span> <span class="o">-</span> <span class="n">b</span> <span class="o">*</span> <span class="n">d</span><span class="p">,</span>
                <span class="n">a</span> <span class="o">*</span> <span class="n">c</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">d</span><span class="p">,</span>
                <span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">c</span> <span class="o">*</span> <span class="n">d</span><span class="p">,</span>
                <span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">c</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">d</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                <span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">c</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">d</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                <span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">d</span><span class="p">,</span>
                <span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">d</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                <span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">d</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
            <span class="p">],</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicPlane._isometry_sim12_to_gl2"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane._isometry_sim12_to_gl2">[docs]</a>    <span class="k">def</span> <span class="nf">_isometry_sim12_to_gl2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">isometry</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an invertible 2×2 matrix that encodes the same isometry as</span>
<span class="sd">        ``isometry``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``isometry`` -- a 3×3 matrix in `\mathrm{Sim}(1, 2)`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H._isometry_sim12_to_gl2(matrix(3, [1, -1, 1, 1, 1/2, 1/2, 1, -1/2, 3/2]))</span>
<span class="sd">            [1 1]</span>
<span class="sd">            [0 1]</span>

<span class="sd">            sage: H._isometry_sim12_to_gl2(matrix(3, [1, 1, 1, -1, 1/2, -1/2, 1, 1/2, 3/2]))</span>
<span class="sd">            [1 0]</span>
<span class="sd">            [1 1]</span>

<span class="sd">            sage: H._isometry_sim12_to_gl2(matrix(3, [1, 0, 0, 0, 17/8, 15/8, 0, 15/8, 17/8]))</span>
<span class="sd">            [  2   0]</span>
<span class="sd">            [  0 1/2]</span>

<span class="sd">            sage: H._isometry_sim12_to_gl2(H._isometry_gl2_to_sim12(matrix([[-1, 0], [0, 1]])))</span>
<span class="sd">            [ 1  0]</span>
<span class="sd">            [ 0 -1]</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`_isometry_gl2_to_sim12` for an inverse of this construction</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.matrix.constructor</span> <span class="kn">import</span> <span class="n">matrix</span>

        <span class="k">if</span> <span class="n">isometry</span><span class="o">.</span><span class="n">dimensions</span><span class="p">()</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;matrix does not encode an isometry in the Klein model&quot;</span><span class="p">)</span>

        <span class="n">m00</span><span class="p">,</span> <span class="n">m01</span><span class="p">,</span> <span class="n">m02</span><span class="p">,</span> <span class="n">m10</span><span class="p">,</span> <span class="n">m11</span><span class="p">,</span> <span class="n">m12</span><span class="p">,</span> <span class="n">m20</span><span class="p">,</span> <span class="n">m21</span><span class="p">,</span> <span class="n">m22</span> <span class="o">=</span> <span class="n">isometry</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">isometry</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>
        <span class="n">two</span> <span class="o">=</span> <span class="n">K</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">so12_det</span> <span class="o">=</span> <span class="n">isometry</span><span class="o">.</span><span class="n">determinant</span><span class="p">()</span>
        <span class="n">sl2_det</span> <span class="o">=</span> <span class="n">so12_det</span><span class="o">.</span><span class="n">nth_root</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">so12_det</span><span class="o">.</span><span class="n">sign</span><span class="p">()</span> <span class="o">!=</span> <span class="n">sl2_det</span><span class="o">.</span><span class="n">sign</span><span class="p">():</span>
            <span class="n">sl2_det</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">a2</span> <span class="o">=</span> <span class="p">(</span><span class="n">m12</span> <span class="o">+</span> <span class="n">m22</span> <span class="o">+</span> <span class="n">m21</span> <span class="o">+</span> <span class="n">m11</span><span class="p">)</span> <span class="o">/</span> <span class="n">two</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="p">(</span><span class="n">m12</span> <span class="o">+</span> <span class="n">m22</span> <span class="o">-</span> <span class="n">m21</span> <span class="o">-</span> <span class="n">m11</span><span class="p">)</span> <span class="o">/</span> <span class="n">two</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="p">(</span><span class="n">m21</span> <span class="o">+</span> <span class="n">m22</span> <span class="o">-</span> <span class="n">m12</span> <span class="o">-</span> <span class="n">m11</span><span class="p">)</span> <span class="o">/</span> <span class="n">two</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="p">(</span><span class="n">m11</span> <span class="o">+</span> <span class="n">m22</span> <span class="o">-</span> <span class="n">m12</span> <span class="o">-</span> <span class="n">m21</span><span class="p">)</span> <span class="o">/</span> <span class="n">two</span>

        <span class="n">ab</span> <span class="o">=</span> <span class="p">(</span><span class="n">m10</span> <span class="o">+</span> <span class="n">m20</span><span class="p">)</span> <span class="o">/</span> <span class="n">two</span>
        <span class="n">ac</span> <span class="o">=</span> <span class="p">(</span><span class="n">m01</span> <span class="o">+</span> <span class="n">m02</span><span class="p">)</span> <span class="o">/</span> <span class="n">two</span>
        <span class="n">ad</span> <span class="o">=</span> <span class="p">(</span><span class="n">m00</span> <span class="o">+</span> <span class="n">sl2_det</span><span class="p">)</span> <span class="o">/</span> <span class="n">two</span>
        <span class="n">bc</span> <span class="o">=</span> <span class="p">(</span><span class="n">m00</span> <span class="o">-</span> <span class="n">sl2_det</span><span class="p">)</span> <span class="o">/</span> <span class="n">two</span>
        <span class="n">bd</span> <span class="o">=</span> <span class="p">(</span><span class="n">m02</span> <span class="o">-</span> <span class="n">m01</span><span class="p">)</span> <span class="o">/</span> <span class="n">two</span>
        <span class="n">cd</span> <span class="o">=</span> <span class="p">(</span><span class="n">m20</span> <span class="o">-</span> <span class="n">m10</span><span class="p">)</span> <span class="o">/</span> <span class="n">two</span>

        <span class="c1"># we recover +/- a taking square roots</span>
        <span class="n">pm_a</span> <span class="o">=</span> <span class="n">a2</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
        <span class="n">pm_b</span> <span class="o">=</span> <span class="n">b2</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
        <span class="n">pm_c</span> <span class="o">=</span> <span class="n">c2</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
        <span class="n">pm_d</span> <span class="o">=</span> <span class="n">d2</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>

        <span class="c1"># We could do something less naive as there is no need to iterate</span>
        <span class="kn">import</span> <span class="nn">itertools</span>

        <span class="k">for</span> <span class="n">sa</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">sd</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">sa</span> <span class="o">*</span> <span class="n">pm_a</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">sb</span> <span class="o">*</span> <span class="n">pm_b</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">sc</span> <span class="o">*</span> <span class="n">pm_c</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">sd</span> <span class="o">*</span> <span class="n">pm_d</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="o">==</span> <span class="n">ab</span>
                <span class="ow">and</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span> <span class="o">==</span> <span class="n">ac</span>
                <span class="ow">and</span> <span class="n">a</span> <span class="o">*</span> <span class="n">d</span> <span class="o">==</span> <span class="n">ad</span>
                <span class="ow">and</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span> <span class="o">==</span> <span class="n">bc</span>
                <span class="ow">and</span> <span class="n">b</span> <span class="o">*</span> <span class="n">d</span> <span class="o">==</span> <span class="n">bd</span>
                <span class="ow">and</span> <span class="n">c</span> <span class="o">*</span> <span class="n">d</span> <span class="o">==</span> <span class="n">cd</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="n">matrix</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no projection to GL(2, R) in the base ring&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_isometry_from_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pairs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a right isometry compatible with given (preimage, image) pairs.</span>

<span class="sd">        This is helper method for :meth:`isometry`.</span>

<span class="sd">        ALGORITHM:</span>

<span class="sd">        We extract pairs of primitive elements (points and geodesics) from</span>
<span class="sd">        ``pairs`` that necessarily need to map to each other for the mappings</span>
<span class="sd">        in ``pairs`` to be satisfied. (Based on the idea that there is only one</span>
<span class="sd">        isometry mapping three points in a prescribed way.) For these pairs of</span>
<span class="sd">        primitive elements, we determine the isometries mapping them (there</span>
<span class="sd">        might be more than one when we cannot extract three points) and check</span>
<span class="sd">        whether they map all ``pairs`` correctly.</span>

<span class="sd">        There is a bit of backtracking needed in :meth:`_isometry_conditions`</span>
<span class="sd">        since, e.g., there is no a unique isometry mapping two polygons to each</span>
<span class="sd">        other since we can, e.g., permute the edges of the polygon cyclically.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``pairs`` -- a sequence of pairs of hyperbolic sets</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H._isometry_from_pairs([(H(0), H(1)), (H(1), H(2)), (H(2), H(3))])</span>
<span class="sd">            [ 1 -1]</span>
<span class="sd">            [ 0  1]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">conditions</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isometry_conditions</span><span class="p">([],</span> <span class="n">pairs</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">isometry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isometry_from_primitives</span><span class="p">(</span><span class="n">conditions</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">isometry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
                    <span class="n">preimage</span><span class="o">.</span><span class="n">apply_isometry</span><span class="p">(</span><span class="n">isometry</span><span class="p">,</span> <span class="n">on_right</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">!=</span> <span class="n">image</span>
                    <span class="k">for</span> <span class="p">(</span><span class="n">preimage</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pairs</span>
                <span class="p">):</span>
                    <span class="k">continue</span>

                <span class="k">return</span> <span class="n">isometry</span>

        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_isometry_from_primitives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pairs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method for :meth:`isometry`.</span>

<span class="sd">        Return right isometries as 2x2 matrices that maps the elements of</span>
<span class="sd">        ``pairs`` to each other.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``pairs`` -- a sequence of pairs of geodesics or hyperbolic points</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        An iterator of matrices, see below.</span>

<span class="sd">        ALGORITHM:</span>

<span class="sd">        If ``pairs`` is a single pair of points, we construct an isometry with</span>
<span class="sd">        :meth:`_isometry_from_single_points`.</span>

<span class="sd">        If ``pairs`` is a single pair of geodesics, we make an attempt to</span>
<span class="sd">        construct an isometry with :meth:`_isometry_from_single_geodesics`.</span>

<span class="sd">        Otherwise, ``pairs`` up to three pairs of points and geodesics. These</span>
<span class="sd">        do not always uniquely define an isometry, e.g., often when presented</span>
<span class="sd">        with two geodesics. Namely, there could be one isometry of positive</span>
<span class="sd">        determinant and one isometry of negative determinant. We return both of</span>
<span class="sd">        them.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        An underdetermined system. Here we are lucky, the midpoint of the</span>
<span class="sd">        geodesics has coordinates in the base ring and the isometry mapping</span>
<span class="sd">        midpoints to each other is defined over the base ring::</span>

<span class="sd">            sage: preimage = H.geodesic(-126, -4447, -6387, model=&quot;half_plane&quot;)</span>
<span class="sd">            sage: image = H.geodesic(-8579, -13089, -4510, model=&quot;half_plane&quot;)</span>
<span class="sd">            sage: list(H._isometry_from_primitives([(preimage, image)]))</span>
<span class="sd">            [</span>
<span class="sd">            [        1 4321/8579]</span>
<span class="sd">            [        0  126/8579]</span>
<span class="sd">            ]</span>

<span class="sd">        Here, a non-trivial isometry maps these oriented geodesics to</span>
<span class="sd">        themselves, i.e., it stabilizes what&#39;s to the left of the geodesics::</span>

<span class="sd">           sage: g = H.geodesic(-1, 1)</span>
<span class="sd">           sage: h = H.geodesic(-2, 2)</span>
<span class="sd">           sage: g.apply_isometry(matrix([[-1, 0], [0, 1]])) == g</span>
<span class="sd">           True</span>
<span class="sd">           sage: h.apply_isometry(matrix([[-1, 0], [0, 1]])) == h</span>
<span class="sd">           True</span>
<span class="sd">           sage: list(H._isometry_from_primitives([(g, g), (h, h)]))</span>
<span class="sd">           [</span>
<span class="sd">           [1 0]  [-1  0]</span>
<span class="sd">           [0 1], [ 0  1]</span>
<span class="sd">           ]</span>

<span class="sd">        Note that that isometry swaps endpoints though::</span>

<span class="sd">            sage: H(-1).apply_isometry(matrix([[-1, 0], [0, 1]]))</span>
<span class="sd">            1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">matrix</span>

            <span class="k">yield</span> <span class="n">matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">(),</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isometry_from_single_points</span><span class="p">(</span><span class="n">pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isometry_from_single_geodesics</span><span class="p">(</span><span class="n">pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span>

        <span class="c1"># Create polynomial equations that must be satisfied to map the pairs</span>
        <span class="c1"># to each other.</span>
        <span class="k">def</span> <span class="nf">equations</span><span class="p">(</span><span class="n">isometry</span><span class="p">,</span> <span class="n">λ</span><span class="p">):</span>
            <span class="n">equations</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">preimage</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pairs</span><span class="p">):</span>
                <span class="n">equations</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">preimage</span><span class="o">.</span><span class="n">_isometry_equations</span><span class="p">(</span><span class="n">isometry</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">λ</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

            <span class="k">return</span> <span class="n">equations</span>

        <span class="c1"># Create a predicate that can be used to check whether the isometry</span>
        <span class="c1"># correctly maps the pairs.</span>
        <span class="k">def</span> <span class="nf">create_filter</span><span class="p">(</span><span class="n">det</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="n">isometry</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">isometry</span><span class="o">.</span><span class="n">det</span><span class="p">()</span><span class="o">.</span><span class="n">sign</span><span class="p">()</span> <span class="o">!=</span> <span class="n">det</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">preimage</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">preimage</span><span class="o">.</span><span class="n">apply_isometry</span><span class="p">(</span><span class="n">isometry</span><span class="p">,</span> <span class="n">on_right</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">!=</span> <span class="n">image</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span>
                <span class="k">return</span> <span class="kc">True</span>

            <span class="k">return</span> <span class="nb">filter</span>

        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isometry_from_equations</span><span class="p">(</span><span class="n">equations</span><span class="p">,</span> <span class="n">create_filter</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isometry_from_equations</span><span class="p">(</span><span class="n">equations</span><span class="p">,</span> <span class="n">create_filter</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_isometry_untrivialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">preimage</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">defining</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method for :meth:`isometry`.</span>

<span class="sd">        Return a pair of hyperbolic objects that describe the mapping of</span>
<span class="sd">        ``preimage`` to ``image`` or return ``None`` if that mapping is already</span>
<span class="sd">        captured by the pairs of objects in ``defining``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H._isometry_untrivialize(H(I), H(I), [])</span>
<span class="sd">            (I, I)</span>

<span class="sd">        There are many ways to map the geodesic between -1 and 1 to itself.</span>
<span class="sd">        Knowing that we need to fix `I` adds information::</span>

<span class="sd">            sage: H._isometry_untrivialize(H(I), H(I), [(H.geodesic(-1, 1), H.geodesic(-1, 1))])</span>
<span class="sd">            (I, I)</span>

<span class="sd">        However, we already know that ``-1`` must go to ``-1``. Well, actually</span>
<span class="sd">        that&#39;s not true, we could also be swapping the endpoints otherwise but</span>
<span class="sd">        we want to use this to build three conditions that are independent</span>
<span class="sd">        (this could probably be improved)::</span>

<span class="sd">            sage: H._isometry_untrivialize(H(-1), H(-1), [(H.geodesic(-1, 1), H.geodesic(-1, 1))]) is None</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">existings</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">defining</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">preimage</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">preimage</span> <span class="ow">in</span> <span class="n">existings</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">preimage</span><span class="o">.</span><span class="n">is_ideal</span><span class="p">():</span>
                <span class="c1"># Actually, an ideal point is not trivial if the existing</span>
                <span class="c1"># geodesic is unoriented. But it does not take a full</span>
                <span class="c1"># degree of freedom away, so we ignore it here.</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">preimage</span> <span class="ow">in</span> <span class="n">existing</span> <span class="k">for</span> <span class="n">existing</span> <span class="ow">in</span> <span class="n">existings</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">preimage</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">preimage</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">preimage</span><span class="o">.</span><span class="n">unoriented</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="n">existing</span><span class="o">.</span><span class="n">unoriented</span><span class="p">()</span> <span class="k">for</span> <span class="n">existing</span> <span class="ow">in</span> <span class="n">existings</span>
            <span class="p">]:</span>
                <span class="c1"># Again, we ignore the distinction between oriented and</span>
                <span class="c1"># unoriented geodesics here.</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">preimage</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="ow">in</span> <span class="n">existings</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isometry_untrivialize</span><span class="p">(</span>
                    <span class="n">preimage</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">image</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">defining</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">preimage</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="ow">in</span> <span class="n">existings</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isometry_untrivialize</span><span class="p">(</span>
                    <span class="n">preimage</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">image</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">defining</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">preimage</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

<div class="viewcode-block" id="HyperbolicPlane._isometry_conditions"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane._isometry_conditions">[docs]</a>    <span class="k">def</span> <span class="nf">_isometry_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">defining</span><span class="p">,</span> <span class="n">remaining</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method for :meth:`isometry`.</span>

<span class="sd">        Return sequences (typically triples) of pairs of hyperbolic primitive</span>
<span class="sd">        objects (geodesics and points) that (almost) uniquely define a</span>
<span class="sd">        hyperbolic mapping.</span>

<span class="sd">        Build this sequence by extending ``defining`` with conditions extracted</span>
<span class="sd">        from ``remaining``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        Given four points, three points already uniquely determine the isometry::</span>

<span class="sd">            sage: conditions = H._isometry_conditions(defining=[], remaining=[(H(0), H(0)), (H(1), H(1)), (H(2), H(2)), (H(3), H(3))])</span>
<span class="sd">            sage: list(conditions)</span>
<span class="sd">            [[(0, 0), (1, 1), (2, 2)]]</span>

<span class="sd">        The data provided by ``remaining`` can contain redundancies::</span>

<span class="sd">            sage: conditions = H._isometry_conditions(defining=[], remaining=[(H(0), H(0)), (H(1), H(1)), (H(1), H(1)), (H(3), H(3))])</span>
<span class="sd">            sage: list(conditions)</span>
<span class="sd">            [[(0, 0), (1, 1), (3, 3)]]</span>

<span class="sd">        For more complex objects there might be lots of mappings possible (we</span>
<span class="sd">        could likely have a shorter list of possibilities here)::</span>

<span class="sd">            sage: P = H.polygon([H.vertical(1).left_half_space(), H.vertical(-1).right_half_space(), H.geodesic(-1, 1).left_half_space()], marked_vertices=[I + 1])</span>
<span class="sd">            sage: Q = H.polygon(P.half_spaces(), marked_vertices=[I - 1])</span>
<span class="sd">            sage: conditions = H._isometry_conditions([], [(P, Q)])</span>
<span class="sd">            sage: list(conditions)</span>
<span class="sd">            [[({-x + 1 = 0}, {x + 1 = 0}), ({x + 1 = 0}, {(x^2 + y^2) - 1 = 0})],</span>
<span class="sd">             [({-x + 1 = 0}, {(x^2 + y^2) - 1 = 0}), ({x + 1 = 0}, {-x + 1 = 0})],</span>
<span class="sd">             [({-x + 1 = 0}, {-x + 1 = 0}), ({x + 1 = 0}, {x + 1 = 0})],</span>
<span class="sd">             [({-x + 1 = 0}, {x + 1 = 0}), ({x + 1 = 0}, {-x + 1 = 0})],</span>
<span class="sd">             [({-x + 1 = 0}, {-x + 1 = 0}), ({x + 1 = 0}, {(x^2 + y^2) - 1 = 0})],</span>
<span class="sd">             [({-x + 1 = 0}, {(x^2 + y^2) - 1 = 0}), ({x + 1 = 0}, {x + 1 = 0})]]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">degree</span><span class="p">(</span><span class="n">preimage</span><span class="p">,</span> <span class="n">image</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">preimage</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">preimage</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">2</span>
            <span class="k">assert</span> <span class="kc">False</span>

        <span class="n">degree</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">degree</span><span class="p">(</span><span class="n">preimage</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">preimage</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span> <span class="ow">in</span> <span class="n">defining</span><span class="p">])</span>

        <span class="c1"># If we have three pairs of points, determine the unique isometry that maps them to each other.</span>
        <span class="k">if</span> <span class="n">degree</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">defining</span>
            <span class="k">return</span>

        <span class="c1"># There are fewer than three points in &quot;defining&quot;. Extend with more points.</span>
        <span class="k">if</span> <span class="n">remaining</span><span class="p">:</span>
            <span class="c1"># Extend by turning remaining[0] into a condition</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">remaining</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">remaining</span> <span class="o">=</span> <span class="n">remaining</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

            <span class="c1"># Extend with a pair of points in &quot;remaining[0]&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">HyperbolicPoint</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">y</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>

                <span class="n">pair</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isometry_untrivialize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">defining</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">pair</span><span class="p">:</span>
                    <span class="n">defining</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>

                <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isometry_conditions</span><span class="p">(</span><span class="n">defining</span><span class="p">[:],</span> <span class="n">remaining</span><span class="p">)</span>

            <span class="c1"># Extend with a pair of geodesics in &quot;remaining[0]&quot;</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">HyperbolicOrientedGeodesic</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">y</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span>

                <span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">geodesic</span><span class="p">()</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">geodesic</span><span class="p">()</span>

                <span class="n">pair</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isometry_untrivialize</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">defining</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">pair</span><span class="p">:</span>
                    <span class="n">defining</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>

                <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isometry_conditions</span><span class="p">(</span>
                    <span class="n">defining</span><span class="p">[:],</span>
                    <span class="n">remaining</span> <span class="o">+</span> <span class="p">[(</span><span class="n">x</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">start</span><span class="p">()),</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">end</span><span class="p">())],</span>
                <span class="p">)</span>

            <span class="c1"># Extend with points coming from other hyperbolic objects in &quot;remaining[0]&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">pairs</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">_isometry_conditions</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                    <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isometry_conditions</span><span class="p">(</span><span class="n">defining</span><span class="p">[:],</span> <span class="n">pairs</span> <span class="o">+</span> <span class="n">remaining</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">defining</span></div>

    <span class="k">def</span> <span class="nf">_isometry_from_single_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">preimage</span><span class="p">,</span> <span class="n">image</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method for :meth:`isometry`.</span>

<span class="sd">        Return a right isometry that maps the point ``preimage`` to the point</span>
<span class="sd">        ``image`` or ``None`` when no such isometry exists.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H._isometry_from_single_points(H(I), H(I))</span>
<span class="sd">            [1 0]</span>
<span class="sd">            [0 1]</span>

<span class="sd">            sage: H._isometry_from_single_points(H(I), H(2*I))</span>
<span class="sd">            [1/2   0]</span>
<span class="sd">            [  0   1]</span>

<span class="sd">            sage: H._isometry_from_single_points(H(0), H(oo))</span>
<span class="sd">            [0 1]</span>
<span class="sd">            [1 0]</span>

<span class="sd">            sage: H._isometry_from_single_points(H(I), H(1)) is None</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">preimage</span><span class="o">.</span><span class="n">is_ideal</span><span class="p">()</span> <span class="o">!=</span> <span class="n">image</span><span class="o">.</span><span class="n">is_ideal</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">MatrixSpace</span>

        <span class="n">MS</span> <span class="o">=</span> <span class="n">MatrixSpace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">(),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">isometry</span> <span class="o">=</span> <span class="n">MS</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">preimage</span> <span class="o">==</span> <span class="n">image</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">isometry</span>

        <span class="k">if</span> <span class="n">preimage</span><span class="o">.</span><span class="n">is_ideal</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">preimage</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">infinity</span><span class="p">():</span>
                <span class="n">isometry</span> <span class="o">*=</span> <span class="o">~</span><span class="n">MS</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">isometry</span> <span class="o">*=</span> <span class="o">~</span><span class="n">MS</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">preimage</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

            <span class="k">if</span> <span class="n">image</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">infinity</span><span class="p">():</span>
                <span class="n">isometry</span> <span class="o">*=</span> <span class="o">~</span><span class="n">MS</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">isometry</span> <span class="o">*=</span> <span class="o">~</span><span class="n">MS</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

            <span class="k">return</span> <span class="n">isometry</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">isometry</span> <span class="o">*=</span> <span class="o">~</span><span class="n">MS</span><span class="p">(</span>
                <span class="p">[[</span><span class="n">image</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">preimage</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="p">)</span>
            <span class="n">isometry</span> <span class="o">*=</span> <span class="o">~</span><span class="n">MS</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">[</span>
                        <span class="mi">1</span><span class="p">,</span>
                        <span class="n">image</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="o">-</span> <span class="n">preimage</span><span class="o">.</span><span class="n">apply_isometry</span><span class="p">(</span>
                            <span class="n">isometry</span><span class="p">,</span> <span class="n">on_right</span><span class="o">=</span><span class="kc">True</span>
                        <span class="p">)</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="p">],</span>
                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">isometry</span>

    <span class="k">def</span> <span class="nf">_isometry_from_single_geodesics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">preimage</span><span class="p">,</span> <span class="n">image</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method for :meth:`isometry`.</span>

<span class="sd">        Return a right isometry that maps the geodesic ``preimage`` to the</span>
<span class="sd">        geodesic ``image`` or ``None`` when no such isometry exists.</span>

<span class="sd">        ALGORITHM:</span>

<span class="sd">        We determine the isometry by forcing the midpoints of the geodesics to</span>
<span class="sd">        be mapped to each other. This might fail because the midpoints of the</span>
<span class="sd">        geodesics are not defined over the :meth:`base_ring`. Also, that</span>
<span class="sd">        isometry might not be defined over the base ring but some other</span>
<span class="sd">        isometry is.</span>

<span class="sd">        In general, this is not a good approach. There might be a much better</span>
<span class="sd">        way to determine such an isometry explicitly.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        A case where we can actually map things::</span>

<span class="sd">            sage: H._isometry_from_single_geodesics(H.geodesic(-1, 1), H.geodesic(0, 2))</span>
<span class="sd">            [ 1 -1]</span>
<span class="sd">            [ 0  1]</span>

<span class="sd">        In many cases, we fail to find the isometry::</span>

<span class="sd">            sage: g = H.geodesic(1, 2, 3, model=&quot;klein&quot;)</span>
<span class="sd">            sage: h = g.apply_isometry(matrix([[1, 2], [3, 4]]), on_right=True)</span>
<span class="sd">            sage: H._isometry_from_single_geodesics(g, h)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: ...</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">isometry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isometry_from_primitives</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">preimage</span><span class="p">,</span> <span class="n">image</span><span class="p">),</span> <span class="p">(</span><span class="n">preimage</span><span class="o">.</span><span class="n">midpoint</span><span class="p">(),</span> <span class="n">image</span><span class="o">.</span><span class="n">midpoint</span><span class="p">())]</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">isometry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">warnings</span>

                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Could not determine an isometry of geodesics over the base ring. There might still be one but the implementation failed to detect it.&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">isometry</span>

<div class="viewcode-block" id="HyperbolicPlane._isometry_from_equations"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPlane._isometry_from_equations">[docs]</a>    <span class="k">def</span> <span class="nf">_isometry_from_equations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conditions</span><span class="p">,</span> <span class="nb">filter</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method for :meth:`isometry`.</span>

<span class="sd">        Return an isometry that satisfies ``conditions`` and ``filter``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``conditions`` -- a function that receives a (symbolic) isometry and</span>
<span class="sd">          some (symbolic) variables and creates polynomial equations that a</span>
<span class="sd">          concrete isometry must satisfy.</span>

<span class="sd">        - ``filter`` -- a function that receives a concrete isometry and</span>
<span class="sd">          returns whether it maps objects correctly.</span>

<span class="sd">        ALGORITHM:</span>

<span class="sd">        We guess determine the entries of a 2×2 matrix with entries a, b, c, d</span>
<span class="sd">        by guessing for each term that it is non-zero and then building the</span>
<span class="sd">        symbolic relations that the isometry must satisfy by invoking</span>
<span class="sd">        ``conditions``. These symbolic conditions contain free linear variables</span>
<span class="sd">        coming from the fact that points are encoded projectively and geodesics</span>
<span class="sd">        in the dual. We tune these variables so that all entries of the matrix</span>
<span class="sd">        are in the base ring. (Namely, so that we can take all the square roots</span>
<span class="sd">        that show up.)</span>

<span class="sd">        The whole process is very ad-hoc and very slow since it computes lots</span>
<span class="sd">        of Gröbner bases. It is very likely that the approach is not</span>
<span class="sd">        mathematically sound but it worked for many random inputs that we</span>
<span class="sd">        presented it with.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">PolynomialRing</span><span class="p">,</span> <span class="n">matrix</span>

        <span class="c1"># Over the reals, the equations are different depending on whether we</span>
        <span class="c1"># send a geodesic to -another geodesic or +another geodesic. We try</span>
        <span class="c1"># both cases to see which one yields a system that we can solve over</span>
        <span class="c1"># the base ring.</span>
        <span class="k">for</span> <span class="n">sgn</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">one</span><span class="p">(),</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">one</span><span class="p">()]:</span>
            <span class="c1"># We try to determine the matrix describing the isometry assuming</span>
            <span class="c1"># that &quot;variable&quot; is non-zero.</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">]:</span>
                <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="s2">&quot;λ1&quot;</span><span class="p">,</span> <span class="s2">&quot;λ2&quot;</span><span class="p">]</span>
                <span class="n">variables</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
                <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
                <span class="c1"># We use a term order that guarantees that we will see an</span>
                <span class="c1"># equation for &quot;variable&quot; in the Gröbner basis.</span>
                <span class="n">R</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">(),</span> <span class="n">names</span><span class="o">=</span><span class="n">variables</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;degrevlex(5), lex(1)&quot;</span>
                <span class="p">)</span>
                <span class="c1"># We are going to run the same procedure twice. Once with λ0 =</span>
                <span class="c1"># ±1 and then with a λ0 tuned to a value so that we can</span>
                <span class="c1"># actually solve for &quot;variable&quot;.</span>
                <span class="n">λ0</span> <span class="o">=</span> <span class="n">sgn</span>
                <span class="n">λ1</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span><span class="s2">&quot;λ1&quot;</span><span class="p">)</span>
                <span class="n">λ2</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span><span class="s2">&quot;λ2&quot;</span><span class="p">)</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
                <span class="n">variable</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>

                <span class="c1"># We keep track of whether we made any assumptions here that</span>
                <span class="c1"># mean that we might be ignoring solutions in this run.</span>
                <span class="n">equivalence</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># The isometry as a symbolic 2×2 matrix.</span>
                <span class="n">isometry</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">]])</span>

                <span class="n">isometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isometry_gl2_to_sim12</span><span class="p">(</span><span class="n">isometry</span><span class="p">)</span>

                <span class="c1"># Build equations for the symbolic variables and make sure that</span>
                <span class="c1"># the resulting variety is zero-dimensional.</span>
                <span class="n">equations</span> <span class="o">=</span> <span class="n">conditions</span><span class="p">(</span><span class="n">isometry</span><span class="p">,</span> <span class="p">(</span><span class="n">λ0</span><span class="p">,</span> <span class="n">λ1</span><span class="p">,</span> <span class="n">λ2</span><span class="p">))</span>

                <span class="k">for</span> <span class="n">λ</span> <span class="ow">in</span> <span class="p">[</span><span class="n">λ1</span><span class="p">,</span> <span class="n">λ2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">equation</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">λ</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">equation</span> <span class="ow">in</span> <span class="n">equations</span><span class="p">):</span>
                        <span class="c1"># Force the unused variable λ to be =0</span>
                        <span class="n">equations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">λ</span><span class="p">)</span>

                <span class="c1"># The system of euations typically has no rational points.</span>
                <span class="c1"># We analyze the Gröbner basis to tune λ0 so that we get</span>
                <span class="c1"># rational points.</span>
                <span class="n">J</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="n">equations</span><span class="p">)</span><span class="o">.</span><span class="n">groebner_basis</span><span class="p">())</span>

                <span class="k">if</span> <span class="n">J</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="c1"># The equations are contradictory.</span>
                    <span class="k">assert</span> <span class="n">equivalence</span>
                    <span class="k">return</span> <span class="kc">None</span>

                <span class="c1"># We extract an equation for &quot;variable&quot; from the Gröbner basis.</span>
                <span class="n">equation</span> <span class="o">=</span> <span class="n">J</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="k">assert</span> <span class="n">equation</span><span class="o">.</span><span class="n">variables</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span>
                    <span class="n">variable</span><span class="p">,</span>
                <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;expected Gröbner basis algorithm to yield an equation for </span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2"> but found </span><span class="si">{</span><span class="n">equation</span><span class="si">}</span><span class="s2"> instead&quot;</span>
                <span class="n">equation</span> <span class="o">=</span> <span class="n">equation</span><span class="o">.</span><span class="n">polynomial</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
                <span class="n">equation</span> <span class="o">=</span> <span class="n">equation</span><span class="o">.</span><span class="n">map_coefficients</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">(),</span> <span class="n">new_base_ring</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="n">variable</span> <span class="o">=</span> <span class="n">equation</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">gen</span><span class="p">()</span>

                <span class="c1"># The variable must be zero. We continue with another</span>
                <span class="c1"># (non-zero) variable since we meant to deduce the value of the</span>
                <span class="c1"># scaling factor λ0.</span>
                <span class="k">if</span> <span class="n">equation</span> <span class="o">==</span> <span class="n">variable</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># The equation allows the case that the variable is zero.</span>
                <span class="c1"># We ignore this possibility here. If this is needed, then we</span>
                <span class="c1"># will find out in the loop for another variable.</span>
                <span class="k">while</span> <span class="ow">not</span> <span class="n">equation</span><span class="o">.</span><span class="n">constant_coefficient</span><span class="p">():</span>
                    <span class="n">equivalence</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">equation</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>

                <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">QQbar</span>

                <span class="n">equation</span> <span class="o">=</span> <span class="n">equation</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">QQbar</span><span class="p">)</span>

                <span class="c1"># We try to arrange things so that &quot;variable&quot; becomes an element of the base ring.</span>
                <span class="c1"># We look at the minpoly of variable and tune λ0 so that this</span>
                <span class="c1"># becomes a square root of something that is a square.</span>
                <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">equation</span><span class="o">.</span><span class="n">roots</span><span class="p">(</span><span class="n">multiplicities</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
                    <span class="n">minpoly</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">minpoly</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">minpoly</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="k">elif</span> <span class="n">minpoly</span><span class="o">.</span><span class="n">exponents</span><span class="p">()</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
                        <span class="n">λ0</span> <span class="o">=</span> <span class="o">-</span><span class="n">sgn</span> <span class="o">*</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()(</span><span class="n">minpoly</span><span class="o">.</span><span class="n">constant_coefficient</span><span class="p">())</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># We cannot change the equations for this root to show</span>
                        <span class="c1"># up over the base ring.</span>
                        <span class="k">continue</span>

                    <span class="k">assert</span> <span class="p">(</span>
                        <span class="n">λ0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span> <span class="ow">and</span> <span class="n">λ0</span> <span class="o">!=</span> <span class="mi">0</span>
                    <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;did not deduce a non-zero constant for λ0=</span><span class="si">{</span><span class="n">λ0</span><span class="si">}</span><span class="s2"> from </span><span class="si">{</span><span class="n">equation</span><span class="si">}</span><span class="s2">&quot;</span>

                    <span class="c1"># We could now patch the existing Gröbner basis and solve directly, but</span>
                    <span class="c1"># we just solve again for the correct value of λ0.</span>
                    <span class="n">equations</span> <span class="o">=</span> <span class="n">conditions</span><span class="p">(</span><span class="n">isometry</span><span class="p">,</span> <span class="p">(</span><span class="n">λ0</span><span class="p">,</span> <span class="n">λ1</span><span class="p">,</span> <span class="n">λ2</span><span class="p">))</span>

                    <span class="k">for</span> <span class="n">λ</span> <span class="ow">in</span> <span class="p">[</span><span class="n">λ1</span><span class="p">,</span> <span class="n">λ2</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">equation</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">λ</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">equation</span> <span class="ow">in</span> <span class="n">equations</span><span class="p">):</span>
                            <span class="c1"># Force the unused variable λ to be =0</span>
                            <span class="n">equations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">λ</span><span class="p">)</span>

                    <span class="n">solutions</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="n">equations</span><span class="p">)</span><span class="o">.</span><span class="n">variety</span><span class="p">()</span>

                    <span class="k">assert</span> <span class="p">(</span>
                        <span class="n">solutions</span>
                    <span class="p">),</span> <span class="s2">&quot;After tuning the constant of the equations describing the isometry, there should be a solution but we did not find any.&quot;</span>

                    <span class="n">solutions</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">matrix</span><span class="p">([[</span><span class="n">solution</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">solution</span><span class="p">[</span><span class="n">b</span><span class="p">]],</span> <span class="p">[</span><span class="n">solution</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">solution</span><span class="p">[</span><span class="n">d</span><span class="p">]]])</span>
                        <span class="k">for</span> <span class="n">solution</span> <span class="ow">in</span> <span class="n">solutions</span>
                    <span class="p">]</span>

                    <span class="c1"># Check which solutions do not only satisfy &quot;conditions&quot;</span>
                    <span class="c1"># but map the underlying objects correctly, i.e., they also</span>
                    <span class="c1"># pass &quot;filter&quot;.</span>
                    <span class="n">solutions</span> <span class="o">=</span> <span class="p">[</span><span class="n">solution</span> <span class="k">for</span> <span class="n">solution</span> <span class="ow">in</span> <span class="n">solutions</span> <span class="k">if</span> <span class="nb">filter</span><span class="p">(</span><span class="n">solution</span><span class="p">)]</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">solutions</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># Prefer an isometry of determinant 1 and isometries with 1 entries.</span>
                    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span>
                        <span class="n">solutions</span><span class="p">,</span>
                        <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">isometry</span><span class="p">:</span> <span class="p">(</span>
                            <span class="n">isometry</span><span class="o">.</span><span class="n">det</span><span class="p">(),</span>
                            <span class="n">isometry</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
                            <span class="n">isometry</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="p">),</span>
                    <span class="p">)</span>

        <span class="c1"># No luck with this approach. We hope that this means that no such</span>
        <span class="c1"># isometry exists over the base ring but it&#39;s not entirely clear</span>
        <span class="c1"># whether that is actually true.</span>
        <span class="k">return</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a printable representation of this hyperbolic plane.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: HyperbolicPlane(AA)</span>
<span class="sd">            Hyperbolic Plane over Algebraic Real Field</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Hyperbolic Plane over </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span></div>


<div class="viewcode-block" id="HyperbolicGeometry"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeometry">[docs]</a><span class="k">class</span> <span class="nc">HyperbolicGeometry</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Predicates and primitive geometric constructions over a base ``ring``.</span>

<span class="sd">    This class and its subclasses implement the core underlying hyperbolic</span>
<span class="sd">    geometry that depends on the base ring. For example, when deciding whether</span>
<span class="sd">    two points in the hyperbolic plane are equal, we cannot just compare their</span>
<span class="sd">    coordinates if the base ring is inexact. Therefore, that predicate is</span>
<span class="sd">    implemented in this &quot;geometry&quot; class and is implemented differently by</span>
<span class="sd">    :class:`HyperbolicExactGeometry` for exact and</span>
<span class="sd">    :class:`HyperbolicEpsilonGeometry` for inexact rings.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``ring`` -- a ring, the ring in which coordinates in the hyperbolic plane</span>
<span class="sd">      will be represented</span>

<span class="sd">    .. NOTE::</span>

<span class="sd">        Abstract methods are not marked with `@abstractmethod` since we cannot</span>
<span class="sd">        use the ABCMeta metaclass to enforce their implementation; otherwise,</span>
<span class="sd">        our subclasses could not use the unique representation metaclasses.</span>

<span class="sd">    EXAMPLES:</span>

<span class="sd">    The specific hyperbolic geometry implementation is picked automatically,</span>
<span class="sd">    depending on whether the base ring is exact or not::</span>

<span class="sd">        sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">        sage: H = HyperbolicPlane()</span>
<span class="sd">        sage: H.geometry</span>
<span class="sd">        Exact geometry over Rational Field</span>
<span class="sd">        sage: H(0) == H(1/1024)</span>
<span class="sd">        False</span>

<span class="sd">    However, we can explicitly use a different or custom geometry::</span>

<span class="sd">        sage: from flatsurf.geometry.hyperbolic import HyperbolicEpsilonGeometry</span>
<span class="sd">        sage: H = HyperbolicPlane(QQ, HyperbolicEpsilonGeometry(QQ, 1/1024))</span>
<span class="sd">        sage: H.geometry</span>
<span class="sd">        Epsilon geometry with ϵ=1/1024 over Rational Field</span>
<span class="sd">        sage: H(0) == H(1/2048)</span>
<span class="sd">        True</span>

<span class="sd">    .. SEEALSO::</span>

<span class="sd">        :class:`HyperbolicExactGeometry`, :class:`HyperbolicEpsilonGeometry`</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="HyperbolicGeometry.__init__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeometry.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicGeometry</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: isinstance(H.geometry, HyperbolicGeometry)</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ring</span> <span class="o">=</span> <span class="n">ring</span></div>

<div class="viewcode-block" id="HyperbolicGeometry.base_ring"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeometry.base_ring">[docs]</a>    <span class="k">def</span> <span class="nf">base_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the ring over which this geometry is implemented.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: H.geometry.base_ring()</span>
<span class="sd">            Rational Field</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ring</span></div>

    <span class="k">def</span> <span class="nf">_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether ``x`` should be considered zero in the</span>
<span class="sd">        :meth:`base_ring`.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            This predicate should not be used directly in geometric</span>
<span class="sd">            constructions since it does not specify the context in which this</span>
<span class="sd">            question is asked. This makes it very difficult to override a</span>
<span class="sd">            specific aspect in a custom geometry. Also, this predicate lacks</span>
<span class="sd">            the context of other elements; a proper predicate should also take</span>
<span class="sd">            other elements into account to decide this question relative to the</span>
<span class="sd">            other values.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``x`` -- an element of the :meth:`base_ring`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane(RR)</span>
<span class="sd">            sage: H.geometry._zero(1)</span>
<span class="sd">            False</span>
<span class="sd">            sage: H.geometry._zero(1e-9)</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_cmp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return how ``x`` compares to ``y``.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            This predicate should not be used directly in geometric</span>
<span class="sd">            constructions since it does not specify the context in which this</span>
<span class="sd">            question is asked. This makes it very difficult to override a</span>
<span class="sd">            specific aspect in a custom geometry.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``x`` -- an element of the :meth:`base_ring`</span>

<span class="sd">        - ``y`` -- an element of the :meth:`base_ring`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: H.geometry._cmp(0, 0)</span>
<span class="sd">            0</span>
<span class="sd">            sage: H.geometry._cmp(0, 1)</span>
<span class="sd">            -1</span>
<span class="sd">            sage: H.geometry._cmp(1, 0)</span>
<span class="sd">            1</span>

<span class="sd">        ::</span>

<span class="sd">            sage: H = HyperbolicPlane(RR)</span>
<span class="sd">            sage: H.geometry._cmp(0, 0)</span>
<span class="sd">            0</span>
<span class="sd">            sage: H.geometry._cmp(0, 1)</span>
<span class="sd">            -1</span>
<span class="sd">            sage: H.geometry._cmp(1, 0)</span>
<span class="sd">            1</span>
<span class="sd">            sage: H.geometry._cmp(1e-10, 0)</span>
<span class="sd">            0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span>
        <span class="p">),</span> <span class="s2">&quot;Geometry over this ring must override _cmp since not (x == y) and not (x &lt; y) does not imply x &gt; y&quot;</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_sgn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the sign of ``x``.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            This predicate should not be used directly in geometric</span>
<span class="sd">            constructions since it does not specify the context in which this</span>
<span class="sd">            question is asked. This makes it very difficult to override a</span>
<span class="sd">            specific aspect in a custom geometry. Also, this predicate lacks</span>
<span class="sd">            the context of other elements; a proper predicate should also take</span>
<span class="sd">            other elements into account to decide this question relative to the</span>
<span class="sd">            other values.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``x`` -- an element of the :meth:`base_ring`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane(RR)</span>
<span class="sd">            sage: H.geometry._sgn(1)</span>
<span class="sd">            1</span>
<span class="sd">            sage: H.geometry._sgn(-1)</span>
<span class="sd">            -1</span>
<span class="sd">            sage: H.geometry._sgn(1e-10)</span>
<span class="sd">            0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<div class="viewcode-block" id="HyperbolicGeometry._equal"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeometry._equal">[docs]</a>    <span class="k">def</span> <span class="nf">_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether ``x`` and ``y`` should be considered equal in the :meth:`base_ring`.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            This predicate should not be used directly in geometric</span>
<span class="sd">            constructions since it does not specify the context in which this</span>
<span class="sd">            question is asked. This makes it very difficult to override a</span>
<span class="sd">            specific aspect in a custom geometry.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``x`` -- an element of the :meth:`base_ring`</span>

<span class="sd">        - ``y`` -- an element of the :meth:`base_ring`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane(RR)</span>
<span class="sd">            sage: H.geometry._equal(0, 1)</span>
<span class="sd">            False</span>
<span class="sd">            sage: H.geometry._equal(0, 1e-10)</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;this geometry does not implement _equal()&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_determinant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the determinant of the 2×2 matrix ``[[a, b], [c, d]]`` or</span>
<span class="sd">        ``None`` if the matrix is singular.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            This predicate should not be used directly in geometric</span>
<span class="sd">            constructions since it does not specify the context in which this</span>
<span class="sd">            question is asked. This makes it very difficult to override a</span>
<span class="sd">            specific aspect in a custom geometry.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``a`` -- an element of the :meth:`base_ring`</span>

<span class="sd">        - ``b`` -- an element of the :meth:`base_ring`</span>

<span class="sd">        - ``c`` -- an element of the :meth:`base_ring`</span>

<span class="sd">        - ``d`` -- an element of the :meth:`base_ring`</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.geometry._determinant(1, 2, 3, 4)</span>
<span class="sd">            -2</span>
<span class="sd">            sage: H.geometry._determinant(0, 10^-10, 1, 1)</span>
<span class="sd">            -1/10000000000</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">det</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">d</span> <span class="o">-</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zero</span><span class="p">(</span><span class="n">det</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">det</span>

<div class="viewcode-block" id="HyperbolicGeometry.change_ring"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeometry.change_ring">[docs]</a>    <span class="k">def</span> <span class="nf">change_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return this geometry with the :meth:`base_ring` changed to ``ring``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: H.geometry</span>
<span class="sd">            Exact geometry over Rational Field</span>
<span class="sd">            sage: H.geometry.change_ring(AA)</span>
<span class="sd">            Exact geometry over Algebraic Real Field</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;this geometry does not implement change_ring()&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicGeometry.projective"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeometry.projective">[docs]</a>    <span class="k">def</span> <span class="nf">projective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the ideal point with projective coordinates ``[p: q]`` in the</span>
<span class="sd">        upper half plane model.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``p`` -- an element of the :meth:`base_ring`</span>

<span class="sd">        - ``q`` -- an element of the :meth:`base_ring`</span>

<span class="sd">        - ``point`` -- the :meth:`HyperbolicPlane.point` to create points</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.geometry.projective(1, 0, H.point)</span>
<span class="sd">            ∞</span>
<span class="sd">            sage: H.geometry.projective(0, 1, H.point)</span>
<span class="sd">            0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zero</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zero</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;one of p and q must not be zero&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zero</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">point</span><span class="p">(</span><span class="n">p</span> <span class="o">/</span> <span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicGeometry.half_circle"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeometry.half_circle">[docs]</a>    <span class="k">def</span> <span class="nf">half_circle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">radius_squared</span><span class="p">,</span> <span class="n">geodesic</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the geodesic around the real ``center`` and with</span>
<span class="sd">        ``radius_squared`` in the upper half plane.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``center`` -- an element of the :meth:`base_ring`, the center of the</span>
<span class="sd">          half circle on the real axis</span>

<span class="sd">        - ``radius_squared`` -- a positive element of the :meth:`base_ring`,</span>
<span class="sd">          the square of the radius of the half circle</span>

<span class="sd">        - ``geodesic`` -- the :meth:`HyperbolicPlane.geodesic` to create geodesics</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.geometry.half_circle(0, 1, H.geodesic)</span>
<span class="sd">            {(x^2 + y^2) - 1 = 0}</span>

<span class="sd">        Unfortunately, this does not work correctly over inexact fields yet::</span>

<span class="sd">            sage: H = HyperbolicPlane(RR)</span>
<span class="sd">            sage: H.geometry.half_circle(0, 1e-32, H.geodesic)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: radius must be positive</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sgn</span><span class="p">(</span><span class="n">radius_squared</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;radius must be positive&quot;</span><span class="p">)</span>

        <span class="c1"># Represent this geodesic as a(x^2 + y^2) + b*x + c = 0</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">center</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">center</span> <span class="o">*</span> <span class="n">center</span> <span class="o">-</span> <span class="n">radius_squared</span>

        <span class="k">return</span> <span class="n">geodesic</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicGeometry.vertical"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeometry.vertical">[docs]</a>    <span class="k">def</span> <span class="nf">vertical</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span> <span class="n">geodesic</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the vertical geodesic at the ``real`` ideal point in the upper</span>
<span class="sd">        half plane model.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``real`` -- an element of the :meth:`base_ring`</span>

<span class="sd">        - ``geodesic`` -- the :meth:`HyperbolicPlane.geodesic` to create geodesics</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.geometry.vertical(0, H.geodesic)</span>
<span class="sd">            {-x = 0}</span>

<span class="sd">        Unfortunately, this does not allow creation of verticals at large reals</span>
<span class="sd">        over inexact fields yet::</span>

<span class="sd">            sage: H = HyperbolicPlane(RR)</span>
<span class="sd">            sage: H.geometry.vertical(1e32, H.geodesic)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: equation ... does not define a chord in the Klein model</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert the equation -x + real = 0 to the Klein model.</span>
        <span class="k">return</span> <span class="n">geodesic</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">real</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicGeometry.classify_point"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeometry.classify_point">[docs]</a>    <span class="k">def</span> <span class="nf">classify_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether the point ``(x, y)`` is finite, ideal, or ultra-ideal.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``x`` -- an element of the :meth:`base_ring`</span>

<span class="sd">        - ``y`` -- an element of the :meth:`base_ring`</span>

<span class="sd">        - ``model`` -- a supported model, either ``&quot;half_plane&quot;`` or</span>
<span class="sd">          ``&quot;klein&quot;``</span>

<span class="sd">        OUTPUT: ``1`` if the point is finite, ``0`` if the point is ideal,</span>
<span class="sd">        ``-1`` if the point is neither of the two.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.geometry.classify_point(0, 1, model=&quot;half_plane&quot;)</span>
<span class="sd">            1</span>
<span class="sd">            sage: H.geometry.classify_point(0, 0, model=&quot;half_plane&quot;)</span>
<span class="sd">            0</span>
<span class="sd">            sage: H.geometry.classify_point(0, -1, model=&quot;half_plane&quot;)</span>
<span class="sd">            -1</span>

<span class="sd">        Unfortunately, over an inexact field, this detects points close to the</span>
<span class="sd">        real axis as being ultra-ideal::</span>

<span class="sd">            sage: H = HyperbolicPlane(RR)</span>
<span class="sd">            sage: H.geometry.classify_point(0, -1e32, model=&quot;half_plane&quot;)</span>
<span class="sd">            -1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s2">&quot;half_plane&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sgn</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s2">&quot;klein&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot classify points in the Klein model yet&quot;</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;unsupported model&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicGeometry.intersection"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeometry.intersection">[docs]</a>    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the point of intersection between the Euclidean lines ``f`` and ``g``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``f`` -- a triple of elements ``(a, b, c)`` of :meth:`base_ring`</span>
<span class="sd">          encoding the line `a + bx + cy = 0`</span>

<span class="sd">        - ``g`` -- a triple of elements ``(a, b, c)`` of :meth:`base_ring`</span>
<span class="sd">          encoding the line `a + bx + cy = 0`</span>

<span class="sd">        OUTPUT: A pair of elements of :meth:`base_ring`, the coordinates of the</span>
<span class="sd">        point of intersection, or ``None`` if the lines do not intersect.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.geometry.intersection((0, 1, 0), (0, 0, 1))</span>
<span class="sd">            (0, 0)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="n">fc</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span>
        <span class="p">(</span><span class="n">ga</span><span class="p">,</span> <span class="n">gb</span><span class="p">,</span> <span class="n">gc</span><span class="p">)</span> <span class="o">=</span> <span class="n">g</span>
        <span class="n">det</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_determinant</span><span class="p">(</span><span class="n">fb</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">gb</span><span class="p">,</span> <span class="n">gc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">det</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">gc</span> <span class="o">*</span> <span class="n">fa</span> <span class="o">+</span> <span class="n">fc</span> <span class="o">*</span> <span class="n">ga</span><span class="p">)</span> <span class="o">/</span> <span class="n">det</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">gb</span> <span class="o">*</span> <span class="n">fa</span> <span class="o">-</span> <span class="n">fb</span> <span class="o">*</span> <span class="n">ga</span><span class="p">)</span> <span class="o">/</span> <span class="n">det</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="HyperbolicExactGeometry"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicExactGeometry">[docs]</a><span class="k">class</span> <span class="nc">HyperbolicExactGeometry</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">,</span> <span class="n">HyperbolicGeometry</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Predicates and primitive geometric constructions over an exact base ring.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">        sage: H = HyperbolicPlane()</span>
<span class="sd">        sage: H.geometry</span>
<span class="sd">        Exact geometry over Rational Field</span>

<span class="sd">    TESTS::</span>

<span class="sd">        sage: from flatsurf.geometry.hyperbolic import HyperbolicExactGeometry</span>
<span class="sd">        sage: isinstance(H.geometry, HyperbolicExactGeometry)</span>
<span class="sd">        True</span>

<span class="sd">    .. SEEALSO::</span>

<span class="sd">        :class:`HyperbolicEpsilonGeometry` for an implementation over inexact rings</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="HyperbolicExactGeometry._equal"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicExactGeometry._equal">[docs]</a>    <span class="k">def</span> <span class="nf">_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether the numbers ``x`` and ``y`` should be considered equal</span>
<span class="sd">        in exact geometry.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            This predicate should not be used directly in geometric</span>
<span class="sd">            constructions since it does not specify the context in which this</span>
<span class="sd">            question is asked. This makes it very difficult to override a</span>
<span class="sd">            specific aspect in a custom geometry.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: H.geometry._equal(0, 1)</span>
<span class="sd">            False</span>
<span class="sd">            sage: H.geometry._equal(0, 1/2**64)</span>
<span class="sd">            False</span>
<span class="sd">            sage: H.geometry._equal(0, 0)</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span></div>

<div class="viewcode-block" id="HyperbolicExactGeometry.change_ring"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicExactGeometry.change_ring">[docs]</a>    <span class="k">def</span> <span class="nf">change_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return this geometry with the :meth:`~HyperbolicGeometry.base_ring`</span>
<span class="sd">        changed to ``ring``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: H.geometry.change_ring(QQ) == H.geometry</span>
<span class="sd">            True</span>
<span class="sd">            sage: H.geometry.change_ring(AA)</span>
<span class="sd">            Exact geometry over Algebraic Real Field</span>

<span class="sd">        When presented with the reals, we guess the epsilon for the</span>
<span class="sd">        :class:`HyperbolicEpsilonGeometry` to be consistent with the</span>
<span class="sd">        :class:`HyperbolicGeometry` constructor. (And also, because we use this</span>
<span class="sd">        frequently when plotting.)::</span>

<span class="sd">            sage: H.geometry.change_ring(RR)</span>
<span class="sd">            Epsilon geometry with ϵ=1.00000000000000e-6 over Real Field with 53 bits of precision</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">RR</span>

        <span class="k">if</span> <span class="n">ring</span> <span class="ow">is</span> <span class="n">RR</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">HyperbolicEpsilonGeometry</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="mf">1e-6</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">ring</span><span class="o">.</span><span class="n">is_exact</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot change_ring() to an inexact ring&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">HyperbolicExactGeometry</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicExactGeometry.__repr__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicExactGeometry.__repr__">[docs]</a>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a printable representation of this geometry.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: H.geometry</span>
<span class="sd">            Exact geometry over Rational Field</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Exact geometry over </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_ring</span><span class="si">}</span><span class="s2">&quot;</span></div></div>


<div class="viewcode-block" id="HyperbolicEpsilonGeometry"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicEpsilonGeometry">[docs]</a><span class="k">class</span> <span class="nc">HyperbolicEpsilonGeometry</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">,</span> <span class="n">HyperbolicGeometry</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Predicates and primitive geometric constructions over a base ``ring`` with</span>
<span class="sd">    &quot;precision&quot; ``epsilon``.</span>

<span class="sd">    This is an alternative to :class:`HyperbolicExactGeometry` over inexact</span>
<span class="sd">    rings. The exact meaning of the ``epsilon`` parameter is a bit fuzzy, but</span>
<span class="sd">    the basic idea is that two numbers are considered equal in this geometry if</span>
<span class="sd">    their relative difference is less than ``epsilon``, see :meth:`_equal` for</span>
<span class="sd">    details.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``ring`` -- a ring, the ring in which coordinates in the hyperbolic plane</span>
<span class="sd">      will be represented</span>

<span class="sd">    - ``epsilon`` -- an error bound</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">        sage: from flatsurf.geometry.hyperbolic import HyperbolicEpsilonGeometry</span>
<span class="sd">        sage: H = HyperbolicPlane(RR, HyperbolicEpsilonGeometry(RR, 1/1024))</span>

<span class="sd">    The ``epsilon`` affects the notion of equality in this geometry::</span>

<span class="sd">        sage: H(0) == H(1/2048)</span>
<span class="sd">        True</span>

<span class="sd">        sage: H(1/2048) == H(2/2048)</span>
<span class="sd">        False</span>

<span class="sd">    This geometry is meant for inexact rings, however, it can also be used in</span>
<span class="sd">    exact rings::</span>

<span class="sd">        sage: H = HyperbolicPlane(QQ, HyperbolicEpsilonGeometry(QQ, 1/1024))</span>

<span class="sd">    .. SEEALSO::</span>

<span class="sd">        :class:`HyperbolicExactGeometry`</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="HyperbolicEpsilonGeometry.__init__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicEpsilonGeometry.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicEpsilonGeometry</span>
<span class="sd">            sage: H = HyperbolicPlane(RR)</span>
<span class="sd">            sage: isinstance(H.geometry, HyperbolicEpsilonGeometry)</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_epsilon</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="n">epsilon</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicEpsilonGeometry._equal"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicEpsilonGeometry._equal">[docs]</a>    <span class="k">def</span> <span class="nf">_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether ``x`` and ``y`` should be considered equal numbers with</span>
<span class="sd">        respect to an ε error.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            This method has not been tested much. Since this underlies much of</span>
<span class="sd">            the inexact geometry, we should probably do something better here,</span>
<span class="sd">            see e.g., https://floating-point-gui.de/errors/comparison/</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane(RR)</span>

<span class="sd">            sage: H.geometry._equal(1, 2)</span>
<span class="sd">            False</span>
<span class="sd">            sage: H.geometry._equal(1, 1 + 1e-32)</span>
<span class="sd">            True</span>
<span class="sd">            sage: H.geometry._equal(1e-32, 1e-32 + 1e-33)</span>
<span class="sd">            False</span>
<span class="sd">            sage: H.geometry._equal(1e-32, 1e-32 + 1e-64)</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_epsilon</span>

        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_epsilon</span></div>

    <span class="k">def</span> <span class="nf">_determinant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the determinant of the 2×2 matrix ``[[a, b], [c, d]]`` or</span>
<span class="sd">        ``None`` if the matrix is singular.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``a`` -- an element of the :meth:`~HyperbolicGeometry.base_ring`</span>

<span class="sd">        - ``b`` -- an element of the :meth:`~HyperbolicGeometry.base_ring`</span>

<span class="sd">        - ``c`` -- an element of the :meth:`~HyperbolicGeometry.base_ring`</span>

<span class="sd">        - ``d`` -- an element of the :meth:`~HyperbolicGeometry.base_ring`</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane(RR)</span>

<span class="sd">            sage: H.geometry._determinant(1, 2, 3, 4)</span>
<span class="sd">            -2</span>
<span class="sd">            sage: H.geometry._determinant(1e-10, 0, 0, 1e-10)</span>
<span class="sd">            1.00000000000000e-20</span>

<span class="sd">        Unfortunately, we are not implementing any actual rank detecting</span>
<span class="sd">        algorithm (QR decomposition or such) here. So, we do not detect that</span>
<span class="sd">        this matrik is singular::</span>

<span class="sd">            sage: H.geometry._determinant(1e-127, 1e-128, 1, 1)</span>
<span class="sd">            9.00000000000000e-128</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">det</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">d</span> <span class="o">-</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span>
        <span class="k">if</span> <span class="n">det</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Note that we should instead numerically detect the rank here.</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">det</span>

<div class="viewcode-block" id="HyperbolicEpsilonGeometry.projective"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicEpsilonGeometry.projective">[docs]</a>    <span class="k">def</span> <span class="nf">projective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the ideal point with projective coordinates ``[p: q]`` in the</span>
<span class="sd">        upper half plane model.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``p`` -- an element of the :meth:`~HyperbolicGeometry.base_ring`</span>

<span class="sd">        - ``q`` -- an element of the :meth:`~HyperbolicGeometry.base_ring`</span>

<span class="sd">        - ``point`` -- the :meth:`HyperbolicPlane.point` to create points</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane(RR)</span>

<span class="sd">        The point ``[p: q]`` is the point at infinity if ``q`` is very small in</span>
<span class="sd">        comparison to ``p``::</span>

<span class="sd">            sage: H.geometry.projective(1, 0, H.point)</span>
<span class="sd">            ∞</span>

<span class="sd">            sage: H.geometry.projective(1e-8, 1e-16, H.point)</span>
<span class="sd">            ∞</span>

<span class="sd">            sage: H.geometry.projective(1e-8, -1e-16, H.point)</span>
<span class="sd">            ∞</span>

<span class="sd">        Even though ``q`` might be small, ``[p: q]`` is not the point at</span>
<span class="sd">        infinity if both coordinates are of similar size::</span>

<span class="sd">            sage: H.geometry.projective(1e-16, 1e-16, H.point)</span>
<span class="sd">            1.00000000000000</span>

<span class="sd">            sage: H.geometry.projective(-1e-16, 1e-16, H.point)</span>
<span class="sd">            -1.00000000000000</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zero</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zero</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">pq</span> <span class="o">=</span> <span class="n">p</span> <span class="o">/</span> <span class="n">q</span>
            <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">qp</span> <span class="o">=</span> <span class="n">q</span> <span class="o">/</span> <span class="n">p</span>
            <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zero</span><span class="p">(</span><span class="n">qp</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">point</span><span class="p">(</span><span class="n">pq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">projective</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">point</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicEpsilonGeometry.change_ring"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicEpsilonGeometry.change_ring">[docs]</a>    <span class="k">def</span> <span class="nf">change_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return this geometry over ``ring``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane(RR)</span>

<span class="sd">            sage: H.geometry.change_ring(RR) is H.geometry</span>
<span class="sd">            True</span>

<span class="sd">            sage: H.geometry.change_ring(RDF)</span>
<span class="sd">            Epsilon geometry with ϵ=1e-06 over Real Double Field</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ring</span><span class="o">.</span><span class="n">is_exact</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot change_ring() to an exact ring&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">HyperbolicEpsilonGeometry</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_epsilon</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicEpsilonGeometry.__repr__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicEpsilonGeometry.__repr__">[docs]</a>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a printable representation of this geometry.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane(RR)</span>
<span class="sd">            sage: H.geometry</span>
<span class="sd">            Epsilon geometry with ϵ=1.00000000000000e-6 over Real Field with 53 bits of precision</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Epsilon geometry with ϵ=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_epsilon</span><span class="si">}</span><span class="s2"> over </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_ring</span><span class="si">}</span><span class="s2">&quot;</span></div></div>


<div class="viewcode-block" id="HyperbolicConvexSet"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexSet">[docs]</a><span class="k">class</span> <span class="nc">HyperbolicConvexSet</span><span class="p">(</span><span class="n">SageObject</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for convex subsets of :class:`HyperbolicPlane`.</span>

<span class="sd">    .. NOTE::</span>

<span class="sd">        Concrete subclasses should apply the following rules.</span>

<span class="sd">        There should only be a single type to describe a certain subset:</span>
<span class="sd">        normally, a certain subset, say a point, should only be described by a</span>
<span class="sd">        single class, namely :class:`HyperbolicPoint`. Of course, one could</span>
<span class="sd">        describe a point as a polygon delimited by some edges that all</span>
<span class="sd">        intersect in that single point, such objects should be avoided. Namely,</span>
<span class="sd">        the methods that create a subset, say :meth:`HyperbolicPlane.polygon`</span>
<span class="sd">        take care of this by calling a sets</span>
<span class="sd">        :meth:`HyperbolicConvexSet._normalize` to rewrite a set in its most</span>
<span class="sd">        natural representation. To get the denormalized representation, we can</span>
<span class="sd">        always set `check=False` when creating the object. For this to work,</span>
<span class="sd">        the `__init__` should not take care of any such normalization and</span>
<span class="sd">        accept any input that can possibly be made sense of.</span>

<span class="sd">        Comparison with ``==`` should mean &quot;is essentially indistinguishable</span>
<span class="sd">        from&quot;: Implementing == to mean anything else would get us into trouble</span>
<span class="sd">        in the long run. In particular we cannot implement &lt;= to mean &quot;is</span>
<span class="sd">        subset of&quot; since then an oriented and an unoriented geodesic would be</span>
<span class="sd">        `==`. So, objects of a different type should almost never be equal. A</span>
<span class="sd">        notable exception are objects that are indistinguishable to the end</span>
<span class="sd">        user but use different implementations: the starting point of the</span>
<span class="sd">        geodesic going from 0 to infinity, a</span>
<span class="sd">        :class:`HyperbolicPointFromGeodesic`, and the point with coordinates</span>
<span class="sd">        (0, 0) in the upper half plane model, a</span>
<span class="sd">        :class:`HyperbolicPointFromCoordinates`, are equal. Note that we also</span>
<span class="sd">        treat objects as equal that only differ in their exact representation</span>
<span class="sd">        such as the geodesic x = 1 and the geodesic 2x = 2.</span>

<span class="sd">    TESTS::</span>

<span class="sd">        sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">        sage: from flatsurf.geometry.hyperbolic import HyperbolicConvexSet</span>
<span class="sd">        sage: H = HyperbolicPlane()</span>

<span class="sd">        sage: isinstance(H(0), HyperbolicConvexSet)</span>
<span class="sd">        True</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="HyperbolicConvexSet.half_spaces"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexSet.half_spaces">[docs]</a>    <span class="k">def</span> <span class="nf">half_spaces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a minimal set of half spaces whose intersection is this convex set.</span>

<span class="sd">        Iteration of the half spaces is in counterclockwise order, i.e.,</span>
<span class="sd">        consistent with :meth:`HyperbolicHalfSpaces._lt_`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.vertical(0).left_half_space().half_spaces()</span>
<span class="sd">            {{x ≤ 0},}</span>

<span class="sd">            sage: H.vertical(0).half_spaces()</span>
<span class="sd">            {{x ≤ 0}, {x ≥ 0}}</span>

<span class="sd">            sage: H(0).half_spaces()</span>
<span class="sd">            {{(x^2 + y^2) + x ≤ 0}, {x ≥ 0}}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> does not implement half_spaces()&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_test_half_spaces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify that this convex set implements :meth:`half_spaces` correctly.</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.an_element()._test_half_spaces()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tester</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tester</span><span class="p">(</span><span class="o">**</span><span class="n">options</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">half_spaces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">half_spaces</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># We cannot create half spaces defining a point which has no coordinates over the base ring.</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertIsInstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">HyperbolicPointFromGeodesic</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="n">half_spaces</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">unoriented</span><span class="p">())</span>

        <span class="n">tester</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">half_spaces</span><span class="p">,</span> <span class="n">HyperbolicHalfSpaces</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">half_spaces</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">half_spaces</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="n">HyperbolicHalfSpaces</span><span class="o">.</span><span class="n">_lt_</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">require_normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate this convex subset.</span>

<span class="sd">        Subclasses run specific checks here that can be disabled when creating</span>
<span class="sd">        objects with ``check=False``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``require_normalized`` -- a boolean (default: ``True``); whether to</span>
<span class="sd">          include checks that assume that normalization has already happened</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: P = H.point(0, 0, model=&quot;klein&quot;)</span>
<span class="sd">            sage: P._check()</span>
<span class="sd">            sage: P = H.point(1, 1, model=&quot;klein&quot;, check=False)</span>
<span class="sd">            sage: P._check()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: point (1, 1) is not in the unit disk in the Klein model</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="HyperbolicConvexSet._normalize"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexSet._normalize">[docs]</a>    <span class="k">def</span> <span class="nf">_normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return this set possibly rewritten in a simpler form.</span>

<span class="sd">        This method is only relevant for sets created with ``check=False``.</span>
<span class="sd">        Such sets might have been created in a non-canonical way, e.g., when</span>
<span class="sd">        creating a :class:`HyperbolicOrientedSegment` whose start and end point are ideal,</span>
<span class="sd">        then this is actually a geodesic and it should be described as such.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: segment = H.segment(H.vertical(-1), start=H.infinity(), end=H.infinity(), check=False, assume_normalized=True)</span>
<span class="sd">            sage: segment</span>
<span class="sd">            {-x - 1 = 0} ∩ {x - 1 ≥ 0} ∩ {x - 1 ≤ 0}</span>
<span class="sd">            sage: segment._normalize()</span>
<span class="sd">            ∞</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="k">def</span> <span class="nf">_test_normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify that normalization is idempotent.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: segment = H.segment(H.vertical(-1), start=H.infinity(), end=H.infinity(), check=False, assume_normalized=True)</span>
<span class="sd">            sage: segment._test_normalize()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tester</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tester</span><span class="p">(</span><span class="o">**</span><span class="n">options</span><span class="p">)</span>

        <span class="n">normalization</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize</span><span class="p">()</span>

        <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">normalization</span><span class="p">,</span> <span class="n">normalization</span><span class="o">.</span><span class="n">_normalize</span><span class="p">())</span>

<div class="viewcode-block" id="HyperbolicConvexSet.unoriented"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexSet.unoriented">[docs]</a>    <span class="k">def</span> <span class="nf">unoriented</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the non-oriented version of this set.</span>

<span class="sd">        Some sets such as geodesics and segments can have an explicit</span>
<span class="sd">        orientation. This method returns the underlying set without any</span>
<span class="sd">        explicit orientation.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: H.vertical(0).unoriented()</span>
<span class="sd">            {x = 0}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="n">oriented</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_test_unoriented</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify that :meth:`unoriented` is implemented correctly.</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.an_element()._test_unoriented()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tester</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tester</span><span class="p">(</span><span class="o">**</span><span class="n">options</span><span class="p">)</span>

        <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unoriented</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">unoriented</span><span class="p">()</span><span class="o">.</span><span class="n">unoriented</span><span class="p">())</span>

<div class="viewcode-block" id="HyperbolicConvexSet.intersection"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexSet.intersection">[docs]</a>    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the intersection with the ``other`` convex set.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: H.vertical(0).intersection(H.vertical(1))</span>
<span class="sd">            ∞</span>

<span class="sd">        ..SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicPlane.intersection`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicConvexSet.__contains__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexSet.__contains__">[docs]</a>    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether ``point`` is contained in this set.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H(I) in H.empty_set()</span>
<span class="sd">            False</span>

<span class="sd">            sage: I in H.vertical(0)</span>
<span class="sd">            True</span>

<span class="sd">            sage: 2*I in H.half_circle(0, 1).left_half_space()</span>
<span class="sd">            True</span>

<span class="sd">            sage: I/2 in H.half_circle(0, 1).left_half_space()</span>
<span class="sd">            False</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            There is currently no way to check whether a point is in the</span>
<span class="sd">            interior of a set.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicConvexSet.is_subset` to check containment of</span>
<span class="sd">            arbitrary sets.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">half_space</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">half_spaces</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">point</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">half_space</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div>

    <span class="k">def</span> <span class="nf">_test_contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify that :meth:`__contains__` is implemented correctly.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: H.vertical(0)._test_contains()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tester</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tester</span><span class="p">(</span><span class="o">**</span><span class="n">options</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">tester</span><span class="o">.</span><span class="n">assertIn</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># Currently, containment can often not be decided when points</span>
                <span class="c1"># do not have coordinates over the base ring.</span>
                <span class="n">tester</span><span class="o">.</span><span class="n">assertIsInstance</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">HyperbolicPointFromGeodesic</span><span class="p">)</span>

<div class="viewcode-block" id="HyperbolicConvexSet.vertices"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexSet.vertices">[docs]</a>    <span class="k">def</span> <span class="nf">vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">marked_vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the vertices bounding this hyperbolic set.</span>

<span class="sd">        This returns both finite and ideal vertices.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``marked_vertices`` -- a boolean (default: ``True``) whether to</span>
<span class="sd">          include marked vertices that are not actual cornerns of the convex</span>
<span class="sd">          set.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        A set of points, namely :class:`HyperbolicVertices`. Iteration of this</span>
<span class="sd">        set happens incounterclockwise order (as seen from the inside of the</span>
<span class="sd">        convex set.)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        The empty set has no vertices::</span>

<span class="sd">            sage: H.empty_set().vertices()</span>
<span class="sd">            {}</span>

<span class="sd">        A point is its own vertex::</span>

<span class="sd">            sage: H(0).vertices()</span>
<span class="sd">            {0,}</span>
<span class="sd">            sage: H(I).vertices()</span>
<span class="sd">            {I,}</span>
<span class="sd">            sage: H(oo).vertices()</span>
<span class="sd">            {∞,}</span>

<span class="sd">        The vertices of a geodesic are its ideal end points::</span>

<span class="sd">            sage: H.vertical(0).vertices()</span>
<span class="sd">            {0, ∞}</span>

<span class="sd">        The vertices of a half space are the ideal end points of its boundary geodesic::</span>

<span class="sd">            sage: H.vertical(0).left_half_space().vertices()</span>
<span class="sd">            {0, ∞}</span>

<span class="sd">        The vertices a polygon can be finite and ideal::</span>

<span class="sd">            sage: P = H.polygon([H.vertical(0).left_half_space(), H.half_circle(0, 1).left_half_space()])</span>
<span class="sd">            sage: P.vertices()</span>
<span class="sd">            {-1, I, ∞}</span>

<span class="sd">        If a polygon has marked vertices they are included::</span>

<span class="sd">            sage: P = H.polygon([H.vertical(0).left_half_space(), H.half_circle(0, 1).left_half_space()], marked_vertices=[2*I])</span>
<span class="sd">            sage: P.vertices()</span>
<span class="sd">            {-1, I, 2*I, ∞}</span>

<span class="sd">            sage: P.vertices(marked_vertices=False)</span>
<span class="sd">            {-1, I, ∞}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
            <span class="o">.</span><span class="n">polygon</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">half_spaces</span><span class="p">(),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">assume_minimal</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicConvexSet.is_finite"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexSet.is_finite">[docs]</a>    <span class="k">def</span> <span class="nf">is_finite</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether all points in this set are finite.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.empty_set().is_finite()</span>
<span class="sd">            True</span>

<span class="sd">            sage: H.vertical(0).is_finite()</span>
<span class="sd">            False</span>

<span class="sd">            sage: H.vertical(0).left_half_space().is_finite()</span>
<span class="sd">            False</span>

<span class="sd">            sage: H(I).segment(2*I).is_finite()</span>
<span class="sd">            True</span>

<span class="sd">            sage: H(0).segment(I).is_finite()</span>
<span class="sd">            False</span>

<span class="sd">            sage: P = H.polygon([</span>
<span class="sd">            ....:     H.vertical(-1).right_half_space(),</span>
<span class="sd">            ....:     H.vertical(1).left_half_space(),</span>
<span class="sd">            ....:     H.half_circle(0, 1).left_half_space(),</span>
<span class="sd">            ....:     H.half_circle(0, 4).right_half_space(),</span>
<span class="sd">            ....: ])</span>
<span class="sd">            sage: P.is_finite()</span>
<span class="sd">            False</span>

<span class="sd">            sage: P = H.polygon([</span>
<span class="sd">            ....:     H.vertical(-1).right_half_space(),</span>
<span class="sd">            ....:     H.vertical(1).left_half_space(),</span>
<span class="sd">            ....:     H.half_circle(0, 2).left_half_space(),</span>
<span class="sd">            ....:     H.half_circle(0, 4).right_half_space(),</span>
<span class="sd">            ....: ])</span>
<span class="sd">            sage: P.is_finite()</span>
<span class="sd">            True</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`is_ideal` and :meth:`is_ultra_ideal` for complementary notions</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">vertex</span><span class="o">.</span><span class="n">is_finite</span><span class="p">()</span> <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">(</span><span class="n">marked_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicConvexSet.is_ideal"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexSet.is_ideal">[docs]</a>    <span class="k">def</span> <span class="nf">is_ideal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether all points in this set are ideal.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.empty_set().is_ideal()</span>
<span class="sd">            True</span>

<span class="sd">            sage: H.vertical(0).is_ideal()</span>
<span class="sd">            False</span>

<span class="sd">            sage: H.vertical(0).start().is_ideal()</span>
<span class="sd">            True</span>

<span class="sd">            sage: H(I).is_ideal()</span>
<span class="sd">            False</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`is_finite` and :meth:`is_ultra_ideal` for complementary notions</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">is_ideal</span><span class="p">()</span> <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">(</span><span class="n">marked_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span></div>

<div class="viewcode-block" id="HyperbolicConvexSet.is_ultra_ideal"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexSet.is_ultra_ideal">[docs]</a>    <span class="k">def</span> <span class="nf">is_ultra_ideal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether all points in this set are ultra-ideal, i.e., the</span>
<span class="sd">        correspond to points outside the Klein disk.</span>

<span class="sd">        Note that it is normally not possible to create ultra ideal sets</span>
<span class="sd">        (except for the actual empty set.) They only exist internally during</span>
<span class="sd">        geometric constructions in the Euclidean plane containing the Klein</span>
<span class="sd">        disk.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.empty_set().is_ultra_ideal()</span>
<span class="sd">            True</span>

<span class="sd">            sage: H.vertical(0).is_ultra_ideal()</span>
<span class="sd">            False</span>

<span class="sd">        Normally, ultra-ideal objects are not permitted. They can often be created with the ``check=False`` keyword::</span>

<span class="sd">            sage: H.point(2, 0, check=False, model=&quot;klein&quot;).is_ultra_ideal()</span>
<span class="sd">            True</span>

<span class="sd">            sage: H.geodesic(2, 0, 1, check=False, model=&quot;klein&quot;).is_ultra_ideal()</span>
<span class="sd">            True</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`is_finite` and :meth:`is_ultra_ideal` for complementary notions</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
            <span class="ow">not</span> <span class="n">vertex</span><span class="o">.</span><span class="n">is_ultra_ideal</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">(</span><span class="n">marked_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> does not implement is_ultra_ideal() yet&quot;</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_test_is_finite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify that :meth;`is_finite`, :meth:`is_ideal`, and</span>
<span class="sd">        :meth:`is_ultra_ideal` are implemented correctly for this set.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.empty_set()._test_is_finite()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tester</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tester</span><span class="p">(</span><span class="o">**</span><span class="n">options</span><span class="p">)</span>

        <span class="n">finite</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite</span><span class="p">()</span>
        <span class="n">ideal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ideal</span><span class="p">()</span>
        <span class="n">ultra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ultra_ideal</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="n">finite</span><span class="p">)</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="n">ideal</span><span class="p">)</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="n">ultra</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">finite</span><span class="p">:</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertFalse</span><span class="p">(</span><span class="n">ideal</span><span class="p">)</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertFalse</span><span class="p">(</span><span class="n">ultra</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ideal</span><span class="p">:</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertFalse</span><span class="p">(</span><span class="n">finite</span><span class="p">)</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertFalse</span><span class="p">(</span><span class="n">ultra</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ultra</span><span class="p">:</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertFalse</span><span class="p">(</span><span class="n">finite</span><span class="p">)</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertFalse</span><span class="p">(</span><span class="n">ideal</span><span class="p">)</span>

<div class="viewcode-block" id="HyperbolicConvexSet.change_ring"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexSet.change_ring">[docs]</a>    <span class="k">def</span> <span class="nf">change_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return this set as an element of the hyperbolic plane over ``ring``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: p = H(0)</span>
<span class="sd">            sage: q = p.change_ring(AA)</span>
<span class="sd">            sage: q.parent().base_ring()</span>
<span class="sd">            Algebraic Real Field</span>

<span class="sd">        Changing the base ring can provide coordinates for points::</span>

<span class="sd">            sage: p = H.half_circle(0, 2).start()</span>
<span class="sd">            sage: p.coordinates()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: ...</span>

<span class="sd">            sage: q = p.change_ring(AA)</span>
<span class="sd">            sage: q.coordinates()</span>
<span class="sd">            (-1.414213562373095?, 0)</span>

<span class="sd">        Note that changing the ring only works in relatively trivial cases::</span>

<span class="sd">            sage: q = HyperbolicPlane(AA).point(sqrt(2), 0, model=&quot;half_plane&quot;)</span>

<span class="sd">            sage: p = q.change_ring(QQ)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: ...</span>

<span class="sd">        Most other sets also support changing the base ring::</span>

<span class="sd">            sage: g = H.half_circle(0, 2)</span>
<span class="sd">            sage: g.start().coordinates()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: ...</span>

<span class="sd">            sage: g.change_ring(AA).start().coordinates()</span>
<span class="sd">            (-1.414213562373095?, 0)</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`change` for a more general interface to changing properties</span>
<span class="sd">            of hyperbolic sets.</span>

<span class="sd">            :meth:`HyperbolicPlane.change_ring` for the hyperbolic plane that</span>
<span class="sd">            the resulting objects lives in.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="n">ring</span><span class="o">=</span><span class="n">ring</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_test_change_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify that this set implements :meth:`change_ring`.</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.an_element()._test_change_ring()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tester</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tester</span><span class="p">(</span><span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()))</span>

<div class="viewcode-block" id="HyperbolicConvexSet.change"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexSet.change">[docs]</a>    <span class="k">def</span> <span class="nf">change</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">oriented</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a modified copy of this set.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``ring`` -- a ring (default: ``None`` to keep the current</span>
<span class="sd">          :meth:`~HyperbolicPlane.base_ring`); the ring over which the new set</span>
<span class="sd">          will be defined.</span>

<span class="sd">        - ``geometry`` -- a :class:`HyperbolicGeometry` (default: ``None`` to</span>
<span class="sd">          keep the current geometry); the geometry that will be used for the</span>
<span class="sd">          new set.</span>

<span class="sd">        - ``oriented`` -- a boolean (default: ``None`` to keep the current</span>
<span class="sd">          orientedness) whether the new set will be explicitly oriented.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: geodesic = H.geodesic(0, 1)</span>

<span class="sd">        We can change the base ring over which this set is defined::</span>

<span class="sd">            sage: geodesic.change(ring=AA)</span>
<span class="sd">            {(x^2 + y^2) - x = 0}</span>

<span class="sd">        We can drop the explicit orientation of a set::</span>

<span class="sd">            sage: unoriented = geodesic.change(oriented=False)</span>
<span class="sd">            sage: unoriented.is_oriented()</span>
<span class="sd">            False</span>

<span class="sd">        We can also take an unoriented set and pick an orientation::</span>

<span class="sd">            sage: oriented = geodesic.change(oriented=True)</span>
<span class="sd">            sage: oriented.is_oriented()</span>
<span class="sd">            True</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`is_oriented` for oriented an unoriented sets.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;this </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> does not implement change()&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_test_change</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify that the full interface of :meth:`change` has been implemented.</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.an_element()._test_change()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tester</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tester</span><span class="p">(</span><span class="o">**</span><span class="n">options</span><span class="p">)</span>

        <span class="c1"># The ring parameter is supported</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="n">ring</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()))</span>

        <span class="c1"># The geometry parameter is supported</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geometry</span><span class="p">))</span>

        <span class="c1"># The oriented parameter is supported</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="n">oriented</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="n">oriented</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="n">oriented</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="n">oriented</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="n">oriented</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

<div class="viewcode-block" id="HyperbolicConvexSet.plot"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexSet.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a plot of this subset.</span>

<span class="sd">        Consult the implementation in the subclasses for a list supported</span>
<span class="sd">        keyword arguments, in particular :meth:`HyperbolicConvexPolygon.plot`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``model`` -- one of ``&quot;half_plane&quot;`` and ``&quot;klein&quot;`` (default: ``&quot;half_plane&quot;``)</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        .. jupyter-execute::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.vertical(0).plot()  # long time (.5s)</span>
<span class="sd">            ...Graphics object consisting of 1 graphics primitive</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;this </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> does not support plotting&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_test_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify that this set implements :meth:`plot`.</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.an_element()._test_plot()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">Graphics</span>

        <span class="n">tester</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tester</span><span class="p">(</span><span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">infinity</span><span class="p">():</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertIsInstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(),</span> <span class="n">Graphics</span><span class="p">)</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertIsInstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">),</span> <span class="n">Graphics</span><span class="p">)</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertIsInstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">),</span> <span class="n">Graphics</span><span class="p">)</span>

<div class="viewcode-block" id="HyperbolicConvexSet.apply_isometry"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexSet.apply_isometry">[docs]</a>    <span class="k">def</span> <span class="nf">apply_isometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">isometry</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">,</span> <span class="n">on_right</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the image of this set under the ``isometry``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``isometry`` -- a 2×2 matrix in `GL(2,\mathbb{R})`, if ``model`` is</span>
<span class="sd">          ``&quot;half_plane&quot;``, or a 3×3 matrix giving a similitude that preserves</span>
<span class="sd">          a quadratic form of type `(1, 2)`, if ``model`` is ``&quot;klein&quot;``.</span>

<span class="sd">        - ``model`` -- a string (default: ``&quot;half_plane&quot;``); either</span>
<span class="sd">          ``&quot;half_plane&quot;`` or ``&quot;klein&quot;``</span>

<span class="sd">        - ``on_right`` -- a boolean (default: ``False``) whether to apply the</span>
<span class="sd">          right action.</span>

<span class="sd">        ALGORITHM:</span>

<span class="sd">        If ``model`` is ``&quot;half_plane&quot;``, the 2×2 matrix with entries `a, b, c,</span>
<span class="sd">        d` encodes a fractional linear transformation sending</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            z \mapsto \frac{az + b}{cz + d}</span>

<span class="sd">        if the determinant is positive, and</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            z \mapsto \frac{a\bar{z} + b}{a\bar{z} + d}</span>

<span class="sd">        if the determinant is negative. Note that these maps are invariant</span>
<span class="sd">        under scaling the matrix with a non-zero real.</span>

<span class="sd">        In any case, we convert the matrix to a corresponding 3×3 matrix, see</span>
<span class="sd">        :meth:`HyperbolicPlane._isometry_gl2_to_sim12` and apply the isometry</span>
<span class="sd">        in the Klein model.</span>

<span class="sd">        To apply an isometry in the Klein model, we lift objects to the</span>
<span class="sd">        hyperboloid model, apply the isometry given by the 3×3 matrix there,</span>
<span class="sd">        and then project to the Klein model again.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        The horizontal translation by 1 in the upper half plane model, a</span>
<span class="sd">        parabolic isometry::</span>

<span class="sd">            sage: isometry = matrix([[1, 1], [0, 1]])</span>
<span class="sd">            sage: H.vertical(0).apply_isometry(isometry)</span>
<span class="sd">            {-x + 1 = 0}</span>

<span class="sd">        The same isometry as an isometry of the hyperboloid model::</span>

<span class="sd">            sage: isometry = matrix([[1, -1, 1], [1, 1/2, 1/2], [1, -1/2, 3/2]])</span>
<span class="sd">            sage: H.vertical(0).apply_isometry(isometry, model=&quot;klein&quot;)</span>
<span class="sd">            {-x + 1 = 0}</span>

<span class="sd">        An elliptic isometry::</span>

<span class="sd">            sage: isometry = matrix([[1, -1], [1, 1]])</span>
<span class="sd">            sage: H.vertical(0).apply_isometry(isometry)</span>
<span class="sd">            {(x^2 + y^2) - 1 = 0}</span>

<span class="sd">        A hyperbolic isometry::</span>

<span class="sd">            sage: isometry = matrix([[1, 0], [0, 1/2]])</span>
<span class="sd">            sage: H.vertical(0).apply_isometry(isometry)</span>
<span class="sd">            {-x = 0}</span>
<span class="sd">            sage: H(I).apply_isometry(isometry)</span>
<span class="sd">            2*I</span>

<span class="sd">        A reflection::</span>

<span class="sd">            sage: isometry = matrix([[-1, 0], [0, 1]])</span>
<span class="sd">            sage: H.vertical(0).apply_isometry(isometry)</span>
<span class="sd">            {x = 0}</span>

<span class="sd">        A glide reflection::</span>

<span class="sd">            sage: isometry = matrix([[-1, 0], [0, 1/2]])</span>
<span class="sd">            sage: H.vertical(0).apply_isometry(isometry)</span>
<span class="sd">            {x = 0}</span>
<span class="sd">            sage: H.vertical(1).apply_isometry(isometry)</span>
<span class="sd">            {x + 2 = 0}</span>

<span class="sd">        An isometry of the upper half plane must have non-zero determinant::</span>

<span class="sd">            sage: isometry = matrix([[1, 0], [1, 0]])</span>
<span class="sd">            sage: H.vertical(0).apply_isometry(isometry)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: matrix does not define an isometry</span>

<span class="sd">        An isometry of the Klein model, must preserve a quadratic form of type</span>
<span class="sd">        `(1, 2)`::</span>

<span class="sd">            sage: isometry = matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])</span>
<span class="sd">            sage: H.vertical(0).apply_isometry(isometry, model=&quot;klein&quot;)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: matrix does not define an isometry</span>

<span class="sd">        Isometries can be applied to half spaces::</span>

<span class="sd">            sage: isometry = matrix([[1, 1], [0, 1]])</span>
<span class="sd">            sage: H.vertical(0).left_half_space().apply_isometry(isometry)</span>
<span class="sd">            {x - 1 ≤ 0}</span>

<span class="sd">        Isometries can be applied to points::</span>

<span class="sd">            sage: H(I).apply_isometry(isometry)</span>
<span class="sd">            1 + I</span>

<span class="sd">        Isometries can be applied to polygons::</span>

<span class="sd">            sage: P = H.polygon([</span>
<span class="sd">            ....:   H.vertical(1).left_half_space(),</span>
<span class="sd">            ....:   H.vertical(-1).right_half_space(),</span>
<span class="sd">            ....:   H.half_circle(0, 1).left_half_space(),</span>
<span class="sd">            ....:   H.half_circle(0, 4).right_half_space(),</span>
<span class="sd">            ....: ], marked_vertices=[I])</span>
<span class="sd">            sage: P.apply_isometry(isometry)</span>
<span class="sd">            {(x^2 + y^2) - 2*x ≥ 0} ∩ {x - 2 ≤ 0} ∩ {(x^2 + y^2) - 2*x - 3 ≤ 0} ∩ {x ≥ 0} ∪ {1 + I}</span>

<span class="sd">        Isometries can be applied to segments::</span>

<span class="sd">            sage: segment = H(I).segment(2*I)</span>
<span class="sd">            sage: segment.apply_isometry(isometry)</span>
<span class="sd">            {-x + 1 = 0} ∩ {2*(x^2 + y^2) - 3*x - 1 ≥ 0} ∩ {(x^2 + y^2) - 3*x - 2 ≤ 0}</span>

<span class="sd">        REFERENCES:</span>

<span class="sd">        - Svetlana Katok, &quot;Fuchsian Groups&quot;, Chicago University Press, Section</span>
<span class="sd">          1.3; for the isometries of the upper half plane.</span>

<span class="sd">        - James W. Cannon, William J. Floyd, Richard Kenyon, and Walter R.</span>
<span class="sd">          Parry, &quot;Hyperbolic Geometry&quot;, Flavors of Geometry, MSRI Publications,</span>
<span class="sd">          Volume 31, 1997, Section 10; for the isometries as 3×3 matrices.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s2">&quot;half_plane&quot;</span><span class="p">:</span>
            <span class="n">isometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">_isometry_gl2_to_sim12</span><span class="p">(</span><span class="n">isometry</span><span class="p">)</span>
            <span class="n">model</span> <span class="o">=</span> <span class="s2">&quot;klein&quot;</span>

        <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s2">&quot;klein&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">isometry</span><span class="o">.</span><span class="n">dimensions</span><span class="p">()</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;isometry in Klein model must be given as a 3×3 matrix&quot;</span>
                <span class="p">)</span>

            <span class="n">isometry</span> <span class="o">=</span> <span class="n">isometry</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">base_ring</span><span class="p">())</span>

            <span class="c1"># Check that the matrix defines an isometry in the hyperboloid</span>
            <span class="c1"># model, see CFJK &quot;Hyperbolic Geometry&quot; Theorem 10.1</span>
            <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">diagonal_matrix</span>

            <span class="n">D</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">isometry</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
                <span class="o">*</span> <span class="n">diagonal_matrix</span><span class="p">(</span><span class="n">isometry</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">base_ring</span><span class="p">(),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="o">*</span> <span class="n">isometry</span>
            <span class="p">)</span>

            <span class="c1"># These checks should use a specialized predicate of the geometry</span>
            <span class="c1"># of this space so they are more robust over inexact rings.</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">D</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_zero</span><span class="p">(</span><span class="n">entry</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;matrix does not define an isometry&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_equal</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">D</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;matrix does not define an isometry&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_equal</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">D</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;matrix does not define an isometry&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_isometry_klein</span><span class="p">(</span><span class="n">isometry</span><span class="p">,</span> <span class="n">on_right</span><span class="o">=</span><span class="n">on_right</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot apply isometries in this model yet&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_apply_isometry_klein</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">isometry</span><span class="p">,</span> <span class="n">on_right</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the result of applying the ``isometry`` to this hyperbolic set.</span>

<span class="sd">        Helper methed for :meth:`apply_isometry`. Hyperbolic sets implement</span>
<span class="sd">        this method which is not implemented generically.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``isometry`` -- a 3×3 matrix over the</span>
<span class="sd">          :meth:`~HyperbolicPlane.base_ring` describing an isometry in the</span>
<span class="sd">          hyperboloid model.</span>

<span class="sd">        - ``on_right`` -- a boolean (default: ``False``); whether to return the</span>
<span class="sd">          result of the right action.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: isometry = matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]])</span>
<span class="sd">            sage: H.empty_set()._apply_isometry_klein(isometry)</span>
<span class="sd">            {}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> does not implement _apply_isometry_klein() yet&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_acted_upon_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">self_on_left</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the result of acting upon this set with ``x``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``x`` -- an isometry encoded as a 2×2 matrix, see</span>
<span class="sd">          :meth:`apply_isometry`</span>

<span class="sd">        - ``self_on_left`` -- a boolean; whether this is the right action or</span>
<span class="sd">          the left action</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        We apply the Möbius transformation that sends `z` to `(1 + 2z)/(3 +</span>
<span class="sd">        4z)`::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: p = H(I)</span>
<span class="sd">            sage: m = matrix([[1, 2], [3, 4]])</span>
<span class="sd">            sage: m * p</span>
<span class="sd">            11/25 + 2/25*I</span>
<span class="sd">            sage: p * m</span>
<span class="sd">            -7/5 + 1/5*I</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: m0 = matrix(2, [1, 2, 3, 4])</span>
<span class="sd">            sage: m1 = matrix(2, [1, 1, 0, 1])</span>
<span class="sd">            sage: p = HyperbolicPlane()(I + 1)</span>
<span class="sd">            sage: assert (m0 * m1) * p == m0 * (m1 * p)</span>
<span class="sd">            sage: assert p * (m0 * m1) == (p * m0) * m1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_isometry</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_right</span><span class="o">=</span><span class="n">self_on_left</span><span class="p">)</span>

<div class="viewcode-block" id="HyperbolicConvexSet.is_subset"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexSet.is_subset">[docs]</a>    <span class="k">def</span> <span class="nf">is_subset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this set is a subset of ``other``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``other`` -- another hyperbolic convex set</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H(I).is_subset(H.vertical(0))</span>
<span class="sd">            True</span>

<span class="sd">            sage: H.vertical(0).is_subset(H(I))</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">dimension</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">other</span>

        <span class="c1"># Make sure that we do not get confused by marked vertices</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">half_spaces</span><span class="p">())</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span></div>

    <span class="k">def</span> <span class="nf">_test_is_subset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify that :meth:`is_subset` is implemented correctly.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.an_element()._test_is_subset()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tester</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tester</span><span class="p">(</span><span class="o">**</span><span class="n">options</span><span class="p">)</span>

        <span class="n">tester</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_subset</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">half_spaces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">half_spaces</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># We cannot determine half spaces for points whose coordinates are not over the base ring.</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertIsInstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">HyperbolicPointFromGeodesic</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_subset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="n">half_spaces</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_an_element_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a point of this set.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        The returned element can be a finite point::</span>

<span class="sd">            sage: H.vertical(0).an_element()</span>
<span class="sd">            I</span>

<span class="sd">        But it can also be an infinite point::</span>

<span class="sd">            sage: H(0).segment(I).an_element()</span>
<span class="sd">            0</span>

<span class="sd">        An exception is raised when there are no elements in this set::</span>

<span class="sd">            sage: H.empty_set().an_element()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            Exception: empty set has no points</span>

<span class="sd">        We get an element for geodesics without end points in the base ring,</span>
<span class="sd">        see :meth:`HyperbolicGeodesic._an_element_`::</span>

<span class="sd">            sage: H.half_circle(0, 2).an_element()</span>
<span class="sd">            (0, 1/3)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">vertices</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;cannot return points of this set yet because it has no vertices&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">vertices</span><span class="p">))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_enhance_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plot</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modify the ``plot`` of this set to improve the resulting plot.</span>

<span class="sd">        Currently, this adds the unit circle to plots in the Klein disk model.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        .. jupyter-execute::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: p = H(0)</span>
<span class="sd">            sage: plot = plot([])</span>

<span class="sd">            sage: type(p)._enhance_plot(plot, model=&quot;half_plane&quot;)</span>
<span class="sd">            ...Graphics object consisting of 0 graphics primitives</span>

<span class="sd">        .. jupyter-execute::</span>

<span class="sd">            sage: type(p)._enhance_plot(plot, model=&quot;klein&quot;)</span>
<span class="sd">            ...Graphics object consisting of 1 graphics primitive</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s2">&quot;klein&quot;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">circle</span>

            <span class="n">plot</span> <span class="o">=</span> <span class="n">circle</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;#d1d1d1&quot;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">plot</span>

        <span class="k">return</span> <span class="n">plot</span>

<div class="viewcode-block" id="HyperbolicConvexSet.is_empty"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexSet.is_empty">[docs]</a>    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this set is empty.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H(0).is_empty()</span>
<span class="sd">            False</span>

<span class="sd">            sage: H.empty_set().is_empty()</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="HyperbolicConvexSet.__bool__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexSet.__bool__">[docs]</a>    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this set is non-empty.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: bool(H(0))</span>
<span class="sd">            True</span>

<span class="sd">            sage: bool(H.empty_set())</span>
<span class="sd">            False</span>

<span class="sd">        .. SEEALSO:</span>

<span class="sd">            :meth:`HyperbolicConvexSet.is_empty`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_empty</span><span class="p">()</span></div>

<div class="viewcode-block" id="HyperbolicConvexSet.dimension"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexSet.dimension">[docs]</a>    <span class="k">def</span> <span class="nf">dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the dimension of this set.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        An integer, one of -1, 0, 1, 2.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        We treat the empty set as -1-dimensional::</span>

<span class="sd">            sage: H.empty_set().dimension()</span>
<span class="sd">            -1</span>

<span class="sd">        Points are zero-dimensional::</span>

<span class="sd">            sage: H(0).dimension()</span>
<span class="sd">            0</span>

<span class="sd">        Geodesics and segments are one-dimensional::</span>

<span class="sd">            sage: H.vertical(0).dimension()</span>
<span class="sd">            1</span>

<span class="sd">            sage: H(I).segment(2*I).dimension()</span>
<span class="sd">            1</span>

<span class="sd">        Polygons and half spaces are two dimensional::</span>

<span class="sd">            sage: H.random_element(&quot;polygon&quot;).dimension()</span>
<span class="sd">            2</span>

<span class="sd">            sage: H.vertical(0).left_half_space().dimension()</span>
<span class="sd">            2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> does not implement dimension() yet&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_test_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify that :meth:`dimension` is implemented correctly.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.empty_set()._test_dimension()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tester</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tester</span><span class="p">(</span><span class="o">**</span><span class="n">options</span><span class="p">)</span>

        <span class="n">dimension</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>

        <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">ZZ</span>

        <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">dimension</span><span class="o">.</span><span class="n">parent</span><span class="p">(),</span> <span class="n">ZZ</span><span class="p">)</span>

        <span class="n">tester</span><span class="o">.</span><span class="n">assertIn</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

        <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unoriented</span><span class="p">()</span><span class="o">.</span><span class="n">dimension</span><span class="p">(),</span> <span class="n">dimension</span><span class="p">)</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_point</span><span class="p">(),</span> <span class="n">dimension</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_empty</span><span class="p">(),</span> <span class="n">dimension</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="HyperbolicConvexSet.is_point"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexSet.is_point">[docs]</a>    <span class="k">def</span> <span class="nf">is_point</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this set is a single point.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H(0).is_point()</span>
<span class="sd">            True</span>

<span class="sd">            sage: H(I).is_point()</span>
<span class="sd">            True</span>

<span class="sd">            sage: H.empty_set().is_point()</span>
<span class="sd">            False</span>

<span class="sd">            sage: H.vertical(0).is_point()</span>
<span class="sd">            False</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`is_ideal` to check whether this is a finite or an infinite</span>
<span class="sd">            point</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="HyperbolicConvexSet.is_oriented"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexSet.is_oriented">[docs]</a>    <span class="k">def</span> <span class="nf">is_oriented</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this is a set with an explicit orientation.</span>

<span class="sd">        Some sets come in two flavors. There are oriented geodesics and</span>
<span class="sd">        unoriented geodesics. There are oriented segments and unoriented</span>
<span class="sd">        segments.</span>

<span class="sd">        This method answers whether a set is of the oriented kind if there is a</span>
<span class="sd">        choice.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        Normally, geodesics are oriented::</span>

<span class="sd">            sage: g = H.vertical(0)</span>
<span class="sd">            sage: g.is_oriented()</span>
<span class="sd">            True</span>

<span class="sd">            sage: g.start()</span>
<span class="sd">            0</span>

<span class="sd">            sage: g.end()</span>
<span class="sd">            ∞</span>

<span class="sd">        We can ask explicitly for an unoriented version::</span>

<span class="sd">            sage: h = g.unoriented()</span>
<span class="sd">            sage: h.is_oriented()</span>
<span class="sd">            False</span>

<span class="sd">            sage: h.start()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            AttributeError: ... has no attribute &#39;start&#39;...</span>

<span class="sd">        Segments are oriented::</span>

<span class="sd">            sage: s = H(I).segment(2*I)</span>
<span class="sd">            sage: s.is_oriented()</span>
<span class="sd">            True</span>

<span class="sd">            sage: s.start()</span>
<span class="sd">            I</span>

<span class="sd">            sage: s.end()</span>
<span class="sd">            2*I</span>

<span class="sd">        We can ask explicitly for an unoriented segment::</span>

<span class="sd">            sage: u = s.unoriented()</span>
<span class="sd">            sage: u.is_oriented()</span>
<span class="sd">            False</span>

<span class="sd">            sage: u.start()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            AttributeError: ... has no attribute &#39;start&#39;...</span>

<span class="sd">        Points are not oriented as there is no choice of orientation::</span>

<span class="sd">            sage: H(0).is_oriented()</span>
<span class="sd">            False</span>

<span class="sd">        Half spaces are not oriented:</span>

<span class="sd">            sage: H.vertical(0).left_half_space().is_oriented()</span>
<span class="sd">            False</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`change` to pick an orientation on an unoriented set</span>

<span class="sd">            :meth:`HyperbolicHalfSpace.__neg__`,</span>
<span class="sd">            :meth:`HyperbolicOrientedGeodesic.__neg__`,</span>
<span class="sd">            :meth:`HyperbolicOrientedSegment.__neg__` i.e., the ``-`` operator,</span>
<span class="sd">            to invert the orientation of a set</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">HyperbolicOrientedConvexSet</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_test_is_oriented</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify that this set implements :meth:`is_oriented` correctly.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.empty_set()._test_is_oriented()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tester</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tester</span><span class="p">(</span><span class="o">**</span><span class="n">options</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">():</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertNotEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="p">)</span>

            <span class="c1"># Verify that neg inverts the orientation of the set</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="p">))</span>

<div class="viewcode-block" id="HyperbolicConvexSet.edges"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexSet.edges">[docs]</a>    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">as_segments</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">marked_vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the :class:`segments &lt;HyperbolicOrientedSegment&gt;` and</span>
<span class="sd">        :class:`geodesics &lt;HyperbolicOrientedGeodesic&gt;` that bound this set.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``as_segments`` -- a boolean (default: ``False``); whether to also</span>
<span class="sd">          return the geodesics as segments with ideal end points.</span>

<span class="sd">        - ``marked_vertices`` -- a boolean (default: ``True``); whether to</span>
<span class="sd">          report segments that start or end at redundant marked vertices or</span>
<span class="sd">          otherwise whether such marked vertices are completely ignored.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        A set of segments and geodesics. Iteration through this set is in</span>
<span class="sd">        counterclockwise order with respect to the points of the set.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        The edges of a polygon::</span>

<span class="sd">            sage: P = H.intersection(</span>
<span class="sd">            ....:   H.vertical(-1).right_half_space(),</span>
<span class="sd">            ....:   H.vertical(1).left_half_space(),</span>
<span class="sd">            ....:   H.half_circle(0, 2).left_half_space())</span>

<span class="sd">            sage: P.edges()</span>
<span class="sd">            {{-x + 1 = 0} ∩ {2*(x^2 + y^2) - 3*x - 1 ≥ 0}, {x + 1 = 0} ∩ {2*(x^2 + y^2) + 3*x - 1 ≥ 0}, {(x^2 + y^2) - 2 = 0} ∩ {(x^2 + y^2) + 3*x + 1 ≥ 0} ∩ {(x^2 + y^2) - 3*x + 1 ≥ 0}}</span>

<span class="sd">        The single edge of a half space:</span>

<span class="sd">            sage: H.vertical(0).left_half_space().edges()</span>
<span class="sd">            {{-x = 0},}</span>

<span class="sd">        A geodesic and a segment are bounded by two edges::</span>

<span class="sd">            sage: H.vertical(0).edges()</span>
<span class="sd">            {{-x = 0}, {x = 0}}</span>

<span class="sd">            sage: H(I).segment(2*I).edges()</span>
<span class="sd">            {{-x = 0} ∩ {(x^2 + y^2) - 1 ≥ 0} ∩ {(x^2 + y^2) - 4 ≤ 0}, {x = 0} ∩ {(x^2 + y^2) - 4 ≤ 0} ∩ {(x^2 + y^2) - 1 ≥ 0}}</span>

<span class="sd">        Lower dimensional objects have no edges:</span>

<span class="sd">            sage: H(I).edges()</span>
<span class="sd">            {}</span>

<span class="sd">            sage: H.empty_set().edges()</span>
<span class="sd">            {}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span><span class="o">.</span><span class="n">pairs</span><span class="p">():</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">is_ideal</span><span class="p">()</span> <span class="ow">and</span> <span class="n">w</span><span class="o">.</span><span class="n">is_ideal</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">right_half_space</span><span class="p">()</span><span class="o">.</span><span class="n">is_subset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">as_segments</span><span class="p">:</span>
                    <span class="n">edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">assume_normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">HyperbolicSegment</span><span class="p">)</span>

            <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">HyperbolicEdges</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_test_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify that this set implements :meth:`edges` correctly.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.empty_set()._test_edges()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tester</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tester</span><span class="p">(</span><span class="o">**</span><span class="n">options</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">is_exact</span><span class="p">():</span>
            <span class="c1"># Inexact base rings typically do not allow hashing of coordinates</span>
            <span class="c1"># which is needed for the set below.</span>
            <span class="k">return</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
        <span class="n">endpoints</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
            <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">endpoints</span><span class="p">,</span> <span class="n">vertices</span><span class="p">)</span>

<div class="viewcode-block" id="HyperbolicConvexSet.__hash__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexSet.__hash__">[docs]</a>    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a hash value for this convex set.</span>

<span class="sd">        Specific sets should override this method.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: hash(H.empty_set())</span>
<span class="sd">            0</span>

<span class="sd">        Note that has values of sets over different base rings might not be</span>
<span class="sd">        consistent::</span>

<span class="sd">            sage: HyperbolicPlane(ZZ).half_circle(0, 2) == HyperbolicPlane(AA).half_circle(0, 2)</span>
<span class="sd">            True</span>

<span class="sd">            sage: hash(HyperbolicPlane(ZZ).half_circle(0, 2)) == hash(HyperbolicPlane(AA).half_circle(0, 2))</span>
<span class="sd">            False</span>

<span class="sd">        Sets over inexact base rings are not be hashable (since their hash</span>
<span class="sd">        would not be compatible with the notion of equality)::</span>

<span class="sd">            sage: hash(HyperbolicPlane(RR).vertical(0))</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            TypeError: cannot hash geodesic defined over inexact base ring</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;the set </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> is not hashable&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_test_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify that this set implements a good hash function.</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.an_element()._test_plot()</span>

<span class="sd">        Nothing is tested for unhashable sets::</span>

<span class="sd">            sage: H = HyperbolicPlane(RR)</span>

<span class="sd">            sage: H.an_element()._test_hash()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tester</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tester</span><span class="p">(</span><span class="o">**</span><span class="n">options</span><span class="p">)</span>

        <span class="c1"># We refuse to hash inexact elements.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">is_exact</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
                <span class="k">with</span> <span class="n">tester</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">):</span>
                    <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">tester</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="c1"># We test that the hash function is good enough to distinguish this set</span>
        <span class="c1"># from some generic sets. While, there will be hash collisions</span>
        <span class="c1"># eventually, they should not show up with such non-random sets for a</span>
        <span class="c1"># good hash function.</span>
        <span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">some_elements</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">subset</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">tester</span><span class="o">.</span><span class="n">assertNotEqual</span><span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">hash</span><span class="p">(</span><span class="n">subset</span><span class="p">))</span>

<div class="viewcode-block" id="HyperbolicConvexSet._isometry_conditions"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexSet._isometry_conditions">[docs]</a>    <span class="k">def</span> <span class="nf">_isometry_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterable of primitive pairs that must map to each other in an</span>
<span class="sd">        isometry that maps this set to ``other``.</span>

<span class="sd">        Helper method for :meth:`HyperbolicPlane._isometry_conditions`.</span>

<span class="sd">        When determining an isometry that maps sets to each other, we reduce to</span>
<span class="sd">        an isometry that maps points or geodesics to each other. Here, we</span>
<span class="sd">        produce such more primitive objects that map to each other.</span>

<span class="sd">        Sometimes, this mapping is not unique, e.g., when mapping polygons to</span>
<span class="sd">        each other, we may rotate the vertices of the polygon. Therefore, this</span>
<span class="sd">        returns an iterator that produces the possible mappings of primitive</span>
<span class="sd">        objects.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: P = H.polygon([</span>
<span class="sd">            ....:     H.vertical(0).right_half_space(),</span>
<span class="sd">            ....:     H.half_circle(0, 4).left_half_space()],</span>
<span class="sd">            ....:     marked_vertices=[4*I])</span>

<span class="sd">            sage: conditions = P._isometry_conditions(P)</span>
<span class="sd">            sage: list(conditions)</span>
<span class="sd">            [[({x ≥ 0}, {(x^2 + y^2) - 4 ≥ 0}),</span>
<span class="sd">              ({(x^2 + y^2) - 4 ≥ 0}, {x ≥ 0}),</span>
<span class="sd">              (4*I, 4*I)],</span>
<span class="sd">             [({x ≥ 0}, {x ≥ 0}),</span>
<span class="sd">              ({(x^2 + y^2) - 4 ≥ 0}, {(x^2 + y^2) - 4 ≥ 0}),</span>
<span class="sd">              (4*I, 4*I)],</span>
<span class="sd">             [({x ≥ 0}, {x ≥ 0}),</span>
<span class="sd">              ({(x^2 + y^2) - 4 ≥ 0}, {(x^2 + y^2) - 4 ≥ 0}),</span>
<span class="sd">              (4*I, 4*I)],</span>
<span class="sd">             [({x ≥ 0}, {(x^2 + y^2) - 4 ≥ 0}),</span>
<span class="sd">              ({(x^2 + y^2) - 4 ≥ 0}, {x ≥ 0}),</span>
<span class="sd">              (4*I, 4*I)]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;this </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> does not implement _isometry_conditions yet and cannot be used to compute an isometry&quot;</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicConvexSet.random_set"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexSet.random_set">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">random_set</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a random convex set.</span>

<span class="sd">        Concrete hyperbolic classes should override this method to provide random sets.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``parent`` -- the :class:`HyperbolicPlane` the set should live in</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        Given a hyperbolic object, we can create another one of the same kind::</span>

<span class="sd">            sage: p = H(I)</span>
<span class="sd">            sage: type(p).random_set(H)  # random output</span>
<span class="sd">            7</span>

<span class="sd">        ::</span>

<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicConvexPolygon</span>
<span class="sd">            sage: P = HyperbolicConvexPolygon.random_set(H)</span>
<span class="sd">            sage: P.dimension()</span>
<span class="sd">            2</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicPlane.random_element`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="si">}</span><span class="s2"> does not support producing random sets yet&quot;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="HyperbolicOrientedConvexSet"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicOrientedConvexSet">[docs]</a><span class="k">class</span> <span class="nc">HyperbolicOrientedConvexSet</span><span class="p">(</span><span class="n">HyperbolicConvexSet</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for sets that have an explicit orientation.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">        sage: from flatsurf.geometry.hyperbolic import HyperbolicOrientedConvexSet</span>
<span class="sd">        sage: H = HyperbolicPlane()</span>

<span class="sd">        sage: isinstance(H(0), HyperbolicOrientedConvexSet)</span>
<span class="sd">        False</span>

<span class="sd">        sage: isinstance(H.vertical(0), HyperbolicOrientedConvexSet)</span>
<span class="sd">        True</span>

<span class="sd">        sage: isinstance(H.vertical(0).unoriented(), HyperbolicOrientedConvexSet)</span>
<span class="sd">        False</span>

<span class="sd">    .. SEEALSO::</span>

<span class="sd">        :meth:`HyperbolicConvexSet.is_oriented`</span>

<span class="sd">    &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="HyperbolicConvexFacade"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexFacade">[docs]</a><span class="k">class</span> <span class="nc">HyperbolicConvexFacade</span><span class="p">(</span><span class="n">HyperbolicConvexSet</span><span class="p">,</span> <span class="n">Parent</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A convex subset of the hyperbolic plane that is itself a parent.</span>

<span class="sd">    This is the base class for all hyperbolic convex sets that are not points.</span>
<span class="sd">    This class solves the problem that we want convex sets to be &quot;elements&quot; of</span>
<span class="sd">    the hyperbolic plane but at the same time, we want these sets to live as</span>
<span class="sd">    parents in the category framework of SageMath; so they have be a Parent</span>
<span class="sd">    with hyperbolic points as their Element class.</span>

<span class="sd">    SageMath provides the (not very frequently used and somewhat flaky) facade</span>
<span class="sd">    mechanism for such parents. Such sets being a facade, their points can be</span>
<span class="sd">    both their elements and the elements of the hyperbolic plane.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">        sage: H = HyperbolicPlane()</span>
<span class="sd">        sage: v = H.vertical(0)</span>
<span class="sd">        sage: p = H(0)</span>
<span class="sd">        sage: p in v</span>
<span class="sd">        True</span>
<span class="sd">        sage: p.parent() is H</span>
<span class="sd">        True</span>
<span class="sd">        sage: q = v.an_element()</span>
<span class="sd">        sage: q</span>
<span class="sd">        I</span>
<span class="sd">        sage: q.parent() is H</span>
<span class="sd">        True</span>

<span class="sd">    TESTS::</span>

<span class="sd">        sage: from flatsurf.geometry.hyperbolic import HyperbolicConvexFacade</span>
<span class="sd">        sage: isinstance(v, HyperbolicConvexFacade)</span>
<span class="sd">        True</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="HyperbolicConvexFacade.__init__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexFacade.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">Parent</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">facade</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">category</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicConvexFacade.parent"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexFacade.parent">[docs]</a>    <span class="k">def</span> <span class="nf">parent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the hyperbolic plane this is a subset of.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: v = H.vertical(0)</span>
<span class="sd">            sage: v.parent()</span>
<span class="sd">            Hyperbolic Plane over Rational Field</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">facade_for</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_element_constructor_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return ``x`` as a point of this set.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: v = H.vertical(0)</span>
<span class="sd">            sage: v(0)</span>
<span class="sd">            0</span>
<span class="sd">            sage: v(I)</span>
<span class="sd">            I</span>
<span class="sd">            sage: v(oo)</span>
<span class="sd">            ∞</span>
<span class="sd">            sage: v(2)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: point not contained in this set</span>

<span class="sd">            sage: 2 in v</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">HyperbolicPoint</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;point not contained in this set&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x</span>

<div class="viewcode-block" id="HyperbolicConvexFacade.base_ring"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexFacade.base_ring">[docs]</a>    <span class="k">def</span> <span class="nf">base_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the ring over which points of this set are defined.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: v = H.vertical(0)</span>
<span class="sd">            sage: v.base_ring()</span>
<span class="sd">            Rational Field</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="HyperbolicHalfSpace"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicHalfSpace">[docs]</a><span class="k">class</span> <span class="nc">HyperbolicHalfSpace</span><span class="p">(</span><span class="n">HyperbolicConvexFacade</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A closed half space of the hyperbolic plane.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``parent`` -- the :class:`HyperbolicPlane` containing this half space.</span>

<span class="sd">    - ``geodesic`` -- the :class:`HyperbolicOrientedGeodesic` to whose left</span>
<span class="sd">      this half space lies.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">        sage: H = HyperbolicPlane()</span>

<span class="sd">        sage: H.half_circle(0, 1).left_half_space()</span>
<span class="sd">        {(x^2 + y^2) - 1 ≥ 0}</span>

<span class="sd">    .. SEEALSO::</span>

<span class="sd">        :meth:`HyperbolicPlane.half_space`,</span>
<span class="sd">        :meth:`HyperbolicOrientedGeodesic.left_half_space`,</span>
<span class="sd">        :meth:`HyperbolicOrientedGeodesic.right_half_space` for the most common</span>
<span class="sd">        ways to create half spaces.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="HyperbolicHalfSpace.__init__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicHalfSpace.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">geodesic</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicHalfSpace</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: h = H.half_circle(0, 1).left_half_space()</span>
<span class="sd">            sage: isinstance(h, HyperbolicHalfSpace)</span>
<span class="sd">            True</span>

<span class="sd">            sage: TestSuite(h).run()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geodesic</span><span class="p">,</span> <span class="n">HyperbolicOrientedGeodesic</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;geodesic must be an oriented geodesic&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">geodesic</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="ow">is</span> <span class="n">parent</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;geodesic must be in parent&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span> <span class="o">=</span> <span class="n">geodesic</span></div>

<div class="viewcode-block" id="HyperbolicHalfSpace.equation"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicHalfSpace.equation">[docs]</a>    <span class="k">def</span> <span class="nf">equation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">normalization</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an inequality for this half space as a triple ``a``, ``b``, ``c`` such that:</span>

<span class="sd">        - if ``model`` is ``&quot;half_plane&quot;``, a point `x + iy` of the upper half</span>
<span class="sd">          plane is in the half space if it satisfies `a(x^2 + y^2) + bx + c \ge 0`.</span>

<span class="sd">        - if ``model`` is ``&quot;klein&quot;``, points `(x, y)` in the unit disk satisfy</span>
<span class="sd">          `a + bx + cy \ge 0`.</span>

<span class="sd">        Note that the output is not unique since the coefficients can be scaled</span>
<span class="sd">        by a positive scalar.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``model`` -- either ``&quot;half_plane&quot;`` or ``&quot;klein&quot;``</span>

<span class="sd">        - ``normalization`` -- how to normalize the coefficients, see</span>
<span class="sd">          :meth:`HyperbolicGeodesic.equation` for details</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicHalfSpace</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: h = H.half_circle(0, 1).left_half_space()</span>

<span class="sd">            sage: h.equation(model=&quot;half_plane&quot;)</span>
<span class="sd">            (2, 0, -2)</span>

<span class="sd">            sage: H.half_space(2, 0, -2, model=&quot;half_plane&quot;) == h</span>
<span class="sd">            True</span>

<span class="sd">            sage: h.equation(model=&quot;klein&quot;)</span>
<span class="sd">            (0, 0, 2)</span>

<span class="sd">            sage: H.half_space(0, 0, 2, model=&quot;klein&quot;) == h</span>
<span class="sd">            True</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicPlane.half_space` to build a half space from the</span>
<span class="sd">            coefficients returned by this method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span><span class="o">.</span><span class="n">equation</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">normalization</span><span class="o">=</span><span class="n">normalization</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a printable representation of this half space.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: S = H.half_circle(0, 1).right_half_space()</span>

<span class="sd">            sage: S</span>
<span class="sd">            {(x^2 + y^2) - 1 ≤ 0}</span>

<span class="sd">            sage: -S</span>
<span class="sd">            {(x^2 + y^2) - 1 ≥ 0}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geodesic</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">())</span>

        <span class="n">cmp</span> <span class="o">=</span> <span class="s2">&quot;≥&quot;</span>

        <span class="k">if</span> <span class="n">geodesic</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;{-&quot;</span><span class="p">):</span>
            <span class="n">cmp</span> <span class="o">=</span> <span class="s2">&quot;≤&quot;</span>
            <span class="n">geodesic</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">geodesic</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">,</span> <span class="n">cmp</span><span class="p">)</span>

<div class="viewcode-block" id="HyperbolicHalfSpace.half_spaces"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicHalfSpace.half_spaces">[docs]</a>    <span class="k">def</span> <span class="nf">half_spaces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the half spaces defining this half space, i.e., this half space</span>
<span class="sd">        itself.</span>

<span class="sd">        Implements :meth:`HyperbolicConvexSet.half_spaces`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: S = H.vertical(0).left_half_space()</span>
<span class="sd">            sage: [S] == list(S.half_spaces())</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">HyperbolicHalfSpaces</span><span class="p">([</span><span class="bp">self</span><span class="p">],</span> <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicHalfSpace.__neg__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicHalfSpace.__neg__">[docs]</a>    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the closure of the complement of this half space.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: S = H.half_circle(0, 1).left_half_space()</span>
<span class="sd">            sage: S</span>
<span class="sd">            {(x^2 + y^2) - 1 ≥ 0}</span>

<span class="sd">            sage: -S</span>
<span class="sd">            {(x^2 + y^2) - 1 ≤ 0}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span><span class="o">.</span><span class="n">right_half_space</span><span class="p">()</span></div>

<div class="viewcode-block" id="HyperbolicHalfSpace.boundary"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicHalfSpace.boundary">[docs]</a>    <span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a geodesic on the boundary of this half space, oriented such</span>
<span class="sd">        that the half space is on its left.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: S = H.vertical(0).left_half_space()</span>
<span class="sd">            sage: S.boundary()</span>
<span class="sd">            {-x = 0}</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicOrientedGeodesic.left_half_space` to recover the</span>
<span class="sd">            half space from the oriented geodesic</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span></div>

<div class="viewcode-block" id="HyperbolicHalfSpace.__contains__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicHalfSpace.__contains__">[docs]</a>    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether ``point`` is contained in this half space.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``point`` -- a :class:`HyperbolicPoint`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: h = H.vertical(0).left_half_space()</span>
<span class="sd">            sage: I in h</span>
<span class="sd">            True</span>

<span class="sd">            sage: I - 1 in h</span>
<span class="sd">            True</span>

<span class="sd">            sage: I + 1 in h</span>
<span class="sd">            False</span>

<span class="sd">            sage: oo in h</span>
<span class="sd">            True</span>

<span class="sd">        Currently, this is not implemented for points whose coordinates cannot</span>
<span class="sd">        be represented over the base ring::</span>

<span class="sd">            sage: H.half_circle(0, 2).start() in h</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            NotImplementedError: cannot decide whether this ideal point is contained in the half space yet</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            The implementation is currently not very robust over inexact rings.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicConvexSet.is_subset` to check containment of</span>
<span class="sd">            arbitrary sets.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">point</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">HyperbolicPoint</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;point must be a point in the hyperbolic plane&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">point</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># The point does not have coordinates in the base ring in the Klein model.</span>
            <span class="c1"># It is the starting point of a geodesic.</span>
            <span class="k">assert</span> <span class="n">point</span><span class="o">.</span><span class="n">is_ideal</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">point</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">():</span>
                <span class="k">return</span> <span class="kc">True</span>

            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;cannot decide whether this ideal point is contained in the half space yet&quot;</span>
            <span class="p">)</span>

        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">equation</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>

        <span class="c1"># We should use a specialized predicate here to do something more</span>
        <span class="c1"># reasonable for points that are close to the boundary over inexact</span>
        <span class="c1"># rings.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_sgn</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="HyperbolicHalfSpace.__eq__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicHalfSpace.__eq__">[docs]</a>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this set is indistinguishable from ``other``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: h = H.vertical(0).left_half_space()</span>

<span class="sd">            sage: h == H.vertical(0).left_half_space()</span>
<span class="sd">            True</span>
<span class="sd">            sage: h == H.vertical(0).right_half_space()</span>
<span class="sd">            False</span>

<span class="sd">        ::</span>

<span class="sd">            sage: h != H.vertical(0).left_half_space()</span>
<span class="sd">            False</span>
<span class="sd">            sage: h != H.vertical(0).right_half_space()</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">HyperbolicHalfSpace</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_geodesic</span></div>

<div class="viewcode-block" id="HyperbolicHalfSpace.plot"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicHalfSpace.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a plot of this half space in the hyperbolic ``model``.</span>

<span class="sd">        See :meth:`HyperbolicConvexPolygon.plot` for the supported keyword</span>
<span class="sd">        arguments.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``model`` -- one of ``&quot;half_plane&quot;`` and ``&quot;klein&quot;`` (default: ``&quot;half_plane&quot;``)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: G = H.vertical(0).left_half_space().plot()</span>

<span class="sd">        In the half plane model, the half space is rendered as an infinite polygon::</span>

<span class="sd">            sage: G = H.vertical(0).left_half_space().plot()</span>
<span class="sd">            sage: G[0]</span>
<span class="sd">            CartesianPathPlot([CartesianPathPlotCommand(code=&#39;MOVETO&#39;, args=(0.000000000000000, 0.000000000000000)),</span>
<span class="sd">                CartesianPathPlotCommand(code=&#39;RAYTO&#39;, args=(0, 1)),</span>
<span class="sd">                CartesianPathPlotCommand(code=&#39;RAYTO&#39;, args=(-1, 0)),</span>
<span class="sd">                CartesianPathPlotCommand(code=&#39;LINETO&#39;, args=(0.000000000000000, 0.000000000000000))])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
            <span class="o">.</span><span class="n">polygon</span><span class="p">([</span><span class="bp">self</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">assume_minimal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicHalfSpace.change"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicHalfSpace.change">[docs]</a>    <span class="k">def</span> <span class="nf">change</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">oriented</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a modified copy of this half space.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``ring`` -- a ring (default: ``None`` to keep the current</span>
<span class="sd">          :meth:`~HyperbolicPlane.base_ring`); the ring over which the new half</span>
<span class="sd">          space will be defined.</span>

<span class="sd">        - ``geometry`` -- a :class:`HyperbolicGeometry` (default: ``None`` to</span>
<span class="sd">          keep the current geometry); the geometry that will be used for the</span>
<span class="sd">          new half space.</span>

<span class="sd">        - ``oriented`` -- a boolean (default: ``None`` to keep the current</span>
<span class="sd">          orientedness); must be ``None`` or ``False`` since half spaces cannot</span>
<span class="sd">          have an explicit orientation. See :meth:`~HyperbolicConvexSet.is_oriented`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: h = H.vertical(0).left_half_space()</span>

<span class="sd">        We change the base ring over which this space is defined::</span>

<span class="sd">            sage: h.change(ring=AA)</span>
<span class="sd">            {x ≤ 0}</span>

<span class="sd">        We cannot change the orientedness of a half space:</span>

<span class="sd">            sage: h.change(oriented=True)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            NotImplementedError: half spaces cannot have an explicit orientation</span>

<span class="sd">            sage: h.change(oriented=False)</span>
<span class="sd">            {x ≤ 0}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ring</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">geometry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="n">ring</span><span class="o">=</span><span class="n">ring</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">geometry</span><span class="p">)</span><span class="o">.</span><span class="n">left_half_space</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">oriented</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">oriented</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">oriented</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;half spaces cannot have an explicit orientation&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="HyperbolicHalfSpace.dimension"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicHalfSpace.dimension">[docs]</a>    <span class="k">def</span> <span class="nf">dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the dimension of this half space, i.e., 2.</span>

<span class="sd">        This implements :meth:`HyperbolicConvexSet.dimension`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.vertical(0).left_half_space().dimension()</span>
<span class="sd">            2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">ZZ</span>

        <span class="k">return</span> <span class="n">ZZ</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicHalfSpace.vertices"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicHalfSpace.vertices">[docs]</a>    <span class="k">def</span> <span class="nf">vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">marked_vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the vertices bounding this half space.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``marked_vertices`` -- a boolean (default: ``True``), ignored since a</span>
<span class="sd">          half space cannot have marked vertices.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        The vertices of a half space are the ideal end points of its boundary geodesic::</span>

<span class="sd">            sage: H.vertical(0).left_half_space().vertices()</span>
<span class="sd">            {0, ∞}</span>

<span class="sd">        Note that iteration in the set is not consistent with the orientation</span>
<span class="sd">        of the half space (it is chosen such that the subset relation on vertices</span>
<span class="sd">        can be checked quickly)::</span>

<span class="sd">            sage: h = H.vertical(0).left_half_space()</span>
<span class="sd">            sage: list(h.vertices())</span>
<span class="sd">            [0, ∞]</span>

<span class="sd">            sage: list((-h).vertices())</span>
<span class="sd">            [0, ∞]</span>

<span class="sd">        Use :meth:`HyperbolicOrientedGeodesic.start` and</span>
<span class="sd">        :meth:`HyperbolicOrientedGeodesic.end` on the :meth:`boundary` to get</span>
<span class="sd">        the end points in an order consistent with the orientation::</span>

<span class="sd">            sage: g = h.boundary()</span>
<span class="sd">            sage: g.start(), g.end()</span>
<span class="sd">            (0, ∞)</span>

<span class="sd">            sage: g = (-h).boundary()</span>
<span class="sd">            sage: g.start(), g.end()</span>
<span class="sd">            (∞, 0)</span>

<span class="sd">        Vertices can be computed even though they do not have coordinates over</span>
<span class="sd">        the :meth:`HyperbolicPlane.base_ring`::</span>

<span class="sd">            sage: H.half_circle(0, 2).left_half_space().vertices()</span>
<span class="sd">            {-1.41421356237310, 1.41421356237310}</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicConvexSet.vertices` for more details.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">()</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_apply_isometry_klein</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">isometry</span><span class="p">,</span> <span class="n">on_right</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the image of this half space under ``isometry``.</span>

<span class="sd">        Helper method for :meth:`HyperbolicConvexSet.apply_isometry`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``isometry`` -- a 3×3 matrix over the</span>
<span class="sd">          :meth:`~HyperbolicPlane.base_ring` describing an isometry in the</span>
<span class="sd">          hyperboloid model.</span>

<span class="sd">        - ``on_right`` -- a boolean (default: ``False``) whether to return the</span>
<span class="sd">          result of the right action.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: isometry = matrix([[1, -1, 1], [1, 1/2, 1/2], [1, -1/2, 3/2]])</span>
<span class="sd">            sage: H.vertical(0).left_half_space()._apply_isometry_klein(isometry)</span>
<span class="sd">            {x - 1 ≤ 0}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span><span class="o">.</span><span class="n">apply_isometry</span><span class="p">(</span>
            <span class="n">isometry</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span> <span class="n">on_right</span><span class="o">=</span><span class="n">on_right</span>
        <span class="p">)</span><span class="o">.</span><span class="n">left_half_space</span><span class="p">()</span>

<div class="viewcode-block" id="HyperbolicHalfSpace.__hash__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicHalfSpace.__hash__">[docs]</a>    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a hash value for this half space</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        Since half spaces are hashable, they can be put in a hash table, such</span>
<span class="sd">        as a Python ``set``::</span>

<span class="sd">            sage: S = {H.vertical(0).left_half_space(), H.vertical(0).right_half_space()}</span>
<span class="sd">            sage: len(S)</span>
<span class="sd">            2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Add the type to the hash value to distinguish the hash value from an</span>
        <span class="c1"># actual geodesic.</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span><span class="p">))</span></div>

<div class="viewcode-block" id="HyperbolicHalfSpace._isometry_conditions"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicHalfSpace._isometry_conditions">[docs]</a>    <span class="k">def</span> <span class="nf">_isometry_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterable of primitive pairs that must map to each other in an</span>
<span class="sd">        isometry that maps this set to ``other``.</span>

<span class="sd">        Helper method for :meth:`HyperbolicPlane._isometry_conditions`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: v = H.vertical(0).left_half_space()</span>
<span class="sd">            sage: w = H.vertical(1).right_half_space()</span>

<span class="sd">            sage: conditions = v._isometry_conditions(w)</span>
<span class="sd">            sage: list(conditions)</span>
<span class="sd">            [[({-x = 0}, {x - 1 = 0})]]</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicConvexSet._isometry_conditions` for a general description.</span>

<span class="sd">        r&quot;&quot;&quot;</span>
        <span class="k">yield</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">(),</span> <span class="n">other</span><span class="o">.</span><span class="n">boundary</span><span class="p">())]</span></div>

<div class="viewcode-block" id="HyperbolicHalfSpace.random_set"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicHalfSpace.random_set">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">random_set</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a random half space.</span>

<span class="sd">        This implements :meth:`HyperbolicConvexSet.random_set`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``parent`` -- the :class:`HyperbolicPlane` containing the half plane</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicHalfSpace</span>
<span class="sd">            sage: x = HyperbolicHalfSpace.random_set(H)</span>

<span class="sd">            sage: x.dimension()</span>
<span class="sd">            2</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicPlane.random_element`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">HyperbolicOrientedGeodesic</span><span class="o">.</span><span class="n">random_set</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span><span class="o">.</span><span class="n">left_half_space</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="HyperbolicGeodesic"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeodesic">[docs]</a><span class="k">class</span> <span class="nc">HyperbolicGeodesic</span><span class="p">(</span><span class="n">HyperbolicConvexFacade</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A geodesic in the hyperbolic plane.</span>

<span class="sd">    This is the abstract base class of :class:`HyperbolicUnorientedGeodesic`</span>
<span class="sd">    and :class:`HyperbolicOrientedGeodesic`.</span>

<span class="sd">    ALGORITHM:</span>

<span class="sd">    Internally, we represent geodesics as a triple `a, b, c` such that they satisfy the equation</span>

<span class="sd">    .. MATH::</span>

<span class="sd">        a + bx + cy = 0</span>

<span class="sd">    in the Klein disk model.</span>

<span class="sd">    Note that due to this representation we can always compute intersection</span>
<span class="sd">    points of geodesics but we cannot always get the coordinates of the ideal</span>
<span class="sd">    end points of a geodesic (since we would have to take a square root to</span>
<span class="sd">    solve for the points on the unit circle.)</span>

<span class="sd">    It might be beneficial to store geodesics differently, see</span>
<span class="sd">    https://sagemath.zulipchat.com/#narrow/stream/271193-polygon/topic/hyperbolic.20geometry/near/284722650</span>
<span class="sd">    for a discussion.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``parent`` -- the :class:`HyperbolicPlane` this geodesic lives in</span>

<span class="sd">    - ``a`` -- an element of :meth:`HyperbolicPlane.base_ring`</span>

<span class="sd">    - ``b`` -- an element of :meth:`HyperbolicPlane.base_ring`</span>

<span class="sd">    - ``c`` -- an element of :meth:`HyperbolicPlane.base_ring`</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">        sage: H = HyperbolicPlane()</span>

<span class="sd">        sage: H.geodesic(1, 2, 3, model=&quot;klein&quot;)</span>
<span class="sd">        {2*(x^2 + y^2) + 2*x - 1 = 0}</span>

<span class="sd">    .. SEEALSO::</span>

<span class="sd">        :meth:`HyperbolicPlane.geodesic` for various ways of constructing geodesics</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="HyperbolicGeodesic.__init__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeodesic.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicGeodesic</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: geodesic = H.vertical(0)</span>

<span class="sd">            sage: isinstance(geodesic, HyperbolicGeodesic)</span>
<span class="sd">            True</span>

<span class="sd">            sage: TestSuite(geodesic).run()</span>

<span class="sd">            sage: isinstance(geodesic.unoriented(), HyperbolicGeodesic)</span>
<span class="sd">            True</span>

<span class="sd">            sage: TestSuite(geodesic.unoriented()).run()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Element</span><span class="p">)</span> <span class="ow">or</span> <span class="n">a</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">parent</span><span class="o">.</span><span class="n">base_ring</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;a must be an element of the base ring&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Element</span><span class="p">)</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">parent</span><span class="o">.</span><span class="n">base_ring</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;b must be an element of the base ring&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Element</span><span class="p">)</span> <span class="ow">or</span> <span class="n">c</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">parent</span><span class="o">.</span><span class="n">base_ring</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;c must be an element of the base ring&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">=</span> <span class="n">a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">=</span> <span class="n">b</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_c</span> <span class="o">=</span> <span class="n">c</span></div>

    <span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">require_normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate the equation defining this geodesic.</span>

<span class="sd">        Implements :meth:`HyperbolicConvexSet._check`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``require_normalized`` -- a boolean (default: ``True``); ignored</span>

<span class="sd">        EXAMPLES::</span>


<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicGeodesic</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: geodesic = H.vertical(0)</span>
<span class="sd">            sage: geodesic._check()</span>

<span class="sd">            sage: geodesic = H.geodesic(2, 0, 1, model=&quot;klein&quot;, check=False)</span>
<span class="sd">            sage: geodesic._check()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: equation 2 + (0)*x + (1)*y = 0 does not define a chord in the Klein model</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`is_ultra_ideal` to check whether a chord is completely outside the Klein disk</span>

<span class="sd">            :meth:`is_ideal` to check whether a chord touches the Klein disk</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ultra_ideal</span><span class="p">()</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ideal</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;equation </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="si">}</span><span class="s2"> + (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="si">}</span><span class="s2">)*x + (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="si">}</span><span class="s2">)*y = 0 does not define a chord in the Klein model&quot;</span>
            <span class="p">)</span>

<div class="viewcode-block" id="HyperbolicGeodesic.is_ideal"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeodesic.is_ideal">[docs]</a>    <span class="k">def</span> <span class="nf">is_ideal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether all hyperbolic points of this geodesic are ideal, i.e.,</span>
<span class="sd">        the defining equation of this geodesic in the Klein model only touches</span>
<span class="sd">        the Klein disk but does not intersect it.</span>

<span class="sd">        Note that it is normally not possible to create ideal geodesics. They</span>
<span class="sd">        only exist internally during constructions in the Euclidean plane.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.vertical(0).is_ideal()</span>
<span class="sd">            False</span>

<span class="sd">            sage: geodesic = H.geodesic(1, 0, 1, model=&quot;klein&quot;, check=False)</span>
<span class="sd">            sage: geodesic.is_ideal()</span>
<span class="sd">            True</span>

<span class="sd">            sage: geodesic = H.geodesic(2, 0, 1, model=&quot;klein&quot;, check=False)</span>
<span class="sd">            sage: geodesic.is_ideal()</span>
<span class="sd">            False</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            The implementation of this predicate is not numerically robust over inexact rings.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`is_ultra_ideal` to detect whether a geodesic does not even</span>
<span class="sd">            touch the Klein disk</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We should probably use a specialized predicate of the geometry to</span>
        <span class="c1"># make this more robust over inexact rings.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_equal</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicGeodesic.is_ultra_ideal"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeodesic.is_ultra_ideal">[docs]</a>    <span class="k">def</span> <span class="nf">is_ultra_ideal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether the line given by the defining equation is completely</span>
<span class="sd">        outside the Klein disk, i.e., all &quot;points&quot; of this geodesic are ultra-ideal.</span>

<span class="sd">        Note that it is normally not possible to create ultra-ideal geodesics.</span>
<span class="sd">        They only exist internally during constructions in the Euclidean plane.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.vertical(0).is_ultra_ideal()</span>
<span class="sd">            False</span>

<span class="sd">            sage: geodesic = H.geodesic(1, 0, 1, model=&quot;klein&quot;, check=False)</span>
<span class="sd">            sage: geodesic.is_ultra_ideal()</span>
<span class="sd">            False</span>

<span class="sd">            sage: geodesic = H.geodesic(2, 0, 1, model=&quot;klein&quot;, check=False)</span>
<span class="sd">            sage: geodesic.is_ultra_ideal()</span>
<span class="sd">            True</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            The implementation of this predicate is not numerically robust over inexact rings.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`is_ideal` to detect whether a geodesic touches the Klein disk</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We should probably use a specialized predicate of the geometry to</span>
        <span class="c1"># make this more robust over inexact rings.</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_cmp</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span>
            <span class="p">)</span>
            <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a printable representation of this geodesic.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``model`` -- ``&quot;half_plane&quot;`` or ``&quot;klein&quot;`` (default: ``None`` to</span>
<span class="sd">          use ``&quot;half_plane&quot;`` if possible); in which model of hyperbolic</span>
<span class="sd">          geometry the equation is realized</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        If the geodesic is oriented, we print a defining equation of the</span>
<span class="sd">        geodesic such that when replacing the ``=`` with a ``≥``, we get an</span>
<span class="sd">        equation for the half space to the left of the geodesic::</span>

<span class="sd">            sage: H.vertical(1)</span>
<span class="sd">            {-x + 1 = 0}</span>
<span class="sd">            sage: H.vertical(1).left_half_space()</span>
<span class="sd">            {x - 1 ≤ 0}</span>

<span class="sd">        Normally, geodesics are shown with their equation in the upper half</span>
<span class="sd">        plane model. We can also ask for an equation of the chord in the Klein</span>
<span class="sd">        disk::</span>

<span class="sd">            sage: H.vertical(1)._repr_(model=&quot;klein&quot;)</span>
<span class="sd">            &#39;{1 + -x - y = 0}&#39;</span>

<span class="sd">        This representation is also chosen automatically for objects that do</span>
<span class="sd">        not have a representation in upper half plane such as ultra-ideal</span>
<span class="sd">        geodesics::</span>

<span class="sd">            sage: H.geodesic(2, 0, 1, model=&quot;klein&quot;, check=False)</span>
<span class="sd">            {2 + y = 0}</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`equation` to access the coefficients of the equation</span>
<span class="sd">            defining the geodesic</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;klein&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ultra_ideal</span><span class="p">()</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ideal</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;half_plane&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s2">&quot;half_plane&quot;</span><span class="p">:</span>
            <span class="c1"># Convert to the upper half plane model as a(x^2 + y^2) + bx + c = 0.</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">equation</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">,</span> <span class="n">normalization</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;gcd&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>

            <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">PolynomialRing</span>

            <span class="n">R</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">base_ring</span><span class="p">(),</span> <span class="n">names</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_sgn</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">{{</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">R</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">]))[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">(x^2 + y^2)</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">R</span><span class="p">([</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]))[</span><span class="mi">3</span><span class="p">:]</span><span class="si">}</span><span class="s2"> = 0</span><span class="se">}}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">{{</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">R</span><span class="p">([</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">]))</span><span class="si">}</span><span class="s2"> = 0</span><span class="se">}}</span><span class="s2">&quot;</span>

        <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s2">&quot;klein&quot;</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">equation</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span> <span class="n">normalization</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;gcd&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>

            <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">PolynomialRing</span>

            <span class="n">R</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">base_ring</span><span class="p">(),</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">])</span>
            <span class="n">polynomial_part</span> <span class="o">=</span> <span class="n">R</span><span class="p">({(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="n">c</span><span class="p">})</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_sgn</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">{{</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="si">}</span><span class="s2"> + </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">polynomial_part</span><span class="p">)</span><span class="si">}</span><span class="s2"> = 0</span><span class="se">}}</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">{{</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">polynomial_part</span><span class="p">)</span><span class="si">}</span><span class="s2"> = 0</span><span class="se">}}</span><span class="s2">&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;printing not supported in this model&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="HyperbolicGeodesic.equation"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeodesic.equation">[docs]</a>    <span class="k">def</span> <span class="nf">equation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">normalization</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an equation for this geodesic as a triple ``a``, ``b``, ``c`` such that:</span>

<span class="sd">        - if ``model`` is ``&quot;half_plane&quot;``, a point `x + iy` of the upper half</span>
<span class="sd">          plane is on the geodesic if it satisfies `a(x^2 + y^2) + bx + c = 0`.</span>

<span class="sd">        - if ``model`` is ``&quot;klein&quot;``, points `(x, y)` in the unit disk satisfy</span>
<span class="sd">          are on the geodesic if `a + bx + cy = 0`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``model`` -- the model in which this equation holds, either</span>
<span class="sd">          ``&quot;half_plane&quot;`` or ``&quot;klein&quot;``</span>

<span class="sd">        - ``normalization`` -- how to normalize the coefficients; the default</span>
<span class="sd">          ``None`` is not to normalize at all. Other options are ``gcd``, to</span>
<span class="sd">          divide the coefficients by their greatest common divisor, ``one``, to</span>
<span class="sd">          normalize the first non-zero coefficient to ±1. This can also be a</span>
<span class="sd">          list of such values which are then tried in order and exceptions are</span>
<span class="sd">          silently ignored unless they happen at the last option.</span>

<span class="sd">        If this geodesic :meth;`is_oriented`, then the sign of the coefficients</span>
<span class="sd">        is chosen to encode the orientation of this geodesic. The sign is such</span>
<span class="sd">        that the half plane obtained by replacing ``=`` with ``≥`` in above</span>
<span class="sd">        equationsis on the left of the geodesic.</span>

<span class="sd">        Note that the output might not uniquely describe the geodesic since the</span>
<span class="sd">        coefficients are only unique up to scaling.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: v = H.vertical(0)</span>
<span class="sd">            sage: v.equation(model=&quot;half_plane&quot;)</span>
<span class="sd">            (0, -2, 0)</span>

<span class="sd">            sage: v.equation(model=&quot;half_plane&quot;, normalization=&quot;gcd&quot;)</span>
<span class="sd">            (0, -1, 0)</span>

<span class="sd">            sage: v.equation(model=&quot;klein&quot;)</span>
<span class="sd">            (0, -1, 0)</span>

<span class="sd">        Sometimes, the desired normalization might not be possible (a more</span>
<span class="sd">        realistic example would be exact-real coefficients)::</span>

<span class="sd">            sage: H = HyperbolicPlane(ZZ)</span>
<span class="sd">            sage: g = H.geodesic(2, 3, -4, model=&quot;half_plane&quot;)</span>

<span class="sd">            sage: g.equation(model=&quot;half_plane&quot;, normalization=&quot;one&quot;)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            TypeError: ...</span>

<span class="sd">        In this case, we can ask for the best of several normalization::</span>

<span class="sd">            sage: g.equation(model=&quot;half_plane&quot;, normalization=[&quot;one&quot;, &quot;gcd&quot;, None])</span>
<span class="sd">            (2, 3, -4)</span>

<span class="sd">        For ultra-ideal geodesics, the equation in the half plane model is not</span>
<span class="sd">        very useful::</span>

<span class="sd">            sage: g = H.geodesic(2, 0, 1, model=&quot;klein&quot;, check=False)</span>
<span class="sd">            sage: g.equation(model=&quot;half_plane&quot;)  # i.e., 3*(x^2 + y^2) + 1 = 0</span>
<span class="sd">            (3, 0, 1)</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicPlane.geodesic` to create a geodesic from an</span>
<span class="sd">            equation</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">normalization</span> <span class="o">=</span> <span class="n">normalization</span> <span class="ow">or</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">normalization</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">normalization</span> <span class="o">=</span> <span class="p">[</span><span class="n">normalization</span><span class="p">]</span>

        <span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sequence</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">normalization</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="n">normalization</span> <span class="o">=</span> <span class="p">[</span><span class="n">normalization</span><span class="p">]</span>

        <span class="n">normalization</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">normalization</span><span class="p">)</span>
        <span class="n">normalization</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span>

        <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s2">&quot;klein&quot;</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span>
        <span class="k">elif</span> <span class="n">model</span> <span class="o">==</span> <span class="s2">&quot;half_plane&quot;</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">-</span> <span class="n">c</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot determine equation for this model yet&quot;</span><span class="p">)</span>

        <span class="n">sgn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_sgn</span>
        <span class="n">sgn</span> <span class="o">=</span> <span class="p">(</span>
            <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">sgn</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">sgn</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">sgn</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">sgn</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">sgn</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">else</span> <span class="mi">1</span>
        <span class="p">)</span>

        <span class="k">while</span> <span class="n">normalization</span><span class="p">:</span>
            <span class="n">strategy</span> <span class="o">=</span> <span class="n">normalization</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">HyperbolicGeodesic</span><span class="o">.</span><span class="n">_normalize_coefficients</span><span class="p">(</span>
                    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="n">strategy</span>
                <span class="p">)</span>
                <span class="k">break</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">normalization</span><span class="p">:</span>
                    <span class="k">raise</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">():</span>
            <span class="n">a</span> <span class="o">*=</span> <span class="n">sgn</span>
            <span class="n">b</span> <span class="o">*=</span> <span class="n">sgn</span>
            <span class="n">c</span> <span class="o">*=</span> <span class="n">sgn</span>

        <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_normalize_coefficients</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">strategy</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the normalized coefficients for the equation of a geodesic.</span>

<span class="sd">        Helper method for :meth:`equation`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``a``, ``b``, ``c`` -- the coefficients of the geodesic equation</span>

<span class="sd">        - ``strategy`` -- one of ``&quot;gcd&quot;`` or ``&quot;one&quot;``</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicGeodesic</span>

<span class="sd">        Normalize the leading coefficient to be ±1::</span>

<span class="sd">            sage: HyperbolicGeodesic._normalize_coefficients(QQ(6), -QQ(10), -QQ(12), strategy=&quot;one&quot;)</span>
<span class="sd">            (1, -5/3, -2)</span>
<span class="sd">            sage: HyperbolicGeodesic._normalize_coefficients(-QQ(6), QQ(10), QQ(12), strategy=&quot;one&quot;)</span>
<span class="sd">            (-1, 5/3, 2)</span>

<span class="sd">        Divide the coefficients by their GCD::</span>

<span class="sd">            sage: HyperbolicGeodesic._normalize_coefficients(QQ(6), -QQ(10), -QQ(12), strategy=&quot;gcd&quot;)</span>
<span class="sd">            (3, -5, -6)</span>
<span class="sd">            sage: HyperbolicGeodesic._normalize_coefficients(-QQ(6), QQ(10), QQ(12), strategy=&quot;gcd&quot;)</span>
<span class="sd">            (-3, 5, 6)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">strategy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span>

        <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;gcd&quot;</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">gcd</span><span class="p">(</span><span class="o">*</span><span class="n">coefficients</span><span class="p">):</span>
                <span class="n">coefficients</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coefficients</span> <span class="k">if</span> <span class="n">c</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coefficients</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">coefficients</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">gcd</span>

                <span class="k">return</span> <span class="n">gcd</span><span class="p">(</span><span class="n">coefficients</span><span class="p">)</span>

            <span class="n">d</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">return</span> <span class="n">R</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">d</span><span class="p">),</span> <span class="n">R</span><span class="p">(</span><span class="n">b</span> <span class="o">/</span> <span class="n">d</span><span class="p">),</span> <span class="n">R</span><span class="p">(</span><span class="n">c</span> <span class="o">/</span> <span class="n">d</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;one&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">a</span>
            <span class="k">elif</span> <span class="n">b</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">b</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">c</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">c</span>

            <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="k">return</span> <span class="n">R</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">d</span><span class="p">),</span> <span class="n">R</span><span class="p">(</span><span class="n">b</span> <span class="o">/</span> <span class="n">d</span><span class="p">),</span> <span class="n">R</span><span class="p">(</span><span class="n">c</span> <span class="o">/</span> <span class="n">d</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unknown normalization </span><span class="si">{</span><span class="n">strategy</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="HyperbolicGeodesic.half_spaces"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeodesic.half_spaces">[docs]</a>    <span class="k">def</span> <span class="nf">half_spaces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the two half spaces whose intersection this geodesic is.</span>

<span class="sd">        Implements :meth:`HyperbolicConvexSet.half_spaces`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.vertical(0).half_spaces()</span>
<span class="sd">            {{x ≤ 0}, {x ≥ 0}}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="n">oriented</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">HyperbolicHalfSpaces</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">left_half_space</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">right_half_space</span><span class="p">()])</span></div>

<div class="viewcode-block" id="HyperbolicGeodesic.plot"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeodesic.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a plot of this geodesic in the hyperbolic ``model``.</span>

<span class="sd">        See :meth:`HyperbolicSegment.plot` for the supported keyword arguments.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``model`` -- one of ``&quot;half_plane&quot;`` and ``&quot;klein&quot;`` (default: ``&quot;half_plane&quot;``)</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        .. jupyter-execute::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.vertical(0).plot()</span>
<span class="sd">            ...Graphics object consisting of 1 graphics primitive</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
            <span class="o">.</span><span class="n">segment</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="n">oriented</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">assume_normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicGeodesic.pole"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeodesic.pole">[docs]</a>    <span class="k">def</span> <span class="nf">pole</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the pole of this geodesic.</span>

<span class="sd">        ALGORITHM:</span>

<span class="sd">        The pole is the intersection of tangents of the Klein disk at</span>
<span class="sd">        the ideal endpoints of this geodesic, see `Wikipedia</span>
<span class="sd">        &lt;https://en.wikipedia.org/wiki/Beltrami%E2%80%93Klein_model#Compass_and_straightedge_constructions&gt;`.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The pole of a geodesic is an ultra ideal point::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: p = H.vertical(2).pole(); p</span>
<span class="sd">            (1/2, 1)</span>
<span class="sd">            sage: p.is_ultra_ideal()</span>
<span class="sd">            True</span>

<span class="sd">        Computing the pole is only implemented if it is a finite point in the</span>
<span class="sd">        Euclidean plane::</span>

<span class="sd">            sage: H.half_circle(0, 1).pole()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            NotImplementedError: can only compute pole if geodesic is a not a diameter in the Klein model</span>

<span class="sd">        The pole might not be defined without passing to a larger base ring::</span>

<span class="sd">            sage: H.half_circle(2, 2).pole()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: square root of 32 not in Rational Field</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_diameter</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;can only compute pole if geodesic is a not a diameter in the Klein model&quot;</span>
            <span class="p">)</span>

        <span class="k">def</span> <span class="nf">tangent</span><span class="p">(</span><span class="n">endpoint</span><span class="p">):</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">endpoint</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span>
                <span class="o">-</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>

        <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>

        <span class="n">pole</span> <span class="o">=</span> <span class="n">tangent</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">_intersection</span><span class="p">(</span><span class="n">tangent</span><span class="p">(</span><span class="n">B</span><span class="p">))</span>

        <span class="k">assert</span> <span class="n">pole</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;non-parallel lines must intersect&quot;</span>

        <span class="k">return</span> <span class="n">pole</span></div>

<div class="viewcode-block" id="HyperbolicGeodesic.perpendicular"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeodesic.perpendicular">[docs]</a>    <span class="k">def</span> <span class="nf">perpendicular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point_or_geodesic</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a geodesic that is perpendicular to this geodesic.</span>

<span class="sd">        If ``point_or_geodesic`` is a point, return a geodesic</span>
<span class="sd">        through that point.</span>

<span class="sd">        If ``point_or_geodesic`` is another geodesic, return a</span>
<span class="sd">        geodesic that is also perpendicular to that geodesic.</span>

<span class="sd">        ALGORITHM:</span>

<span class="sd">        We use the construction as explained on `Wikipedia</span>
<span class="sd">        &lt;https://en.wikipedia.org/wiki/Beltrami%E2%80%93Klein_model#Compass_and_straightedge_constructions&gt;`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``point_or_geodesic`` -- a point or a geodesic in the</span>
<span class="sd">          hyperbolic plane or ``None`` (the default)</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Without parameters this method returns one of the many</span>
<span class="sd">        perpendicular geodesics::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: v = H.vertical(2)</span>
<span class="sd">            sage: v.perpendicular()</span>
<span class="sd">            {(x^2 + y^2) - 4*x - 1 = 0}</span>

<span class="sd">        We can request a perpendicular geodesic through a specific</span>
<span class="sd">        point::</span>

<span class="sd">            sage: v.perpendicular(2 + I)</span>
<span class="sd">            {(x^2 + y^2) - 4*x + 3 = 0}</span>
<span class="sd">            sage: v.perpendicular(I)</span>
<span class="sd">            {(x^2 + y^2) - 4*x - 1 = 0}</span>

<span class="sd">        In some cases, such a geodesic might not exist::</span>

<span class="sd">            sage: v.perpendicular(oo)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: ... does not define a chord in the Klein model</span>

<span class="sd">        We can request a geodesic that is also perpendicular to</span>
<span class="sd">        another geodesic::</span>

<span class="sd">            sage: v.perpendicular(H.half_circle(4, 1))</span>
<span class="sd">            {(x^2 + y^2) - 4*x + 1 = 0}</span>

<span class="sd">        In some cases, such a geodesic might not exist::</span>

<span class="sd">            sage: v.perpendicular(H.half_circle(2, 1))</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: ... does not define a chord in the Klein model</span>

<span class="sd">        TESTS:</span>

<span class="sd">        Verify that this also works for geodesic that have no finite pole::</span>

<span class="sd">            sage: H.vertical(0).perpendicular()</span>
<span class="sd">            {(x^2 + y^2) - 1 = 0}</span>

<span class="sd">            sage: H.half_circle(0, 1).perpendicular()</span>
<span class="sd">            {x = 0}</span>

<span class="sd">            sage: H.half_circle(0, 1).perpendicular(0)</span>
<span class="sd">            {x = 0}</span>

<span class="sd">            sage: H.half_circle(0, 1).perpendicular(2)</span>
<span class="sd">            {2*(x^2 + y^2) - 5*x + 2 = 0}</span>

<span class="sd">            sage: H.vertical(0).perpendicular(H.half_circle(0, 1))</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: no geodesic perpendicular to both {-x = 0} and {(x^2 + y^2) - 1 = 0}</span>

<span class="sd">            sage: H.half_circle(0, 1).perpendicular(H.vertical(0))</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: no geodesic perpendicular to both {(x^2 + y^2) - 1 = 0} and {-x = 0}</span>

<span class="sd">            sage: H.vertical(0).perpendicular(H.vertical(0))</span>
<span class="sd">            {(x^2 + y^2) - 1 = 0}</span>

<span class="sd">            sage: H.vertical(0).perpendicular(H.half_circle(0, 1))</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: no geodesic perpendicular to both {-x = 0} and {(x^2 + y^2) - 1 = 0}</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            Currently, the orientation of the returned geodesic is somewhat</span>
<span class="sd">            random. It should probably be counterclockwise to this geodesic.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">point_or_geodesic</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">point_or_geodesic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>

        <span class="n">point_or_geodesic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">point_or_geodesic</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point_or_geodesic</span><span class="p">,</span> <span class="n">HyperbolicGeodesic</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">point_or_geodesic</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unoriented</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">unoriented</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">perpendicular</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">an_element</span><span class="p">())</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_diameter</span><span class="p">()</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">is_diameter</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;no geodesic perpendicular to both </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">other</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">is_diameter</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">perpendicular</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_diameter</span><span class="p">():</span>
                <span class="c1"># Construct the line a + bx + cy = 0 perpendicular to the</span>
                <span class="c1"># diameter through the pole of the other geodesic.</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">)</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">pole</span><span class="p">()</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>
                <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>

                <span class="c1"># The line might be not intersect the Klein disk. An error is</span>
                <span class="c1"># raised here in that case.</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span> <span class="n">oriented</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># In the generic case, the perpendicular goes through both poles.</span>
            <span class="c1"># Throws an error if that line does not define a geodesic because</span>
            <span class="c1"># it&#39;s outside of the Klein disk.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pole</span><span class="p">(),</span> <span class="n">other</span><span class="o">.</span><span class="n">pole</span><span class="p">(),</span> <span class="n">oriented</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">point_or_geodesic</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_diameter</span><span class="p">():</span>
                <span class="c1"># Construct the line a + bx + cy = 0 perpendicular to the</span>
                <span class="c1"># diameter through the given point.</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">)</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">point</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>
                <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>

                <span class="n">perpendicular</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span>
                    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span> <span class="n">oriented</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">perpendicular</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pole</span><span class="p">(),</span> <span class="n">point</span><span class="p">,</span> <span class="n">oriented</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>

            <span class="k">assert</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">perpendicular</span>

            <span class="k">return</span> <span class="n">perpendicular</span></div>

<div class="viewcode-block" id="HyperbolicGeodesic.midpoint"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeodesic.midpoint">[docs]</a>    <span class="k">def</span> <span class="nf">midpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the fixed point of the (determinant one) Möbius transformation</span>
<span class="sd">        that interchanges the ideal endpoints of this geodesic.</span>

<span class="sd">        ALGORITHM:</span>

<span class="sd">        For the vertical connecting zero and infinity, the Möbius</span>
<span class="sd">        transformation sending z to `-1/z` has the imaginary unit as its fixed</span>
<span class="sd">        point. For a half circle centered at the origin its point on the</span>
<span class="sd">        imaginary axis must be the fixed point (due to symmetry or a direct</span>
<span class="sd">        computation.) All other geodesics, are just translated versions of</span>
<span class="sd">        these so we can just conjugate with a translation to determine the</span>
<span class="sd">        fixed point, i.e., the fixed point is a translate of one of the above.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicSegment</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: H.vertical(0).midpoint()</span>
<span class="sd">            I</span>
<span class="sd">            sage: H.vertical(1).midpoint()</span>
<span class="sd">            1 + I</span>
<span class="sd">            sage: H.half_circle(1, 1).midpoint()</span>
<span class="sd">            1 + I</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicSegment.midpoint`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_vertical</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">infinity</span><span class="p">():</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">)</span>

        <span class="n">ax</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">)</span>
        <span class="n">bx</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">)</span>

        <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">ax</span> <span class="o">+</span> <span class="n">bx</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">bx</span> <span class="o">-</span> <span class="n">ax</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">point</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicGeodesic.is_diameter"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeodesic.is_diameter">[docs]</a>    <span class="k">def</span> <span class="nf">is_diameter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this geodesic is a diameter in the Klein model.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: H.vertical(0).is_diameter()</span>
<span class="sd">            True</span>
<span class="sd">            sage: H.vertical(1).is_diameter()</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="HyperbolicGeodesic.is_vertical"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeodesic.is_vertical">[docs]</a>    <span class="k">def</span> <span class="nf">is_vertical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this geodesic is a vertical in the upper half plane.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: H.vertical(0).is_vertical()</span>
<span class="sd">            True</span>
<span class="sd">            sage: H.half_circle(0, 1).is_vertical()</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">infinity</span><span class="p">()</span> <span class="ow">in</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="HyperbolicGeodesic.__eq__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeodesic.__eq__">[docs]</a>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this geodesic is identical to other up to (orientation</span>
<span class="sd">        preserving) scaling of the defining equation.</span>


<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: H.vertical(0) == H.vertical(0)</span>
<span class="sd">            True</span>

<span class="sd">        We distinguish oriented and unoriented geodesics::</span>

<span class="sd">            sage: H.vertical(0).unoriented() == H.vertical(0)</span>
<span class="sd">            False</span>
<span class="sd">            sage: H.vertical(0).unoriented() != H.vertical(0)</span>
<span class="sd">            True</span>

<span class="sd">        We distinguish differently oriented geodesics::</span>

<span class="sd">            sage: H.vertical(0) == -H.vertical(0)</span>
<span class="sd">            False</span>
<span class="sd">            sage: H.vertical(0) != -H.vertical(0)</span>
<span class="sd">            True</span>

<span class="sd">        We do, however, identify geodesics whose defining equations differ by some scaling::</span>

<span class="sd">            sage: g = H.vertical(0)</span>
<span class="sd">            sage: g.equation(model=&quot;half_plane&quot;)</span>
<span class="sd">            (0, -2, 0)</span>
<span class="sd">            sage: h = H.geodesic(0, -4, 0, model=&quot;half_plane&quot;)</span>
<span class="sd">            sage: g.equation(model=&quot;half_plane&quot;) == h.equation(model=&quot;half_plane&quot;)</span>
<span class="sd">            False</span>
<span class="sd">            sage: g == h</span>
<span class="sd">            True</span>
<span class="sd">            sage: g != h</span>
<span class="sd">            False</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            Over inexact rings, this method is not very reliable. To some</span>
<span class="sd">            extent this is inherent to the problem but also the implementation</span>
<span class="sd">            uses generic predicates instead of relying on a specialized</span>
<span class="sd">            implementation in the :class:`HyperbolicGeometry`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">other</span><span class="p">)</span>

        <span class="c1"># See note in the docstring. We should use specialized geometry here.</span>
        <span class="n">equal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_equal</span>
        <span class="n">sgn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_sgn</span>

        <span class="k">if</span> <span class="n">sgn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">()</span> <span class="ow">or</span> <span class="n">sgn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">)</span> <span class="o">==</span> <span class="n">sgn</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_b</span><span class="p">))</span>
                <span class="ow">and</span> <span class="n">equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">_b</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_a</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_c</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">_b</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_c</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">()</span> <span class="ow">or</span> <span class="n">sgn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">)</span> <span class="o">==</span> <span class="n">sgn</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_c</span><span class="p">))</span>
                <span class="ow">and</span> <span class="n">equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">_c</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_a</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">_c</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_b</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">)</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicGeodesic.__contains__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeodesic.__contains__">[docs]</a>    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether ``point`` lies on this geodesic.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        ::</span>

<span class="sd">            sage: g = H.geodesic(20, -479, 858, model=&quot;half_plane&quot;)</span>
<span class="sd">            sage: g.start() in g</span>
<span class="sd">            True</span>

<span class="sd">        We can often decide containment for points coming from geodesics::</span>

<span class="sd">            sage: g = H.geodesic(-1, -1/2)</span>
<span class="sd">            sage: h = H.geodesic(1, 1/2)</span>

<span class="sd">            sage: g.start() in g</span>
<span class="sd">            True</span>
<span class="sd">            sage: g.start() in h</span>
<span class="sd">            False</span>
<span class="sd">            sage: g.end() in g</span>
<span class="sd">            True</span>
<span class="sd">            sage: g.end() in h</span>
<span class="sd">            False</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            The implementation is currently not very robust over inexact rings.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">point</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">HyperbolicPoint</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;point must be a point in the hyperbolic plane&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">HyperbolicPointFromGeodesic</span><span class="p">):</span>
            <span class="c1"># Short cut the most common case (that intersection cannot handle.)</span>
            <span class="k">if</span> <span class="n">point</span><span class="o">.</span><span class="n">_geodesic</span><span class="o">.</span><span class="n">unoriented</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">unoriented</span><span class="p">():</span>
                <span class="k">return</span> <span class="kc">True</span>

            <span class="n">intersection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intersection</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">_geodesic</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">intersection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">intersection</span><span class="o">.</span><span class="n">is_ultra_ideal</span><span class="p">():</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">return</span> <span class="n">intersection</span> <span class="o">==</span> <span class="n">point</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">point</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">equation</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>

        <span class="c1"># We should use a specialized predicate from the geometry class here to</span>
        <span class="c1"># handle points that are close to the geodesic in a more robust way.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_zero</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicGeodesic.dimension"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeodesic.dimension">[docs]</a>    <span class="k">def</span> <span class="nf">dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the dimension of this set, i.e., 1.</span>

<span class="sd">        This implements :meth:`HyperbolicConvexSet.dimension`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.vertical(0).dimension()</span>
<span class="sd">            1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">ZZ</span>

        <span class="k">return</span> <span class="n">ZZ</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicGeodesic.change"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeodesic.change">[docs]</a>    <span class="k">def</span> <span class="nf">change</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">ring</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">oriented</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a modified copy of this geodesic.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``ring`` -- a ring (default: ``None`` to keep the current</span>
<span class="sd">          :meth:`~HyperbolicPlane.base_ring`); the ring over which the new geodesic will be</span>
<span class="sd">          defined.</span>

<span class="sd">        - ``geometry`` -- a :class:`HyperbolicGeometry` (default: ``None`` to</span>
<span class="sd">          keep the current geometry); the geometry that will be used for the</span>
<span class="sd">          new geodesic.</span>

<span class="sd">        - ``oriented`` -- a boolean (default: ``None`` to keep the current</span>
<span class="sd">          orientedness); whether the new geodesic should be oriented.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane(AA)</span>

<span class="sd">        The base ring over which this geodesic is defined can be changed::</span>

<span class="sd">            sage: H.vertical(1).change_ring(QQ)</span>
<span class="sd">            {-x + 1 = 0}</span>

<span class="sd">        But we cannot change the base ring if the geodesic cannot be expressed</span>
<span class="sd">        in the smaller ring::</span>

<span class="sd">            sage: H.vertical(AA(2).sqrt()).change(ring=QQ)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: Cannot coerce irrational Algebraic Real ... to Rational</span>

<span class="sd">        We can forget the orientation of a geodesic::</span>

<span class="sd">            sage: v = H.vertical(0)</span>
<span class="sd">            sage: v.is_oriented()</span>
<span class="sd">            True</span>

<span class="sd">            sage: v = v.change(oriented=False)</span>
<span class="sd">            sage: v.is_oriented()</span>
<span class="sd">            False</span>

<span class="sd">        We can (somewhat randomly) pick the orientation of a geodesic::</span>

<span class="sd">            sage: v = v.change(oriented=True)</span>
<span class="sd">            sage: v.is_oriented()</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ring</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">geometry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
                <span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">geometry</span><span class="p">)</span>
                <span class="o">.</span><span class="n">geodesic</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">,</span>
                    <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span>
                    <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">oriented</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">(),</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">oriented</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">oriented</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">oriented</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">():</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">oriented</span><span class="o">=</span><span class="n">oriented</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="HyperbolicGeodesic.geodesic"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeodesic.geodesic">[docs]</a>    <span class="k">def</span> <span class="nf">geodesic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the geodesic underlying this set, i.e., this geodesic itself.</span>

<span class="sd">        This method exists to unify the interface between segments and</span>
<span class="sd">        geodesics, see :meth:`HyperbolicSegment.geodesic`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.vertical(0).geodesic() == H.vertical(0)</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="HyperbolicGeodesic.__hash__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeodesic.__hash__">[docs]</a>    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a hash value for this geodesic.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>

<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        Since oriented geodesics are hashable, they can be put in a hash table, such as a</span>
<span class="sd">        Python ``set``::</span>

<span class="sd">            sage: S = {H.vertical(0), -H.vertical(0)}</span>
<span class="sd">            sage: len(S)</span>
<span class="sd">            2</span>

<span class="sd">        Same for unoriented geodesics::</span>

<span class="sd">            sage: {H.vertical(0).unoriented(), (-H.vertical(0)).unoriented()}</span>
<span class="sd">            {{x = 0}}</span>

<span class="sd">        Oriented and unoriented geodesics are distinct and so is their hash</span>
<span class="sd">        value (typically)::</span>

<span class="sd">            sage: hash(H.vertical(0)) != hash(H.vertical(0).unoriented())</span>
<span class="sd">            True</span>

<span class="sd">        We can also mix oriented and unoriented geodesics in hash tables::</span>

<span class="sd">            sage: S = {H.vertical(0), -H.vertical(0), H.vertical(0).unoriented(), (-H.vertical(0)).unoriented()}</span>
<span class="sd">            sage: len(S)</span>
<span class="sd">            3</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">is_exact</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot hash geodesic defined over inexact base ring&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">equation</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span> <span class="n">normalization</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;one&quot;</span><span class="p">,</span> <span class="s2">&quot;gcd&quot;</span><span class="p">]))</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicGeodesic._intersection"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeodesic._intersection">[docs]</a>    <span class="k">def</span> <span class="nf">_intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the intersection of this geodesic and ``other``.</span>

<span class="sd">        Return ``None`` if they do not intersect in a point.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``other`` -- another :class:`HyperbolicGeodesic`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane(AA)</span>

<span class="sd">        Geodesics can intersect in a finite point::</span>

<span class="sd">            sage: H.vertical(0)._intersection(H.half_circle(0, 1))</span>
<span class="sd">            I</span>

<span class="sd">        Geodesics can intersect in an ideal point::</span>

<span class="sd">            sage: H.vertical(1)._intersection(H.half_circle(0, 1))</span>
<span class="sd">            1</span>

<span class="sd">        Geodesics might intersect in an ultra ideal point::</span>

<span class="sd">            sage: H.half_circle(0, 1)._intersection(H.half_circle(1, 8))</span>
<span class="sd">            (-3, 0)</span>

<span class="sd">        Or they are parallel in the Klein model::</span>

<span class="sd">            sage: H.half_circle(0, 1)._intersection(H.half_circle(0, 4))</span>

<span class="sd">        Note that geodesics that overlap do not intersect in a point::</span>

<span class="sd">            sage: H.vertical(0)._intersection(H.vertical(0))</span>

<span class="sd">            sage: H.vertical(0)._intersection(-H.vertical(0))</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: A = -H.vertical(0)</span>
<span class="sd">            sage: B = H.vertical(-1)</span>
<span class="sd">            sage: C = H.vertical(0)</span>

<span class="sd">            sage: A._intersection(B)</span>
<span class="sd">            ∞</span>

<span class="sd">            sage: A._intersection(C)</span>

<span class="sd">            sage: B._intersection(A)</span>
<span class="sd">            ∞</span>

<span class="sd">            sage: B._intersection(C)</span>
<span class="sd">            ∞</span>

<span class="sd">            sage: C._intersection(A)</span>

<span class="sd">            sage: C._intersection(B)</span>
<span class="sd">            ∞</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicConvexSet.intersection` for intersection with more</span>
<span class="sd">            general sets.</span>

<span class="sd">            :meth:`HyperbolicPlane.intersection` for the generic</span>
<span class="sd">            intersection of convex sets.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">HyperbolicGeodesic</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="n">xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">),</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_a</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_b</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_c</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">xy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">point</span><span class="p">(</span><span class="o">*</span><span class="n">xy</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_apply_isometry_klein</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">isometry</span><span class="p">,</span> <span class="n">on_right</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the result of applying the ``isometry`` to this geodesic.</span>

<span class="sd">        Helper methed for :meth:`HyperbolicConvexSet.apply_isometry`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``isometry`` -- a 3×3 matrix over the</span>
<span class="sd">          :meth:`~HyperbolicPlane.base_ring` describing an isometry in the</span>
<span class="sd">          hyperboloid model.</span>

<span class="sd">        - ``on_right`` -- a boolean (default: ``False``); whether to return the</span>
<span class="sd">          result of the right action.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        We apply a reflection to a geodesic::</span>

<span class="sd">            sage: isometry = matrix([[-1, 0, 0], [0, 1, 0], [0, 0, 1]])</span>
<span class="sd">            sage: g = H.geodesic(-1, 1)</span>

<span class="sd">            sage: g._apply_isometry_klein(isometry)</span>
<span class="sd">            {(x^2 + y^2) - 1 = 0}</span>

<span class="sd">        Note how the reflection swaps the end points of the geodesic::</span>

<span class="sd">            sage: g.start().apply_isometry(isometry, model=&quot;klein&quot;)</span>
<span class="sd">            1</span>
<span class="sd">            sage: g.end().apply_isometry(isometry, model=&quot;klein&quot;)</span>
<span class="sd">            -1</span>

<span class="sd">        However, the isometry maps the oriented geodesic to itself since what&#39;s</span>
<span class="sd">        left of the geodesic is not changed::</span>

<span class="sd">            sage: g._apply_isometry_klein(isometry) == g</span>
<span class="sd">            True</span>

<span class="sd">        An isometry that changes the orientation of the geodesic::</span>

<span class="sd">            sage: isometry = matrix([[-1, 0, 0], [0, -1, 0], [0, 0, 1]])</span>
<span class="sd">            sage: g._apply_isometry_klein(isometry)</span>
<span class="sd">            {-(x^2 + y^2) + 1 = 0}</span>

<span class="sd">        For an unoriented geodesic, the geodesic is unchanged though::</span>

<span class="sd">            sage: g.unoriented()._apply_isometry_klein(isometry) == g.unoriented()</span>
<span class="sd">            True</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: p0 = H(0)</span>
<span class="sd">            sage: p1 = H(1)</span>
<span class="sd">            sage: p2 = H(oo)</span>
<span class="sd">            sage: for (a, b, c, d) in [(2, 1, 1, 1), (1, 1, 0, 1), (1, 0, 1, 1), (2, 0, 0 , 1)]:</span>
<span class="sd">            ....:     for on_right in [True, False]:</span>
<span class="sd">            ....:         m = matrix(2, [a, b, c, d])</span>
<span class="sd">            ....:         q0 = p0.apply_isometry(m, on_right=on_right)</span>
<span class="sd">            ....:         q1 = p1.apply_isometry(m, on_right=on_right)</span>
<span class="sd">            ....:         q2 = p2.apply_isometry(m, on_right=on_right)</span>
<span class="sd">            ....:         assert H.geodesic(p0, p1).apply_isometry(m, on_right=on_right) == H.geodesic(q0, q1)</span>
<span class="sd">            ....:         assert H.geodesic(p1, p0).apply_isometry(m, on_right=on_right) == H.geodesic(q1, q0)</span>
<span class="sd">            ....:         assert H.geodesic(p1, p2).apply_isometry(m, on_right=on_right) == H.geodesic(q1, q2)</span>
<span class="sd">            ....:         assert H.geodesic(p2, p1).apply_isometry(m, on_right=on_right) == H.geodesic(q2, q1)</span>
<span class="sd">            ....:         assert H.geodesic(p2, p0).apply_isometry(m, on_right=on_right) == H.geodesic(q2, q0)</span>
<span class="sd">            ....:         assert H.geodesic(p0, p2).apply_isometry(m, on_right=on_right) == H.geodesic(q0, q2)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.modules.free_module_element</span> <span class="kn">import</span> <span class="n">vector</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">on_right</span><span class="p">:</span>
            <span class="n">isometry</span> <span class="o">=</span> <span class="n">isometry</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span>

        <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">vector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">base_ring</span><span class="p">(),</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">])</span> <span class="o">*</span> <span class="n">isometry</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span> <span class="n">oriented</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">()</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_isometry_equations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">isometry</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">λ</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return equations that must be satisfied if this set converts to</span>
<span class="sd">        ``image`` under ``isometry`` using ``λ`` as a free variable for the</span>
<span class="sd">        scaling factor.</span>

<span class="sd">        Helper method for :meth:`HyperbolicPlane._isometry_from_primitives`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``isometry`` -- a 3×3 matrix describing a (right) isometry; typically</span>
<span class="sd">          not over the base ring but in symbolic variables</span>

<span class="sd">        - ``image`` -- a geodesic</span>

<span class="sd">        - ``λ`` -- a symbolic variable</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: R.&lt;a, b, c, d, λ&gt; = QQ[]</span>
<span class="sd">            sage: isometry = H._isometry_gl2_to_sim12(matrix([[a, b], [c, d]]))</span>
<span class="sd">            sage: isometry</span>
<span class="sd">            [                            b*c + a*d                             a*c - b*d                             a*c + b*d]</span>
<span class="sd">            [                            a*b - c*d 1/2*a^2 - 1/2*b^2 - 1/2*c^2 + 1/2*d^2 1/2*a^2 + 1/2*b^2 - 1/2*c^2 - 1/2*d^2]</span>
<span class="sd">            [                            a*b + c*d 1/2*a^2 - 1/2*b^2 + 1/2*c^2 - 1/2*d^2 1/2*a^2 + 1/2*b^2 + 1/2*c^2 + 1/2*d^2]</span>

<span class="sd">            sage: H.vertical(0)._isometry_equations(isometry, H.vertical(1), λ)</span>
<span class="sd">            [-b*c - a*d + λ, -a*c + b*d + λ, -a*c - b*d - λ]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">λ</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>

        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">equation</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>
        <span class="n">fa</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="n">fc</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">equation</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">vector</span>

        <span class="n">condition</span> <span class="o">=</span> <span class="n">vector</span><span class="p">((</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span> <span class="o">*</span> <span class="n">isometry</span> <span class="o">-</span> <span class="n">λ</span> <span class="o">*</span> <span class="n">vector</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="p">(</span><span class="n">fb</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">fa</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">condition</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_an_element_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a finite point on this geodesic.</span>

<span class="sd">        ALGORITHM:</span>

<span class="sd">        We take the chord in the Klein model that intersects this geodesic</span>
<span class="sd">        perpendicularly and passes through the origin. The point of</span>
<span class="sd">        intersection must be a finite point.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.vertical(0).an_element()</span>
<span class="sd">            I</span>

<span class="sd">            sage: H.half_circle(0, 2).an_element()</span>
<span class="sd">            (0, 1/3)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">cross</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">cross</span>
        <span class="k">return</span> <span class="n">cross</span>

<div class="viewcode-block" id="HyperbolicGeodesic.vertices"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicGeodesic.vertices">[docs]</a>    <span class="k">def</span> <span class="nf">vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">marked_vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the ideal end points of this geodesic.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``marked_vertices`` -- a boolean (default: ``True``), ignored since a</span>
<span class="sd">          geodesic cannot have marked vertices.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.vertical(0).vertices()</span>
<span class="sd">            {0, ∞}</span>

<span class="sd">        Note that iteration in the set is not consistent with the orientation</span>
<span class="sd">        of the geodesic (it is chosen such that the subset relation on vertices</span>
<span class="sd">        can be checked quickly)::</span>

<span class="sd">            sage: v = H.vertical(0)</span>
<span class="sd">            sage: list(v.vertices())</span>
<span class="sd">            [0, ∞]</span>

<span class="sd">            sage: list((-v).vertices())</span>
<span class="sd">            [0, ∞]</span>

<span class="sd">        Use :meth:`HyperbolicOrientedGeodesic.start` and</span>
<span class="sd">        :meth:`HyperbolicOrientedGeodesic.end` to get the end points in an</span>
<span class="sd">        order that is consistent with orientation::</span>

<span class="sd">            sage: v.start(), v.end()</span>
<span class="sd">            (0, ∞)</span>

<span class="sd">            sage: (-v).start(), (-v).end()</span>
<span class="sd">            (∞, 0)</span>

<span class="sd">        The vertices can also be determined for an unoriented geodesic::</span>

<span class="sd">            sage: v.unoriented().vertices()</span>
<span class="sd">            {0, ∞}</span>

<span class="sd">        Vertices can be computed even if they do not have coordinates over the</span>
<span class="sd">        :meth:`HyperbolicPlane.base_ring`::</span>

<span class="sd">            sage: H.half_circle(0, 2).vertices()</span>
<span class="sd">            {-1.41421356237310, 1.41421356237310}</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            The implementation of this method is not robust over inexact rings.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicConvexSet.vertices` for more details.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">():</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="n">oriented</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">HyperbolicVertices</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">()])</span></div></div>


<div class="viewcode-block" id="HyperbolicUnorientedGeodesic"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicUnorientedGeodesic">[docs]</a><span class="k">class</span> <span class="nc">HyperbolicUnorientedGeodesic</span><span class="p">(</span><span class="n">HyperbolicGeodesic</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An unoriented geodesic in the hyperbolic plane.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">        sage: from flatsurf.geometry.hyperbolic import HyperbolicUnorientedGeodesic</span>
<span class="sd">        sage: H = HyperbolicPlane()</span>

<span class="sd">        sage: H.vertical(0).unoriented()</span>
<span class="sd">        {x = 0}</span>

<span class="sd">    TESTS::</span>

<span class="sd">        sage: v = H.vertical(0).unoriented()</span>
<span class="sd">        sage: isinstance(v, HyperbolicUnorientedGeodesic)</span>
<span class="sd">        True</span>

<span class="sd">        sage: TestSuite(v).run()</span>

<span class="sd">    .. SEEALSO::</span>

<span class="sd">        :meth:`HyperbolicPlane.geodesic` to create geodesics from points or equations</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="HyperbolicUnorientedGeodesic._isometry_conditions"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicUnorientedGeodesic._isometry_conditions">[docs]</a>    <span class="k">def</span> <span class="nf">_isometry_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterable of primitive pairs that must map to each other in an</span>
<span class="sd">        isometry that maps this set to ``other``.</span>

<span class="sd">        Helper method for :meth:`HyperbolicPlane._isometry_conditions`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: v = H.vertical(0).unoriented()</span>
<span class="sd">            sage: w = H.vertical(1).unoriented()</span>

<span class="sd">            sage: conditions = v._isometry_conditions(w)</span>
<span class="sd">            sage: list(conditions)</span>
<span class="sd">            [[({-x = 0}, {-x + 1 = 0})], [({-x = 0}, {x - 1 = 0})]]</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicConvexSet._isometry_conditions` for a general description.</span>

<span class="sd">        r&quot;&quot;&quot;</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="n">oriented</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="n">oriented</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">yield</span> <span class="p">[(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)]</span>
        <span class="k">yield</span> <span class="p">[(</span><span class="bp">self</span><span class="p">,</span> <span class="o">-</span><span class="n">other</span><span class="p">)]</span></div>

<div class="viewcode-block" id="HyperbolicUnorientedGeodesic.random_set"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicUnorientedGeodesic.random_set">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">random_set</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a random unoriented geodesic.</span>

<span class="sd">        This implements :meth:`HyperbolicConvexSet.random_set`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``parent`` -- the :class:`HyperbolicPlane` containing the geodesic</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicUnorientedGeodesic</span>
<span class="sd">            sage: x = HyperbolicUnorientedGeodesic.random_set(H)</span>

<span class="sd">            sage: x.dimension()</span>
<span class="sd">            1</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicPlane.random_element`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">HyperbolicOrientedGeodesic</span><span class="o">.</span><span class="n">random_set</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span><span class="o">.</span><span class="n">unoriented</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="HyperbolicOrientedGeodesic"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicOrientedGeodesic">[docs]</a><span class="k">class</span> <span class="nc">HyperbolicOrientedGeodesic</span><span class="p">(</span><span class="n">HyperbolicGeodesic</span><span class="p">,</span> <span class="n">HyperbolicOrientedConvexSet</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An oriented geodesic in the hyperbolic plane.</span>

<span class="sd">    Internally, we represent geodesics as the chords satisfying the equation</span>

<span class="sd">    .. MATH::</span>

<span class="sd">        a + bx + cy = 0</span>

<span class="sd">    in the unit disk of the Klein model.</span>

<span class="sd">    The geodesic is oriented such that the half space</span>

<span class="sd">    .. MATH::</span>

<span class="sd">        a + bx + cy ≥ 0</span>

<span class="sd">    is on its left.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``parent`` -- the :class:`HyperbolicPlane` this geodesic lives in</span>

<span class="sd">    - ``a`` -- an element of :meth:`HyperbolicPlane.base_ring`</span>

<span class="sd">    - ``b`` -- an element of :meth:`HyperbolicPlane.base_ring`</span>

<span class="sd">    - ``c`` -- an element of :meth:`HyperbolicPlane.base_ring`</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">        sage: H = HyperbolicPlane()</span>

<span class="sd">        sage: H.vertical(0)</span>
<span class="sd">        {-x = 0}</span>

<span class="sd">        sage: H.half_circle(0, 1)</span>
<span class="sd">        {(x^2 + y^2) - 1 = 0}</span>

<span class="sd">        sage: H.geodesic(H(I), 0)</span>
<span class="sd">        {x = 0}</span>

<span class="sd">    TESTS::</span>

<span class="sd">        sage: from flatsurf.geometry.hyperbolic import HyperbolicOrientedGeodesic</span>

<span class="sd">        sage: g = H.vertical(0)</span>

<span class="sd">        sage: isinstance(g, HyperbolicOrientedGeodesic)</span>
<span class="sd">        True</span>

<span class="sd">        sage: TestSuite(g).run()</span>

<span class="sd">    .. SEEALSO::</span>

<span class="sd">        :meth:`HyperbolicPlane.geodesic` for the most common ways to construct</span>
<span class="sd">        geodesics.</span>

<span class="sd">        :class:`HyperbolicUnorientedGeodesic` for geodesics without an explicit</span>
<span class="sd">        orientation and :class:`HyperbolicGeodesic` for shared functionality of</span>
<span class="sd">        all geodesics.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="HyperbolicOrientedGeodesic.__neg__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicOrientedGeodesic.__neg__">[docs]</a>    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return this geodesic with its orientation reversed.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: -H.vertical(0)</span>
<span class="sd">            {x = 0}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span>
            <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicOrientedGeodesic.start"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicOrientedGeodesic.start">[docs]</a>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the ideal starting point of this geodesic.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.vertical(0).start()</span>
<span class="sd">            0</span>

<span class="sd">        The coordinates of the end points of the half circle of radius</span>
<span class="sd">        `\sqrt{2}` around 0 can not be written down in the rationals::</span>

<span class="sd">            sage: p = H.half_circle(0, 2).start()</span>
<span class="sd">            sage: p</span>
<span class="sd">            -1.41421356237310</span>

<span class="sd">            sage: p.coordinates()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: square root of 32 ...</span>

<span class="sd">        Passing to a bigger field, the coordinates can be represented::</span>

<span class="sd">            sage: K.&lt;a&gt; = QQ.extension(x^2 - 2, embedding=1.4)</span>
<span class="sd">            sage: H.half_circle(0, 2).change_ring(K).start()</span>
<span class="sd">            -a</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicOrientedGeodesic.end"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicOrientedGeodesic.end">[docs]</a>    <span class="k">def</span> <span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the ideal end point of this geodesic.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.vertical(0).end()</span>
<span class="sd">            ∞</span>

<span class="sd">        The coordinates of the end points of the half circle of radius</span>
<span class="sd">        `\sqrt{2}` around 0 can not be written down in the rationals::</span>

<span class="sd">            sage: p = H.half_circle(0, 2).end()</span>
<span class="sd">            sage: p</span>
<span class="sd">            1.41421356237310</span>

<span class="sd">            sage: p.coordinates()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: square root of 32 ...</span>

<span class="sd">        Passing to a bigger field, the coordinates can be represented::</span>

<span class="sd">            sage: K.&lt;a&gt; = QQ.extension(x^2 - 2, embedding=1.4)</span>
<span class="sd">            sage: H.half_circle(0, 2).change_ring(K).end()</span>
<span class="sd">            a</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span></div>

<div class="viewcode-block" id="HyperbolicOrientedGeodesic.left_half_space"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicOrientedGeodesic.left_half_space">[docs]</a>    <span class="k">def</span> <span class="nf">left_half_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the closed half space to the left of this (oriented) geodesic.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane(AA)</span>

<span class="sd">            sage: H.vertical(0).left_half_space()</span>
<span class="sd">            {x ≤ 0}</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`right_half_space` for the corresponding half space on the other side</span>

<span class="sd">            :meth:`HyperbolicPlane.half_space` for another method to create half spaces.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">half_space</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicOrientedGeodesic.right_half_space"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicOrientedGeodesic.right_half_space">[docs]</a>    <span class="k">def</span> <span class="nf">right_half_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the closed half space to the right of this (oriented) geodesic.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane(AA)</span>

<span class="sd">            sage: H.vertical(0).right_half_space()</span>
<span class="sd">            {x ≥ 0}</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`left_half_space` for the corresponding half space on the other side</span>

<span class="sd">            :meth:`HyperbolicPlane.half_space` for another method to create half spaces.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">left_half_space</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_configuration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a classification of the (Euclidean) angle between this geodesic</span>
<span class="sd">        and ``other`` in the Klein model.</span>

<span class="sd">        This is a helper method for :meth:`HyperbolicConvexPolygon._normalize`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``other`` -- another :class:`HyperbolicOrientedGeodesic`</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        A string explaining how the two geodesics are oriented.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            This check is not robust over inexact rings and should be improved</span>
<span class="sd">            for that use case.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        Two geodesics can be equal::</span>

<span class="sd">            sage: H.vertical(0)._configuration(H.vertical(0))</span>
<span class="sd">            &#39;equal&#39;</span>

<span class="sd">        They can be equal with reversed orientation::</span>

<span class="sd">            sage: H.vertical(0)._configuration(-H.vertical(0))</span>
<span class="sd">            &#39;negative&#39;</span>

<span class="sd">        They can be parallel in the Klein model::</span>

<span class="sd">            sage: H.vertical(0)._configuration(H.geodesic(1/2, 2))</span>
<span class="sd">            &#39;parallel&#39;</span>

<span class="sd">        They can be parallel but with reversed orientation::</span>

<span class="sd">            sage: H.vertical(0)._configuration(H.geodesic(2, 1/2))</span>
<span class="sd">            &#39;anti-parallel&#39;</span>

<span class="sd">        Or they can intersect. We can distinguish the case that ``other``</span>
<span class="sd">        crosses over from left-to-right or from right-to-left::</span>

<span class="sd">            sage: H.vertical(0)._configuration(H.geodesic(1/3, 2))</span>
<span class="sd">            &#39;concave&#39;</span>

<span class="sd">            sage: H.vertical(0)._configuration(H.geodesic(1/2, 3))</span>
<span class="sd">            &#39;convex&#39;</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`~HyperbolicGeodesic._intersection` to compute the (ultra-ideal) intersection of geodesics</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">HyperbolicOrientedGeodesic</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;other must be an oriented geodesic&quot;</span><span class="p">)</span>

        <span class="n">intersection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intersection</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">intersection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># We should use a specialized method of geometry here to make this</span>
            <span class="c1"># more robust over inexact rings.</span>
            <span class="n">orientation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_sgn</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">_b</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">_c</span>
            <span class="p">)</span>

            <span class="k">assert</span> <span class="n">orientation</span> <span class="o">!=</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">orientation</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="k">return</span> <span class="s2">&quot;equal&quot;</span>

            <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="o">-</span><span class="n">other</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">orientation</span> <span class="o">&lt;</span> <span class="mi">0</span>
                <span class="k">return</span> <span class="s2">&quot;negative&quot;</span>

            <span class="k">if</span> <span class="n">orientation</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;parallel&quot;</span>

            <span class="k">return</span> <span class="s2">&quot;anti-parallel&quot;</span>

        <span class="n">tangent</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">)</span>
        <span class="n">orientation</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">tangent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">_b</span> <span class="o">-</span> <span class="n">tangent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">_c</span><span class="p">)</span><span class="o">.</span><span class="n">sign</span><span class="p">()</span>

        <span class="k">assert</span> <span class="n">orientation</span> <span class="o">!=</span> <span class="mi">0</span>

        <span class="c1"># Probably convex and concave are not the best terms here.</span>
        <span class="k">if</span> <span class="n">orientation</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;convex&quot;</span>

        <span class="c1"># We probably would not need to consider the concave case if we always</span>
        <span class="c1"># packed all geodesics into a bounding box that contains the unit disk.</span>
        <span class="k">return</span> <span class="s2">&quot;concave&quot;</span>

<div class="viewcode-block" id="HyperbolicOrientedGeodesic.parametrize"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicOrientedGeodesic.parametrize">[docs]</a>    <span class="k">def</span> <span class="nf">parametrize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the value of ``point`` in a linear parametrization of this</span>
<span class="sd">        geodesic.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``point`` -- a :class:`HyperbolicPoint` on this geodesic</span>

<span class="sd">        - ``model`` -- a string; currently only ``&quot;euclidean&quot;`` is supported</span>

<span class="sd">        - ``check`` -- a boolean (default: ``True``); whether to ensure that</span>
<span class="sd">          ``point`` is actually a point on the geodesic</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        We can parametrize points on a geodesic such that the order of the</span>
<span class="sd">        points corresponds to the parameters we get::</span>

<span class="sd">            sage: g = H.vertical(0)</span>

<span class="sd">            sage: g.parametrize(0, model=&quot;euclidean&quot;)</span>
<span class="sd">            -1</span>

<span class="sd">            sage: g.parametrize(I, model=&quot;euclidean&quot;)</span>
<span class="sd">            0</span>

<span class="sd">            sage: g.parametrize(2*I, model=&quot;euclidean&quot;)</span>
<span class="sd">            3/5</span>

<span class="sd">            sage: g.parametrize(oo, model=&quot;euclidean&quot;)</span>
<span class="sd">            1</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            This method is not robust for points over inexact rings and should</span>
<span class="sd">            be improved.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`unparametrize` for the recovers the point from the parameter</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
            <span class="n">point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">point</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">point</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;point must be on geodesic to be parametrized&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s2">&quot;euclidean&quot;</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>
            <span class="n">tangent</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">)</span>

            <span class="c1"># We should use a specialized predicate here to make this work</span>
            <span class="c1"># better over inexact rings.</span>
            <span class="n">coordinate</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_zero</span><span class="p">(</span><span class="n">tangent</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">point</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)[</span><span class="n">coordinate</span><span class="p">]</span> <span class="o">-</span> <span class="n">base</span><span class="p">[</span><span class="n">coordinate</span><span class="p">]</span>
            <span class="p">)</span> <span class="o">/</span> <span class="n">tangent</span><span class="p">[</span><span class="n">coordinate</span><span class="p">]</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot parametrize a geodesic over this model yet&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicOrientedGeodesic.unparametrize"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicOrientedGeodesic.unparametrize">[docs]</a>    <span class="k">def</span> <span class="nf">unparametrize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">λ</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the point parametrized by ``λ`` on this geodesic.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``λ`` -- an element of :meth:`HyperbolicPlane.base_ring`</span>

<span class="sd">        - ``model`` -- a string; currently only ``&quot;euclidean&quot;`` is supported</span>

<span class="sd">        - ``check`` -- a boolean (default: ``True``); whether to ensure that</span>
<span class="sd">          the returned point is not ultra ideal</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        This method is the inverse of :meth;`parametrize`::</span>

<span class="sd">            sage: g = H.vertical(0)</span>

<span class="sd">            sage: g.unparametrize(g.parametrize(0, model=&quot;euclidean&quot;), model=&quot;euclidean&quot;)</span>
<span class="sd">            0</span>

<span class="sd">            sage: g.unparametrize(g.parametrize(I, model=&quot;euclidean&quot;), model=&quot;euclidean&quot;)</span>
<span class="sd">            I</span>

<span class="sd">            sage: g.unparametrize(g.parametrize(2*I, model=&quot;euclidean&quot;), model=&quot;euclidean&quot;)</span>
<span class="sd">            2*I</span>

<span class="sd">            sage: g.unparametrize(g.parametrize(oo, model=&quot;euclidean&quot;), model=&quot;euclidean&quot;)</span>
<span class="sd">            ∞</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s2">&quot;euclidean&quot;</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>
            <span class="n">tangent</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">)</span>

            <span class="n">λ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()(</span><span class="n">λ</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">point</span><span class="p">(</span>
                <span class="n">x</span><span class="o">=</span><span class="n">base</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">λ</span> <span class="o">*</span> <span class="n">tangent</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">y</span><span class="o">=</span><span class="n">base</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">λ</span> <span class="o">*</span> <span class="n">tangent</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span>
                <span class="n">check</span><span class="o">=</span><span class="n">check</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot parametrize a geodesic over this model yet&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicOrientedGeodesic.random_set"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicOrientedGeodesic.random_set">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">random_set</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a random oriented geodesic.</span>

<span class="sd">        This implements :meth:`HyperbolicConvexSet.random_set`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``parent`` -- the :class:`HyperbolicPlane` containing the geodesic</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicOrientedGeodesic</span>
<span class="sd">            sage: x = HyperbolicOrientedGeodesic.random_set(H)</span>

<span class="sd">            sage: x.dimension()</span>
<span class="sd">            1</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicPlane.random_element`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">HyperbolicPointFromCoordinates</span><span class="o">.</span><span class="n">random_set</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">while</span> <span class="n">b</span> <span class="o">==</span> <span class="n">a</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">HyperbolicPointFromCoordinates</span><span class="o">.</span><span class="n">random_set</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">parent</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="HyperbolicPoint"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPoint">[docs]</a><span class="k">class</span> <span class="nc">HyperbolicPoint</span><span class="p">(</span><span class="n">HyperbolicConvexSet</span><span class="p">,</span> <span class="n">Element</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A (possibly infinite or even ultra-ideal) point in the</span>
<span class="sd">    :class:`HyperbolicPlane`.</span>

<span class="sd">    This is the abstract base class providing shared functionality for</span>
<span class="sd">    :class:`HyperbolicPointFromCoordinates` and</span>
<span class="sd">    :class:`HyperbolicPointFromGeodesic`.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">        sage: H = HyperbolicPlane()</span>

<span class="sd">    A point with coordinates in the upper half plane::</span>

<span class="sd">        sage: p = H(0)</span>

<span class="sd">    The same point, created as an endpoint of a geodesic::</span>

<span class="sd">        sage: p = H.vertical(0).start()</span>

<span class="sd">    Another point on the same geodesic, a finite point::</span>

<span class="sd">        sage: p = H(I)</span>

<span class="sd">    TESTS::</span>

<span class="sd">        sage: from flatsurf.geometry.hyperbolic import HyperbolicPoint</span>
<span class="sd">        sage: isinstance(p, HyperbolicPoint)</span>
<span class="sd">        True</span>

<span class="sd">        sage: TestSuite(p).run()</span>

<span class="sd">    .. SEEALSO::</span>

<span class="sd">        :meth:`HyperbolicPlane.point` for ways to create points</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">require_normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify that this is a (possibly infinite) point in the hyperbolic plane.</span>

<span class="sd">        Implements :meth:`HyperbolicConvexSet._check`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``require_normalized`` -- a boolean (default: ``True``); ignored</span>

<span class="sd">        EXAMPLES::</span>


<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicGeodesic</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: p = H(0)</span>
<span class="sd">            sage: p._check()</span>

<span class="sd">            sage: p = H.point(2, 0, model=&quot;klein&quot;, check=False)</span>
<span class="sd">            sage: p._check()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: point (2, 0) is not in the unit disk in the Klein model</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`is_ultra_ideal` to see whether a point is outside of the Klein disk</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ultra_ideal</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;point </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s1">&#39;klein&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2"> is not in the unit disk in the Klein model&quot;</span>
            <span class="p">)</span>

<div class="viewcode-block" id="HyperbolicPoint.is_ideal"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPoint.is_ideal">[docs]</a>    <span class="k">def</span> <span class="nf">is_ideal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this point is at infinity.</span>

<span class="sd">        This implements :meth:`HyperbolicConvexSet.is_ideal`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicGeodesic</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H(0).is_ideal()</span>
<span class="sd">            True</span>

<span class="sd">            sage: H(I).is_ideal()</span>
<span class="sd">            False</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            This check is not very robust over inexact rings and should be improved.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`is_ultra_ideal`, :meth:`is_finite`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>
        <span class="c1"># We should use a specialized predicate from the geometry here to be</span>
        <span class="c1"># more robust over inexact rings.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_cmp</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="HyperbolicPoint.is_ultra_ideal"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPoint.is_ultra_ideal">[docs]</a>    <span class="k">def</span> <span class="nf">is_ultra_ideal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this point is ultra-ideal, i.e., outside of the Klein</span>
<span class="sd">        disk.</span>

<span class="sd">        This implements :meth;`HyperbolicConvexSet.is_ultra_ideal`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicGeodesic</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H(0).is_ultra_ideal()</span>
<span class="sd">            False</span>

<span class="sd">            sage: H(I).is_ultra_ideal()</span>
<span class="sd">            False</span>

<span class="sd">            sage: H.point(2, 0, model=&quot;klein&quot;, check=False).is_ultra_ideal()</span>
<span class="sd">            True</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            This check is not very robust over inexact rings and should be improved.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`is_ideal`, :meth:`is_finite`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>
        <span class="c1"># We should use a specialized predicate from the geometry here to be</span>
        <span class="c1"># more robust over inexact rings.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_cmp</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="HyperbolicPoint.is_finite"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPoint.is_finite">[docs]</a>    <span class="k">def</span> <span class="nf">is_finite</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this point is finite.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H(0).is_finite()</span>
<span class="sd">            False</span>

<span class="sd">            sage: H(I).is_finite()</span>
<span class="sd">            True</span>

<span class="sd">            sage: H.half_circle(0, 2).start().is_finite()</span>
<span class="sd">            False</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            Currently, the implementation is not robust over inexact rings.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`is_ideal`, :meth:`is_ultra_ideal`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>
        <span class="c1"># We should use specialized predicate from the geometry implementation</span>
        <span class="c1"># here to make this more robust over inexact rings.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_cmp</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="HyperbolicPoint.half_spaces"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPoint.half_spaces">[docs]</a>    <span class="k">def</span> <span class="nf">half_spaces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a set of half spaces whose intersection is this point.</span>

<span class="sd">        Implements :meth:`HyperbolicConvexSet.half_spaces`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H(I).half_spaces()</span>
<span class="sd">            {{(x^2 + y^2) + 2*x - 1 ≤ 0}, {x ≥ 0}, {(x^2 + y^2) - 1 ≥ 0}}</span>

<span class="sd">            sage: H(I + 1).half_spaces()</span>
<span class="sd">            {{x - 1 ≤ 0}, {(x^2 + y^2) - 3*x + 1 ≤ 0}, {(x^2 + y^2) - 2 ≥ 0}}</span>

<span class="sd">            sage: H.infinity().half_spaces()</span>
<span class="sd">            {{x ≤ 0}, {x - 1 ≥ 0}}</span>

<span class="sd">            sage: H(0).half_spaces()</span>
<span class="sd">            {{(x^2 + y^2) + x ≤ 0}, {x ≥ 0}}</span>

<span class="sd">            sage: H(-1).half_spaces()</span>
<span class="sd">            {{x + 1 ≤ 0}, {(x^2 + y^2) - 1 ≤ 0}}</span>

<span class="sd">            sage: H(1).half_spaces()</span>
<span class="sd">            {{(x^2 + y^2) - x ≤ 0}, {(x^2 + y^2) - 1 ≥ 0}}</span>

<span class="sd">            sage: H(2).half_spaces()</span>
<span class="sd">            {{2*(x^2 + y^2) - 3*x - 2 ≥ 0}, {3*(x^2 + y^2) - 7*x + 2 ≤ 0}}</span>

<span class="sd">            sage: H(-2).half_spaces()</span>
<span class="sd">            {{(x^2 + y^2) - x - 6 ≥ 0}, {2*(x^2 + y^2) + 3*x - 2 ≤ 0}}</span>

<span class="sd">            sage: H(1/2).half_spaces()</span>
<span class="sd">            {{6*(x^2 + y^2) - x - 1 ≤ 0}, {2*(x^2 + y^2) + 3*x - 2 ≥ 0}}</span>

<span class="sd">            sage: H(-1/2).half_spaces()</span>
<span class="sd">            {{2*(x^2 + y^2) + 7*x + 3 ≤ 0}, {2*(x^2 + y^2) - 3*x - 2 ≤ 0}}</span>

<span class="sd">        For ideal endpoints of geodesics that do not have coordinates over the</span>
<span class="sd">        base ring, we cannot produce defining half spaces since these would</span>
<span class="sd">        require equations over a quadratic extension as well::</span>

<span class="sd">            sage: H.half_circle(0, 2).start().half_spaces()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: square root of 32 ...</span>

<span class="sd">        ::</span>

<span class="sd">            sage: H = HyperbolicPlane(RR)</span>

<span class="sd">            sage: H(I).half_spaces()</span>
<span class="sd">            {{(x^2 + y^2) + 2.00000000000000*x - 1.00000000000000 ≤ 0},</span>
<span class="sd">             {x ≥ 0},</span>
<span class="sd">             {(x^2 + y^2) - 1.00000000000000 ≥ 0}}</span>

<span class="sd">            sage: H(0).half_spaces()</span>
<span class="sd">            {{(x^2 + y^2) + x ≤ 0}, {x ≥ 0}}</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicPlane.intersection` and</span>
<span class="sd">            :meth:`HyperbolicPlane.polygon` to intersect half spaces</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">HyperbolicHalfSpaces</span><span class="p">(</span>
                <span class="c1"># x ≥ x0</span>
                <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">half_space</span><span class="p">(</span><span class="o">-</span><span class="n">x0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">),</span>
                    <span class="c1"># y ≥ y0</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">half_space</span><span class="p">(</span><span class="o">-</span><span class="n">y0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">),</span>
                    <span class="c1"># x + y ≤ x0 + y0</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">half_space</span><span class="p">(</span><span class="n">x0</span> <span class="o">+</span> <span class="n">y0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">),</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">HyperbolicHalfSpaces</span><span class="p">(</span>
                <span class="c1"># left of the line from (0, 0) to this point</span>
                <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">half_space</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">y0</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">),</span>
                    <span class="c1"># right of a line to this point with a starting point right of (0, 0)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">half_space</span><span class="p">(</span>
                        <span class="o">-</span><span class="n">x0</span> <span class="o">*</span> <span class="n">x0</span> <span class="o">-</span> <span class="n">y0</span> <span class="o">*</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">-</span> <span class="n">x0</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span>
                    <span class="p">),</span>
                <span class="p">]</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicPoint.coordinates"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPoint.coordinates">[docs]</a>    <span class="k">def</span> <span class="nf">coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">,</span> <span class="n">ring</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return coordinates of this point in ``ring``.</span>

<span class="sd">        If ``model`` is ``&quot;half_plane&quot;``, return coordinates in the upper half</span>
<span class="sd">        plane model.</span>

<span class="sd">        If ``model`` is ``&quot;klein&quot;``, return Euclidean coordinates in the Klein</span>
<span class="sd">        model.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``model`` -- either ``&quot;half_plane&quot;`` or ``&quot;klein&quot;`` (default: ``&quot;half_plane&quot;``)</span>

<span class="sd">        - ``ring`` -- a ring, ``&quot;maybe&quot;``, or ``None`` (default: ``None``); in</span>
<span class="sd">          which ring the coordinates should be returned. If ``None``,</span>
<span class="sd">          coordinates are returned in the :meth:`HyperbolicPlane.base_ring`. If</span>
<span class="sd">          ``&quot;maybe&quot;``, same as ``None`` but instead of throwing an exception if</span>
<span class="sd">          the coordinates do not exist in the base ring, ``None`` is returned.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            It would be good to add a ``&quot;extension&quot;`` mode here to</span>
<span class="sd">            automatically take a ring extension where the coordinates live.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H(I).coordinates()</span>
<span class="sd">            (0, 1)</span>

<span class="sd">            sage: H(0).coordinates()</span>
<span class="sd">            (0, 0)</span>

<span class="sd">        The point at infinity has no coordinates in the upper half plane model::</span>

<span class="sd">            sage: H(oo).coordinates()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: point has no coordinates in the upper half plane</span>

<span class="sd">        Some points have coordinates in the Klein model but not in the upper</span>
<span class="sd">        half plane model::</span>

<span class="sd">            sage: p = H.point(1/2, 0, model=&quot;klein&quot;)</span>

<span class="sd">            sage: p.coordinates(model=&quot;klein&quot;)</span>
<span class="sd">            (1/2, 0)</span>

<span class="sd">            sage: p.coordinates()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: square root of 3/4 not in Rational Field</span>

<span class="sd">            sage: K.&lt;a&gt; = NumberField(x^2 - 3/4)</span>
<span class="sd">            sage: p.coordinates(ring=K)</span>
<span class="sd">            (1/2, a)</span>

<span class="sd">        Some points have no coordinates in either model unless we pass to a</span>
<span class="sd">        field extension::</span>

<span class="sd">            sage: p = H.half_circle(0, 2).start()</span>

<span class="sd">            sage: p.coordinates(model=&quot;half_plane&quot;)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: ...</span>

<span class="sd">            sage: p.coordinates(model=&quot;klein&quot;)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: ...</span>

<span class="sd">            sage: K.&lt;a&gt; = QuadraticField(2)</span>
<span class="sd">            sage: p.coordinates(ring=K)</span>
<span class="sd">            (-a, 0)</span>

<span class="sd">            sage: p.coordinates(ring=K, model=&quot;klein&quot;)</span>
<span class="sd">            (-2/3*a, 1/3)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coordinates_klein</span><span class="p">(</span><span class="n">ring</span><span class="o">=</span><span class="n">ring</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">coordinates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">ring</span> <span class="o">==</span> <span class="s2">&quot;maybe&quot;</span>
            <span class="k">return</span> <span class="n">coordinates</span>

        <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s2">&quot;klein&quot;</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">model</span> <span class="o">==</span> <span class="s2">&quot;half_plane&quot;</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">coordinates</span>

            <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">infinity</span><span class="p">()</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ultra_ideal</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;point has no coordinates in the upper half plane&quot;</span><span class="p">)</span>

            <span class="n">denominator</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">y</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">denominator</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">zero</span><span class="p">())</span>

            <span class="n">square</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sqrt</span> <span class="o">=</span> <span class="n">square</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">sqrt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">parent</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;square root of </span><span class="si">{</span><span class="n">square</span><span class="si">}</span><span class="s2"> not in </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ring</span> <span class="o">==</span> <span class="s2">&quot;maybe&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="k">raise</span>

            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">denominator</span><span class="p">,</span> <span class="n">sqrt</span> <span class="o">/</span> <span class="n">denominator</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot determine coordinates in this model yet&quot;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">coordinates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">coordinates</span></div>

<div class="viewcode-block" id="HyperbolicPoint.real"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPoint.real">[docs]</a>    <span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the real part of this point in the upper half plane model.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: p = H(I + 2)</span>
<span class="sd">            sage: p.real()</span>
<span class="sd">            2</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`imag`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="HyperbolicPoint.imag"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPoint.imag">[docs]</a>    <span class="k">def</span> <span class="nf">imag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the imaginary part of this point in the upper half plane model.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>

<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: p = H(I + 2)</span>
<span class="sd">            sage: p.imag()</span>
<span class="sd">            1</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`real`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="HyperbolicPoint.segment"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPoint.segment">[docs]</a>    <span class="k">def</span> <span class="nf">segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the oriented segment from this point to ``end``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``end`` -- another :class:`HyperbolicPoint`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H(0).segment(I)</span>
<span class="sd">            {-x = 0} ∩ {(x^2 + y^2) - 1 ≤ 0}</span>

<span class="sd">        A geodesic is returned when both endpoints are ideal points::</span>

<span class="sd">            sage: H(0).segment(1) == H.geodesic(0, 1)</span>
<span class="sd">            True</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicPlane.segment` for other ways to construct segments</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">end</span><span class="p">)</span>

        <span class="n">geodesic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ideal</span><span class="p">()</span> <span class="ow">and</span> <span class="n">end</span><span class="o">.</span><span class="n">is_ideal</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">geodesic</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span>
            <span class="n">geodesic</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="bp">self</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite</span><span class="p">()</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">end</span><span class="o">=</span><span class="n">end</span> <span class="k">if</span> <span class="n">end</span><span class="o">.</span><span class="n">is_finite</span><span class="p">()</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">assume_normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicPoint.plot"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPoint.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a plot of this subset.</span>

<span class="sd">        See :meth:`HyperbolicConvexPolygon.plot` for the supported keyword</span>
<span class="sd">        arguments.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``model`` -- one of ``&quot;half_plane&quot;`` and ``&quot;klein&quot;`` (default: ``&quot;half_plane&quot;``)</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        .. jupyter-execute::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H(I).plot()</span>
<span class="sd">            ...Graphics object consisting of 1 graphics primitive</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">ring</span><span class="o">=</span><span class="s2">&quot;maybe&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">coordinates</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">RR</span>

            <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">ring</span><span class="o">=</span><span class="n">RR</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">point</span>

        <span class="c1"># We need to wrap the coordinates into a list so they are not</span>
        <span class="c1"># interpreted as a list of complex numbers.</span>
        <span class="n">plot</span> <span class="o">=</span> <span class="n">point</span><span class="p">([</span><span class="n">coordinates</span><span class="p">],</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enhance_plot</span><span class="p">(</span><span class="n">plot</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicPoint.dimension"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPoint.dimension">[docs]</a>    <span class="k">def</span> <span class="nf">dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the dimension of this point, i.e., 0.</span>

<span class="sd">        This implements :meth:`HyperbolicConvexSet.dimension`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H(0).dimension()</span>
<span class="sd">            0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">ZZ</span>

        <span class="k">return</span> <span class="n">ZZ</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span></div>

<div class="viewcode-block" id="HyperbolicPoint.vertices"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPoint.vertices">[docs]</a>    <span class="k">def</span> <span class="nf">vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">marked_vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the vertices of this point, i.e., this point.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``marked_vertices`` -- a boolean (default: ``True``), ignored since a</span>
<span class="sd">          point cannot have marked vertices.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H(oo).vertices()</span>
<span class="sd">            {∞,}</span>

<span class="sd">        Vertices can be computed even if they do not have coordinates over the</span>
<span class="sd">        :meth:`HyperbolicPlane.base_ring`::</span>

<span class="sd">            sage: H.half_circle(0, 2).start().vertices()</span>
<span class="sd">            {-1.41421356237310,}</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicConvexSet.vertices` for more details.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">HyperbolicVertices</span><span class="p">([</span><span class="bp">self</span><span class="p">])</span></div>

<div class="viewcode-block" id="HyperbolicPoint.__hash__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPoint.__hash__">[docs]</a>    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a hash value for this point.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>

<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        Since points are hashable, they can be put in a hash table, such as a</span>
<span class="sd">        Python ``set``::</span>

<span class="sd">            sage: S = {H(I), H(0)}</span>
<span class="sd">            sage: len(S)</span>
<span class="sd">            2</span>

<span class="sd">        ::</span>

<span class="sd">            sage: {H.half_circle(0, 1).start(), H.half_circle(-2, 1).end()}</span>
<span class="sd">            {-1}</span>

<span class="sd">        Also, endpoints of geodesics that have no coordinates in the base ring</span>
<span class="sd">        can be hashed, see :meth:`HyperbolicPointFromGeodesic.__hash__`::</span>

<span class="sd">            sage: S = {H.half_circle(0, 2).start()}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">is_exact</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot hash a point defined over inexact base ring&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">ring</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">base_ring</span><span class="p">(),</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_isometry_equations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">isometry</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">λ</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return equations that must be satisfied if this set converts to</span>
<span class="sd">        ``image`` under ``isometry`` using ``λ`` as a free variable for the</span>
<span class="sd">        scaling factor.</span>

<span class="sd">        Helper method for :meth:`HyperbolicPlane._isometry_from_primitives`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``isometry`` -- a 3×3 matrix describing a (right) isometry; typically</span>
<span class="sd">          not over the base ring but in symbolic variables</span>

<span class="sd">        - ``image`` -- a point</span>

<span class="sd">        - ``λ`` -- a symbolic variable</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: R.&lt;a, b, c, d, λ&gt; = QQ[]</span>
<span class="sd">            sage: isometry = H._isometry_gl2_to_sim12(matrix([[a, b], [c, d]]))</span>
<span class="sd">            sage: isometry</span>
<span class="sd">            [                            b*c + a*d                             a*c - b*d                             a*c + b*d]</span>
<span class="sd">            [                            a*b - c*d 1/2*a^2 - 1/2*b^2 - 1/2*c^2 + 1/2*d^2 1/2*a^2 + 1/2*b^2 - 1/2*c^2 - 1/2*d^2]</span>
<span class="sd">            [                            a*b + c*d 1/2*a^2 - 1/2*b^2 + 1/2*c^2 - 1/2*d^2 1/2*a^2 + 1/2*b^2 + 1/2*c^2 + 1/2*d^2]</span>

<span class="sd">            sage: H(I)._isometry_equations(isometry, H(2*I), λ)</span>
<span class="sd">            [-8/5*a*c - 2/5*b*d,</span>
<span class="sd">             -4/5*a^2 - 1/5*b^2 + 4/5*c^2 + 1/5*d^2,</span>
<span class="sd">             -4/5*a^2 - 1/5*b^2 - 4/5*c^2 - 1/5*d^2 + λ]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">λ</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">),</span> <span class="n">R</span><span class="o">.</span><span class="n">one</span><span class="p">())</span>
        <span class="n">fx</span><span class="p">,</span> <span class="n">fy</span><span class="p">,</span> <span class="n">fz</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">image</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">),</span> <span class="n">R</span><span class="o">.</span><span class="n">one</span><span class="p">())</span>

        <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">vector</span>

        <span class="n">equations</span> <span class="o">=</span> <span class="n">λ</span> <span class="o">*</span> <span class="n">vector</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span> <span class="o">-</span> <span class="n">isometry</span> <span class="o">*</span> <span class="n">vector</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">fy</span><span class="p">,</span> <span class="n">fz</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">equations</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>

<div class="viewcode-block" id="HyperbolicPoint.__contains__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPoint.__contains__">[docs]</a>    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether the set comprised of this point contains ``point``,</span>
<span class="sd">        i.e., whether the points are equal.</span>

<span class="sd">        This implements :meth:`HyperbolicConvexSet.__contains__` without</span>
<span class="sd">        relying on :meth:`HyperbolicConvexSet.half_spaces` which can not be</span>
<span class="sd">        computed for points without coordinates in the</span>
<span class="sd">        :meth:`HyperbolicPlane.base_ring`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: p = H(0)</span>
<span class="sd">            sage: q = H.half_circle(0, 2).start()</span>

<span class="sd">            sage: p in p</span>
<span class="sd">            True</span>

<span class="sd">            sage: p in q</span>
<span class="sd">            False</span>

<span class="sd">            sage: q in p</span>
<span class="sd">            False</span>

<span class="sd">            sage: q in q</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">point</span></div></div>


<div class="viewcode-block" id="HyperbolicPointFromCoordinates"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPointFromCoordinates">[docs]</a><span class="k">class</span> <span class="nc">HyperbolicPointFromCoordinates</span><span class="p">(</span><span class="n">HyperbolicPoint</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A :class:`HyperbolicPoint` with explicit coordinates in the Klein model.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">        sage: from flatsurf.geometry.hyperbolic import HyperbolicPointFromCoordinates</span>
<span class="sd">        sage: H = HyperbolicPlane()</span>

<span class="sd">        sage: H.point(0, 0, model=&quot;klein&quot;)</span>
<span class="sd">        I</span>

<span class="sd">    Points with coordinates in the half plane model are also stored as points</span>
<span class="sd">    in the Klein model::</span>

<span class="sd">        sage: p = H.point(0, 0, model=&quot;half_plane&quot;)</span>

<span class="sd">        sage: isinstance(p, HyperbolicPointFromCoordinates)</span>
<span class="sd">        True</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``parent`` -- the :class:`HyperbolicPlane` containing this point</span>

<span class="sd">    - ``x`` -- an element of :meth:`HyperbolicPlane.base_ring`</span>

<span class="sd">    - ``y`` -- an element of :meth:`HyperbolicPlane.base_ring`</span>

<span class="sd">    .. SEEALSO::</span>

<span class="sd">        Use :meth;`HyperbolicPlane.point` to create points from coordinates</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="HyperbolicPointFromCoordinates.__init__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPointFromCoordinates.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: p = H.point(0, 0, model=&quot;klein&quot;)</span>
<span class="sd">            sage: TestSuite(p).run()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">parent</span><span class="o">.</span><span class="n">base_ring</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;x must be an element of the base ring&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">parent</span><span class="o">.</span><span class="n">base_ring</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;y must be an element of the base ring&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_coordinates</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_coordinates_klein</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the coordinates of this point in the Klein model.</span>

<span class="sd">        This is a helper method for :meth:`HyperbolicPoint.coordinates`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``ring`` -- see :meth:`HyperbolicPoint.coordinates` for this</span>
<span class="sd">          parameter</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: p = H.point(0, 0, model=&quot;klein&quot;)</span>
<span class="sd">            sage: p._coordinates_klein(ring=None)</span>
<span class="sd">            (0, 0)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coordinates</span>

        <span class="kn">from</span> <span class="nn">sage.categories.all</span> <span class="kn">import</span> <span class="n">Rings</span>

        <span class="k">if</span> <span class="n">ring</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ring</span> <span class="o">==</span> <span class="s2">&quot;maybe&quot;</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">ring</span> <span class="ow">in</span> <span class="n">Rings</span><span class="p">():</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">ring</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot produce coordinates for this ring yet&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>

    <span class="k">def</span> <span class="nf">_richcmp_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return how this point compares to ``other`` with respect to the ``op``</span>
<span class="sd">        operator.</span>

<span class="sd">        This is only implemented for the operators ``==`` and ``!=``. It</span>
<span class="sd">        returns whether two points are the same.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.infinity() == H.projective(1, 0)</span>
<span class="sd">            True</span>

<span class="sd">        TESTS:</span>

<span class="sd">        We can compare points even though their coordinates are only defined</span>
<span class="sd">        over a quadratic extension::</span>

<span class="sd">            sage: H.half_circle(0, 2).start() == H.half_circle(0, 2).start()</span>
<span class="sd">            True</span>

<span class="sd">            sage: H.half_circle(0, 2).start() == H.half_circle(0, 2).end()</span>
<span class="sd">            False</span>

<span class="sd">            sage: H.half_circle(0, 2).start() == H(0)</span>
<span class="sd">            False</span>

<span class="sd">            sage: H.half_circle(0, 1).end() == H(1)</span>
<span class="sd">            True</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            Over inexact rings, this method is not very reliable. To some</span>
<span class="sd">            extent this is inherent to the problem but also the implementation</span>
<span class="sd">            uses generic predicates instead of relying on a specialized</span>
<span class="sd">            implementation in the :class:`HyperbolicGeometry`.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicConvexSet.__contains__` to check for containment</span>
<span class="sd">            of a point in a set</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.structure.richcmp</span> <span class="kn">import</span> <span class="n">op_EQ</span><span class="p">,</span> <span class="n">op_NE</span>

        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="n">op_NE</span><span class="p">:</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_richcmp_</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">op_EQ</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="n">op_EQ</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">HyperbolicPoint</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">HyperbolicPointFromGeodesic</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">other</span> <span class="o">==</span> <span class="bp">self</span>

            <span class="c1"># See note in the docstring. We should use specialized geometry</span>
            <span class="c1"># here to compare the coordinates simultaneously.</span>
            <span class="k">return</span> <span class="nb">all</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_equal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">),</span> <span class="n">other</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_richcmp_</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a printable representation of this point.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        We represent points in the upper half plane model if possible::</span>

<span class="sd">            sage: H.point(0, 0, model=&quot;klein&quot;)</span>
<span class="sd">            I</span>

<span class="sd">        For some points this is not possible without extending the coordinate</span>
<span class="sd">        ring. Then we show their coordinates in the Klein model::</span>

<span class="sd">            sage: H.point(1/2, 0, model=&quot;klein&quot;)</span>
<span class="sd">            (1/2, 0)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">infinity</span><span class="p">():</span>
            <span class="k">return</span> <span class="s2">&quot;∞&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ultra_ideal</span><span class="p">():</span>
            <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">))</span>

        <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">,</span> <span class="n">ring</span><span class="o">=</span><span class="s2">&quot;maybe&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coordinates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">))</span>

        <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">PowerSeriesRing</span>

        <span class="c1"># We represent x + y*I in R[[I]] so we do not have to reimplement printing ourselves.</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span>
            <span class="n">PowerSeriesRing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">base_ring</span><span class="p">(),</span> <span class="n">names</span><span class="o">=</span><span class="s2">&quot;I&quot;</span><span class="p">)(</span><span class="nb">list</span><span class="p">(</span><span class="n">coordinates</span><span class="p">))</span>
        <span class="p">)</span>

<div class="viewcode-block" id="HyperbolicPointFromCoordinates.change"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPointFromCoordinates.change">[docs]</a>    <span class="k">def</span> <span class="nf">change</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">oriented</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a modified copy of this point.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``ring`` -- a ring (default: ``None`` to keep the current</span>
<span class="sd">          :meth:`~HyperbolicPlane.base_ring`); the ring over which the point</span>
<span class="sd">          will be defined.</span>

<span class="sd">        - ``geometry`` -- a :class:`HyperbolicGeometry` (default: ``None`` to</span>
<span class="sd">          keep the current geometry); the geometry that will be used for the</span>
<span class="sd">          point.</span>

<span class="sd">        - ``oriented`` -- a boolean (default: ``None`` to keep the current</span>
<span class="sd">          orientedness); must be ``None`` or ``False`` since points cannot have</span>
<span class="sd">          an orientation.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        We change the base ring over which the point is defined::</span>

<span class="sd">            sage: p = H(0)</span>
<span class="sd">            sage: p.change(ring=AA)</span>
<span class="sd">            0</span>

<span class="sd">        We cannot make a point oriented::</span>

<span class="sd">            sage: p.change(oriented=True)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            NotImplementedError: cannot make a point oriented</span>

<span class="sd">            sage: p.change(oriented=False) == p</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">point</span><span class="p">(</span><span class="n">parent</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">parent</span><span class="o">.</span><span class="n">point</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_coordinates</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">oriented</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">oriented</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">oriented</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot make a point oriented&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ring</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">geometry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
                <span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">geometry</span><span class="p">)</span>
                <span class="o">.</span><span class="n">point</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_coordinates</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="k">def</span> <span class="nf">_apply_isometry_klein</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">isometry</span><span class="p">,</span> <span class="n">on_right</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the result of applying the ``isometry`` to this hyperbolic</span>
<span class="sd">        point.</span>

<span class="sd">        Helper method for :meth:`HyperbolicConvexSet.apply_isometry`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``isometry`` -- a 3×3 matrix over the</span>
<span class="sd">          :meth:`~HyperbolicPlane.base_ring` describing an isometry in the</span>
<span class="sd">          hyperboloid model.</span>

<span class="sd">        - ``on_right`` -- a boolean (default: ``False``) whether to return the</span>
<span class="sd">          result of the right action.</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: for (a, b, c, d) in [(2, 1, 1, 1), (1, 1, 0, 1), (1, 0, 1, 1), (2, 0, 0 , 1)]:</span>
<span class="sd">            ....:     m = matrix(2, [a, b, c, d])</span>
<span class="sd">            ....:     assert H(0).apply_isometry(m) == H(b / d if d else oo)</span>
<span class="sd">            ....:     assert H(1).apply_isometry(m) == H((a + b) / (c + d) if c+d else oo)</span>
<span class="sd">            ....:     assert H(oo).apply_isometry(m) == H(a / c if c else oo)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.modules.free_module_element</span> <span class="kn">import</span> <span class="n">vector</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">on_right</span><span class="p">:</span>
            <span class="n">isometry</span> <span class="o">=</span> <span class="n">isometry</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">isometry</span> <span class="o">*</span> <span class="n">vector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">base_ring</span><span class="p">(),</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">point</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">z</span><span class="p">,</span> <span class="n">y</span> <span class="o">/</span> <span class="n">z</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="HyperbolicPointFromCoordinates.random_set"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPointFromCoordinates.random_set">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">random_set</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a random hyperbolic point.</span>

<span class="sd">        This implements :meth:`HyperbolicConvexSet.random_set`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``parent`` -- the :class:`HyperbolicPlane` containing the point</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicPointFromCoordinates</span>
<span class="sd">            sage: x = HyperbolicPointFromCoordinates.random_set(H)</span>

<span class="sd">            sage: x.dimension()</span>
<span class="sd">            0</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicPlane.random_element`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">parent</span><span class="o">.</span><span class="n">point</span><span class="p">(</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">random_element</span><span class="p">(),</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span><span class="o">.</span><span class="n">abs</span><span class="p">(),</span>
            <span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">,</span>
            <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="HyperbolicPointFromGeodesic"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPointFromGeodesic">[docs]</a><span class="k">class</span> <span class="nc">HyperbolicPointFromGeodesic</span><span class="p">(</span><span class="n">HyperbolicPoint</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An ideal :class:`HyperbolicPoint`, the end point of a geodesic.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">        sage: H = HyperbolicPlane()</span>

<span class="sd">        sage: H.vertical(0).start()</span>
<span class="sd">        0</span>

<span class="sd">    This class is necessary because not all points have coordinates in the</span>
<span class="sd">    :meth:`HyperbolicPlane.base_ring`::</span>

<span class="sd">        sage: p = H.half_circle(0, 2).start()</span>

<span class="sd">        sage: p.coordinates(model=&quot;klein&quot;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError: ...</span>

<span class="sd">        sage: p.coordinates(model=&quot;half_plane&quot;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError: ...</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``parent`` -- the :class:`HyperbolicPlane` containing this point</span>

<span class="sd">    - ``geodesic`` -- to :class:`HyperbolicOrientedGeodesic` whose :meth:`HyperbolicOrientedGeodesic.start` this point is</span>

<span class="sd">    .. SEEALSO::</span>

<span class="sd">        Use :meth:`HyperbolicOrientedGeodesic.start` and</span>
<span class="sd">        :meth:`HyperbolicOrientedGeodesic.end` to create endpoints of geodesics</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="HyperbolicPointFromGeodesic.__init__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPointFromGeodesic.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">geodesic</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicPointFromGeodesic</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: p = H.half_circle(0, 2).start()</span>
<span class="sd">            sage: isinstance(p, HyperbolicPointFromGeodesic)</span>
<span class="sd">            True</span>

<span class="sd">            sage: TestSuite(p).run()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geodesic</span><span class="p">,</span> <span class="n">HyperbolicOrientedGeodesic</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;x must be an oriented geodesic&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span> <span class="o">=</span> <span class="n">geodesic</span></div>

<div class="viewcode-block" id="HyperbolicPointFromGeodesic.is_ideal"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPointFromGeodesic.is_ideal">[docs]</a>    <span class="k">def</span> <span class="nf">is_ideal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this is an infinite point, i.e., return ``True`` since</span>
<span class="sd">        this is an endpoint of a geodesic.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.vertical(0).start().is_ideal()</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="HyperbolicPointFromGeodesic.is_ultra_ideal"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPointFromGeodesic.is_ultra_ideal">[docs]</a>    <span class="k">def</span> <span class="nf">is_ultra_ideal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this is an ultra ideal point, i.e., return ``False``</span>
<span class="sd">        since this end point of a geodesic is not outside of the unit disk in</span>
<span class="sd">        the Klein model.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.vertical(0).start().is_ultra_ideal()</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="HyperbolicPointFromGeodesic.is_finite"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPointFromGeodesic.is_finite">[docs]</a>    <span class="k">def</span> <span class="nf">is_finite</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this is a finite point, i.e., return ``False`` since</span>
<span class="sd">        this end point of a geodesic is infinite.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.half_circle(0, 2).start().is_finite()</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span></div>

    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">_coordinates_klein</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the coordinates of this point in the Klein model.</span>

<span class="sd">        This is a helper method for :meth:`HyperbolicPoint.coordinates`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``ring`` -- see :meth:`HyperbolicPoint.coordinates` for this</span>
<span class="sd">          parameter</span>


<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: p = H.point(0, 0, model=&quot;klein&quot;)</span>
<span class="sd">            sage: p._coordinates_klein(ring=None)</span>
<span class="sd">            (0, 0)</span>

<span class="sd">        Since the coordinates are given by intersection a line with the unit</span>
<span class="sd">        circle, they might only exist over a quadratic extension::</span>

<span class="sd">            sage: p = H.half_circle(0, 2).start()</span>
<span class="sd">            sage: p._coordinates_klein(ring=None)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: ...</span>

<span class="sd">            sage: K.&lt;a&gt; = QuadraticField(2)</span>
<span class="sd">            sage: p._coordinates_klein(ring=K)</span>
<span class="sd">            (-2/3*a, 1/3)</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            The implementation of this predicate is not numerically robust over</span>
<span class="sd">            inexact rings and should be improved.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span><span class="o">.</span><span class="n">equation</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">)</span>

        <span class="c1"># We should probably use a specialized predicate of the geometry to make this</span>
        <span class="c1"># more robust over inexact rings.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_zero</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="n">point</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># We should probably use a specialized predicate of the geometry to make this</span>
            <span class="c1"># more robust over inexact rings.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_sgn</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">point</span><span class="p">(</span><span class="o">-</span><span class="n">c</span> <span class="o">/</span> <span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">point</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span> <span class="n">ring</span><span class="o">=</span><span class="n">ring</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">discriminant</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span>

            <span class="k">if</span> <span class="n">ring</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ring</span> <span class="o">==</span> <span class="s2">&quot;maybe&quot;</span><span class="p">:</span>
                <span class="n">sqrt_ring</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sqrt_ring</span> <span class="o">=</span> <span class="n">ring</span>

            <span class="n">discriminant</span> <span class="o">=</span> <span class="n">sqrt_ring</span><span class="p">(</span><span class="n">discriminant</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">sqrt</span> <span class="o">=</span> <span class="n">discriminant</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">sqrt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sqrt_ring</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;square root of </span><span class="si">{</span><span class="n">discriminant</span><span class="si">}</span><span class="s2"> not in </span><span class="si">{</span><span class="n">sqrt_ring</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ring</span> <span class="o">==</span> <span class="s2">&quot;maybe&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="k">raise</span>

            <span class="n">endpoints</span> <span class="o">=</span> <span class="p">((</span><span class="o">-</span><span class="n">b</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">a</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">a</span><span class="p">))</span>

            <span class="k">return</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
                <span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">sqrt_ring</span><span class="p">)</span>
                <span class="o">.</span><span class="n">point</span><span class="p">(</span>
                    <span class="c1"># We should probably use a specialized predicate of the geometry to make this</span>
                    <span class="c1"># more robust over inexact rings.</span>
                    <span class="p">(</span><span class="nb">min</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_sgn</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">max</span><span class="p">)(</span><span class="n">endpoints</span><span class="p">),</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">,</span>
                    <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span> <span class="n">ring</span><span class="o">=</span><span class="n">ring</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_richcmp_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return how this point compares to ``other`` with respect to the ``op``</span>
<span class="sd">        operator.</span>

<span class="sd">        This is only implemented for the operators ``==`` and ``!=``. It</span>
<span class="sd">        returns whether two points are the same.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.infinity() == H.projective(1, 0)</span>
<span class="sd">            True</span>

<span class="sd">        TESTS:</span>

<span class="sd">        We can compare points even though their coordinates are only defined</span>
<span class="sd">        over a quadratic extension::</span>

<span class="sd">            sage: H.half_circle(0, 2).start() == H.half_circle(0, 2).start()</span>
<span class="sd">            True</span>

<span class="sd">            sage: H.half_circle(0, 2).start() == H.half_circle(0, 2).end()</span>
<span class="sd">            False</span>

<span class="sd">            sage: H.half_circle(0, 2).start() == H(0)</span>
<span class="sd">            False</span>

<span class="sd">            sage: H.half_circle(0, 1).end() == H(1)</span>
<span class="sd">            True</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            Over inexact rings, this method is not very reliable. To some</span>
<span class="sd">            extent this is inherent to the problem but also the implementation</span>
<span class="sd">            uses generic predicates instead of relying on a specialized</span>
<span class="sd">            implementation in the :class:`HyperbolicGeometry`.</span>

<span class="sd">            For points that are not defined by coordinates but merely as the</span>
<span class="sd">            starting points of a hyperbolic geodesic, this is probably not</span>
<span class="sd">            implemented to the full extent possible. Instead, this will often</span>
<span class="sd">            throw a ``ValueError`` even though we could say something about the</span>
<span class="sd">            equality of the points.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.structure.richcmp</span> <span class="kn">import</span> <span class="n">op_EQ</span><span class="p">,</span> <span class="n">op_NE</span>

        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="n">op_NE</span><span class="p">:</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_richcmp_</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">op_EQ</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="n">op_EQ</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">HyperbolicPoint</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">HyperbolicPointFromGeodesic</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_geodesic</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span> <span class="o">==</span> <span class="o">-</span><span class="n">other</span><span class="o">.</span><span class="n">_geodesic</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>

                <span class="c1"># This is probably too complicated. If we can compute the</span>
                <span class="c1"># intersection, then it should have coordinates in the base</span>
                <span class="c1"># ring.</span>
                <span class="n">intersection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span><span class="o">.</span><span class="n">_intersection</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_geodesic</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">intersection</span> <span class="ow">and</span> <span class="n">other</span> <span class="o">==</span> <span class="n">intersection</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">is_ideal</span><span class="p">():</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="c1"># We should probably be a little bit more careful over inexact</span>
            <span class="c1"># rings here.</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span><span class="o">.</span><span class="n">parametrize</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_richcmp_</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a printable representation of this point.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        We try to represent this point in the upper half plane::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.vertical(0).start()</span>
<span class="sd">            0</span>

<span class="sd">        When this is not possible, we show approximate coordinates::</span>

<span class="sd">            sage: H.half_circle(0, 2).start()</span>
<span class="sd">            -1.41421356237310</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: geodesic = H.geodesic(733833/5522174119, -242010/5522174119, -105111/788882017, model=&quot;klein&quot;)</span>
<span class="sd">            sage: geodesic.start()</span>
<span class="sd">            3.03625883227966</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">infinity</span><span class="p">():</span>
            <span class="k">return</span> <span class="s2">&quot;∞&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ultra_ideal</span><span class="p">():</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">,</span> <span class="n">ring</span><span class="o">=</span><span class="s2">&quot;maybe&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">coordinates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">point</span><span class="p">(</span><span class="o">*</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">RR</span>

        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">RR</span><span class="p">))</span>

<div class="viewcode-block" id="HyperbolicPointFromGeodesic.change"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPointFromGeodesic.change">[docs]</a>    <span class="k">def</span> <span class="nf">change</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">oriented</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a modified copy of this point.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``ring`` -- a ring (default: ``None`` to keep the current</span>
<span class="sd">          :meth:`~HyperbolicPlane.base_ring`); the ring over which the point</span>
<span class="sd">          will be defined.</span>

<span class="sd">        - ``geometry`` -- a :class:`HyperbolicGeometry` (default: ``None`` to</span>
<span class="sd">          keep the current geometry); the geometry that will be used for the</span>
<span class="sd">          point.</span>

<span class="sd">        - ``oriented`` -- a boolean (default: ``None`` to keep the current</span>
<span class="sd">          orientedness); must be ``None`` or ``False`` since points cannot have</span>
<span class="sd">          an orientation.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        We change the base ring over which the point is defined::</span>

<span class="sd">            sage: p = H.half_circle(0, 2).start()</span>
<span class="sd">            sage: p.change(ring=AA)</span>
<span class="sd">            -1.414213562373095?</span>

<span class="sd">        We cannot make a point oriented::</span>

<span class="sd">            sage: p.change(oriented=True)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            NotImplementedError: cannot change orientation of a point</span>

<span class="sd">            sage: p.change(oriented=False) == p</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">oriented</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">oriented</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">oriented</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot change orientation of a point&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ring</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">geometry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="n">ring</span><span class="o">=</span><span class="n">ring</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">geometry</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="HyperbolicPointFromGeodesic.__hash__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicPointFromGeodesic.__hash__">[docs]</a>    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a hash value for this point.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>

<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        Points that are given as the endpoints of a geodesic may or may not</span>
<span class="sd">        have coordinates over the base ring::</span>

<span class="sd">            sage: H.half_circle(0, 1).start().coordinates(model=&quot;klein&quot;)</span>
<span class="sd">            (-1, 0)</span>
<span class="sd">            sage: H.half_circle(0, 2).start().coordinates(model=&quot;klein&quot;)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: square root of 32 not in Rational Field</span>

<span class="sd">        While they always have coordinates in a quadratic extension, the hash</span>
<span class="sd">        of the coordinates in the extension might not be consistent with has</span>
<span class="sd">        values in the base ring, so we cannot simply hash the coordinates over</span>
<span class="sd">        some field extension::</span>

<span class="sd">            sage: hash(QQ(1/2)) == hash(AA(1/2))</span>
<span class="sd">            False</span>

<span class="sd">        To obtain consistent hash values for sets over the same base ring, at</span>
<span class="sd">        least if that base ring is a field, we observe that a point whose</span>
<span class="sd">        coordinates are not in the base ring cannot be the starting point of</span>
<span class="sd">        two different geodesics with an equation in the base ring. Indeed, for</span>
<span class="sd">        it otherwise had coordinates in the base ring as it were the</span>
<span class="sd">        intersection of these two geodesics and whence a solution to a linear</span>
<span class="sd">        equation with coefficients in the base ring. So, for points that have</span>
<span class="sd">        no coordinates in the base ring, we can hash the equation of the</span>
<span class="sd">        oriented geodesic to obtain a hash value::</span>

<span class="sd">            sage: hash(H.half_circle(0, 2).start()) != hash(H.half_circle(0, 2).end())</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span> <span class="n">ring</span><span class="o">=</span><span class="s2">&quot;maybe&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span>

        <span class="kn">from</span> <span class="nn">sage.categories.all</span> <span class="kn">import</span> <span class="n">Fields</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Fields</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;cannot hash point defined by a geodesic over a non-field yet&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_apply_isometry_klein</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">isometry</span><span class="p">,</span> <span class="n">on_right</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the result of applying the ``isometry`` to this hyperbolic</span>
<span class="sd">        point.</span>

<span class="sd">        Helper method for :meth:`HyperbolicConvexSet.apply_isometry`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``isometry`` -- a 3×3 matrix over the</span>
<span class="sd">          :meth:`~HyperbolicPlane.base_ring` describing an isometry in the</span>
<span class="sd">          hyperboloid model.</span>

<span class="sd">        - ``on_right`` -- a boolean (default: ``False``) whether to return the</span>
<span class="sd">          result of the right action.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: point = H.half_circle(0, 2).start()</span>
<span class="sd">            sage: point</span>
<span class="sd">            -1.41421356237310</span>

<span class="sd">        We apply an isometry of positive determinant::</span>

<span class="sd">            sage: isometry = matrix([[1, -1, 1], [1, 1/2, 1/2], [1, -1/2, 3/2]])</span>
<span class="sd">            sage: point._apply_isometry_klein(isometry)</span>
<span class="sd">            -0.414213562373095</span>

<span class="sd">        We apply an isometry of negative determinant::</span>

<span class="sd">            sage: isometry = matrix([[-1, 0, 0], [0, 1, 0], [0, 0, 1]])</span>
<span class="sd">            sage: point._apply_isometry_klein(isometry)</span>
<span class="sd">            1.41421356237310</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span><span class="o">.</span><span class="n">apply_isometry</span><span class="p">(</span>
            <span class="n">isometry</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span> <span class="n">on_right</span><span class="o">=</span><span class="n">on_right</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">isometry</span><span class="o">.</span><span class="n">det</span><span class="p">()</span><span class="o">.</span><span class="n">sign</span><span class="p">()</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># An isometry of negative determinant swaps the end points of the</span>
            <span class="c1"># geodesic</span>
            <span class="n">image</span> <span class="o">=</span> <span class="o">-</span><span class="n">image</span>

        <span class="k">return</span> <span class="n">image</span><span class="o">.</span><span class="n">start</span><span class="p">()</span></div>


<div class="viewcode-block" id="HyperbolicConvexPolygon"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexPolygon">[docs]</a><span class="k">class</span> <span class="nc">HyperbolicConvexPolygon</span><span class="p">(</span><span class="n">HyperbolicConvexFacade</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A (possibly unbounded) closed polygon in the :class:`HyperbolicPlane`,</span>
<span class="sd">    i.e., the intersection of a finite number of :class:`half spaces</span>
<span class="sd">    &lt;HyperbolicHalfSpace&gt;`.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``parent`` -- the :class:`HyperbolicPlane` of which this is a subset</span>

<span class="sd">    - ``half_spaces`` -- the :class:`HyperbolicHalfSpace` of which this is an intersection</span>

<span class="sd">    - ``vertices`` -- marked vertices that should additionally be kept track of</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">        sage: H = HyperbolicPlane()</span>

<span class="sd">        sage: P = H.polygon([</span>
<span class="sd">        ....:     H.vertical(0).right_half_space(),</span>
<span class="sd">        ....:     H.vertical(1).left_half_space(),</span>
<span class="sd">        ....:     H.half_circle(0, 2).left_half_space()])</span>

<span class="sd">    .. SEEALSO::</span>

<span class="sd">        Use :meth:`HyperbolicPlane.polygon` and</span>
<span class="sd">        :meth:`HyperbolicPlane.intersection` to create polygons in the</span>
<span class="sd">        hyperbolic plane.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="HyperbolicConvexPolygon.__init__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexPolygon.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">half_spaces</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicConvexPolygon</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: P = H.polygon([</span>
<span class="sd">            ....:     H.vertical(0).right_half_space(),</span>
<span class="sd">            ....:     H.vertical(1).left_half_space(),</span>
<span class="sd">            ....:     H.half_circle(0, 2).left_half_space()])</span>

<span class="sd">            sage: isinstance(P, HyperbolicConvexPolygon)</span>
<span class="sd">            True</span>

<span class="sd">            sage: TestSuite(P).run()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">category</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">flatsurf.geometry.categories</span> <span class="kn">import</span> <span class="n">HyperbolicPolygons</span>

            <span class="n">category</span> <span class="o">=</span> <span class="n">HyperbolicPolygons</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">base_ring</span><span class="p">())</span><span class="o">.</span><span class="n">Convex</span><span class="p">()</span><span class="o">.</span><span class="n">Simple</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">category</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">half_spaces</span><span class="p">,</span> <span class="n">HyperbolicHalfSpaces</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;half_spaces must be HyperbolicHalfSpaces&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_half_spaces</span> <span class="o">=</span> <span class="n">half_spaces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_marked_vertices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">require_normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify that the marked vertices of this polygon are actually on the edges of the polygon.</span>

<span class="sd">        This implements :meth:`HyperbolicConvexSet._check`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``require_normalized`` -- a boolean (default: ``True``); whether to</span>
<span class="sd">          assume that normalization has already happened, i.e., marked vertices</span>
<span class="sd">          that are actual vertices have already been removed</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicConvexPolygon</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: P = H.polygon([</span>
<span class="sd">            ....:     H.vertical(0).right_half_space(),</span>
<span class="sd">            ....:     H.vertical(1).left_half_space(),</span>
<span class="sd">            ....:     H.half_circle(0, 2).left_half_space()],</span>
<span class="sd">            ....:     marked_vertices=[4], check=False)</span>

<span class="sd">            sage: P._check()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: marked vertex must be on an edge of the polygon</span>

<span class="sd">            sage: P = H.polygon([</span>
<span class="sd">            ....:     H.vertical(0).right_half_space(),</span>
<span class="sd">            ....:     H.vertical(1).left_half_space(),</span>
<span class="sd">            ....:     H.half_circle(0, 2).left_half_space()],</span>
<span class="sd">            ....:     marked_vertices=[oo], assume_minimal=True, check=False)</span>

<span class="sd">            sage: P._check()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: marked vertex must not be a non-marked vertex of the polygon</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_marked_vertices</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">vertex</span> <span class="ow">in</span> <span class="n">edge</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">marked_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;marked vertex must be on an edge of the polygon&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">require_normalized</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
                <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">(</span><span class="n">marked_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_marked_vertices</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;marked vertex must not be a non-marked vertex of the polygon&quot;</span>
                <span class="p">)</span>

<div class="viewcode-block" id="HyperbolicConvexPolygon._normalize"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexPolygon._normalize">[docs]</a>    <span class="k">def</span> <span class="nf">_normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">marked_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a convex set describing the intersection of the half spaces</span>
<span class="sd">        underlying this polygon.</span>

<span class="sd">        This implements :meth:`HyperbolicConvexSet._normalize`.</span>

<span class="sd">        The half spaces are assumed to be already sorted respecting</span>
<span class="sd">        :meth:`HyperbolicHalfSpaces._lt_`.</span>

<span class="sd">        ALGORITHM:</span>

<span class="sd">        We compute the intersection of the half spaces in the Klein model in</span>
<span class="sd">        several steps:</span>

<span class="sd">        * Drop trivially redundant half spaces, e.g., repeated ones.</span>
<span class="sd">        * Handle the case that the intersection is empty or a single point, see</span>
<span class="sd">          :meth:`_normalize_euclidean_boundary`.</span>
<span class="sd">        * Compute the intersection of the corresponding half spaces in the</span>
<span class="sd">          Euclidean plane, see :meth:`_normalize_drop_euclidean_redundant`.</span>
<span class="sd">        * Remove redundant half spaces that make no contribution for the unit</span>
<span class="sd">          disk of the Klein model, see</span>
<span class="sd">          :meth:`_normalize_drop_unit_disk_redundant`.</span>
<span class="sd">        * Determine of which nature (point, segment, line, polygon) the</span>
<span class="sd">          intersection of half spaces is and return the resulting set.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``marked_vertices`` -- a boolean (default: ``False``); whether to</span>
<span class="sd">          keep marked vertices when normalizing</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            Over inexact rings, this is probably mostly useless.</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        A helper to create non-normalized polygons for testing::</span>

<span class="sd">            sage: polygon = lambda *half_spaces: H.polygon(half_spaces, check=False, assume_sorted=False, assume_minimal=True)</span>

<span class="sd">        An instance that caused problems at some point::</span>

<span class="sd">            sage: P = polygon(</span>
<span class="sd">            ....:   H.geodesic(7, -4, -3, model=&quot;half_plane&quot;).left_half_space(),</span>
<span class="sd">            ....:   H.geodesic(1, -1, 0, model=&quot;half_plane&quot;).left_half_space(),</span>
<span class="sd">            ....:   H.vertical(1/2).right_half_space(),</span>
<span class="sd">            ....:   H.vertical(1).right_half_space(),</span>
<span class="sd">            ....:   H.vertical(1).right_half_space(),</span>
<span class="sd">            ....:   H.geodesic(1, 4, -5, model=&quot;half_plane&quot;).left_half_space(),</span>
<span class="sd">            ....:   H.geodesic(50, 57, -43, model=&quot;half_plane&quot;).left_half_space(),</span>
<span class="sd">            ....:   H.geodesic(3, 2, -3, model=&quot;half_plane&quot;).left_half_space()</span>
<span class="sd">            ....: )</span>
<span class="sd">            sage: P._normalize()</span>
<span class="sd">            {x - 1 ≥ 0}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">marked_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_marked_vertices</span> <span class="k">if</span> <span class="n">marked_vertices</span> <span class="k">else</span> <span class="p">[]</span>

        <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_drop_trivially_redundant</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_half_spaces</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot model intersection of no half spaces yet&quot;</span><span class="p">)</span>

        <span class="c1"># Find a segment on the boundary of the intersection.</span>
        <span class="n">boundary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_euclidean_boundary</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">boundary</span><span class="p">,</span> <span class="n">HyperbolicHalfSpace</span><span class="p">):</span>
            <span class="c1"># When there was no such segment, i.e., the intersection is empty</span>
            <span class="c1"># or just a point, we are done.</span>
            <span class="k">return</span> <span class="n">boundary</span>

        <span class="c1"># Compute a minimal subset of the half spaces that defines the intersection in the Euclidean plane.</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_drop_euclidean_redundant</span><span class="p">(</span><span class="n">boundary</span><span class="p">)</span>

        <span class="c1"># Remove half spaces that make no contribution when restricting to the unit disk of the Klein model.</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_drop_unit_disk_redundant</span><span class="p">()</span>

        <span class="n">marked_vertices</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">vertex</span> <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">marked_vertices</span> <span class="k">if</span> <span class="n">vertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="n">marked_vertices</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;cannot add marked vertices to low dimensional objects&quot;</span>
                <span class="p">)</span>

            <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">half_spaces</span><span class="p">(),</span>
                <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">assume_minimal</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">marked_vertices</span><span class="o">=</span><span class="n">marked_vertices</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_drop_marked_vertices</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="k">def</span> <span class="nf">_normalize_drop_trivially_redundant</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a sublist of the ``half_spaces`` defining this polygon without</span>
<span class="sd">        changing their intersection by removing some trivially redundant half</span>
<span class="sd">        spaces.</span>

<span class="sd">        The ``half_spaces`` are assumed to be sorted consistent with</span>
<span class="sd">        :meth:`HyperbolicHalfSpaces._lt_`.</span>

<span class="sd">        This is a helper method for :meth:`_normalize`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        A helper to create non-normalized polygons for testing::</span>

<span class="sd">            sage: polygon = lambda *half_spaces: H.polygon(half_spaces, check=False, assume_sorted=False, assume_minimal=True)</span>

<span class="sd">        Repeated half spaces are removed::</span>

<span class="sd">            sage: polygon(H.vertical(0).left_half_space(), H.vertical(0).left_half_space())._normalize_drop_trivially_redundant()</span>
<span class="sd">            {x ≤ 0}</span>

<span class="sd">        Inclusions of half spaces are simplified::</span>

<span class="sd">            sage: polygon(H.vertical(0).left_half_space(), H.geodesic(1/2, 2).left_half_space())._normalize_drop_trivially_redundant()</span>
<span class="sd">            {x ≤ 0}</span>

<span class="sd">        But only if the inclusion is already present when extending the half</span>
<span class="sd">        space from the Klein model to the entire Euclidean plane::</span>

<span class="sd">            sage: polygon(H.vertical(0).left_half_space(), H.vertical(1).left_half_space())._normalize_drop_trivially_redundant()</span>
<span class="sd">            {x ≤ 0} ∩ {x - 1 ≤ 0}</span>

<span class="sd">        TESTS:</span>

<span class="sd">        The intersection of two half circles centered at 0::</span>

<span class="sd">            sage: polygon(*(H.half_circle(0, 1).half_spaces() + H.half_circle(0, 2).half_spaces()))._normalize_drop_trivially_redundant()</span>
<span class="sd">            {(x^2 + y^2) - 1 ≤ 0} ∩ {(x^2 + y^2) - 2 ≥ 0}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reduced</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">half_space</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_half_spaces</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">reduced</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">half_space</span><span class="o">.</span><span class="n">equation</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>
                <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">reduced</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">equation</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>

                <span class="n">equal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_equal</span>
                <span class="n">sgn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_sgn</span>
                <span class="k">if</span> <span class="n">equal</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sgn</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="n">sgn</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sgn</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="n">sgn</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
                    <span class="c1"># The half spaces are parallel in the Euclidean plane. Since we</span>
                    <span class="c1"># assume spaces to be sorted by inclusion, we can drop this</span>
                    <span class="c1"># space.</span>
                    <span class="k">continue</span>

            <span class="n">reduced</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">half_space</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span>
            <span class="n">reduced</span><span class="p">,</span>
            <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">assume_minimal</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">marked_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="HyperbolicConvexPolygon._normalize_drop_euclidean_redundant"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexPolygon._normalize_drop_euclidean_redundant">[docs]</a>    <span class="k">def</span> <span class="nf">_normalize_drop_euclidean_redundant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">boundary</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a minimal sublist of the ``half_spaces`` defining this polygon</span>
<span class="sd">        that describe their intersection as half spaces of the Euclidean plane.</span>

<span class="sd">        Consider the half spaces in the Klein model. Ignoring the unit disk,</span>
<span class="sd">        they also describe half spaces in the Euclidean plane.</span>

<span class="sd">        The half space ``boundary`` must be one of the ``half_spaces`` that</span>
<span class="sd">        defines a boundary edge of the intersection polygon in the Euclidean</span>
<span class="sd">        plane.</span>

<span class="sd">        This is a helper method for :meth:`_normalize`.</span>

<span class="sd">        ALGORITHM:</span>

<span class="sd">        We use an approach similar to gift-wrapping (but from the inside) to remove</span>
<span class="sd">        redundant half spaces from the input list. We start from the</span>
<span class="sd">        ``boundary`` which is one of the minimal half spaces and extend to the</span>
<span class="sd">        full intersection by walking the sorted half spaces.</span>

<span class="sd">        Since we visit each half space once, this reduction runs in linear time</span>
<span class="sd">        in the number of half spaces.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        A helper to create non-normalized polygons for testing::</span>

<span class="sd">            sage: polygon = lambda *half_spaces: H.polygon(half_spaces, check=False, assume_sorted=False, assume_minimal=True)</span>

<span class="sd">        An intersection which is a single point on the boundary of the unit</span>
<span class="sd">        disk::</span>

<span class="sd">            sage: polygon(*H.infinity().half_spaces())._normalize_drop_euclidean_redundant(</span>
<span class="sd">            ....:     boundary=H.vertical(1).right_half_space())</span>
<span class="sd">            {x ≤ 0} ∩ {x - 1 ≥ 0}</span>

<span class="sd">        An intersection which is a segment outside of the unit disk::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.vertical(0).left_half_space(),</span>
<span class="sd">            ....:     H.vertical(0).right_half_space(),</span>
<span class="sd">            ....:     H.half_space(-2, -2, 1, model=&quot;klein&quot;),</span>
<span class="sd">            ....:     H.half_space(17/8, 2, -1, model=&quot;klein&quot;),</span>
<span class="sd">            ....: )._normalize_drop_euclidean_redundant(boundary=H.vertical(0).left_half_space())</span>
<span class="sd">            {(x^2 + y^2) + 4*x + 3 ≤ 0} ∩ {x ≤ 0} ∩ {9*(x^2 + y^2) + 32*x + 25 ≥ 0} ∩ {x ≥ 0}</span>

<span class="sd">        An intersection which is a polygon outside of the unit disk::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.half_space(0, 1, 0, model=&quot;klein&quot;),</span>
<span class="sd">            ....:     H.half_space(1, -2, 0, model=&quot;klein&quot;),</span>
<span class="sd">            ....:     H.half_space(-2, -2, 1, model=&quot;klein&quot;),</span>
<span class="sd">            ....:     H.half_space(17/8, 2, -1, model=&quot;klein&quot;),</span>
<span class="sd">            ....: )._normalize_drop_euclidean_redundant(boundary=H.half_space(17/8, 2, -1, model=&quot;klein&quot;))</span>
<span class="sd">            {(x^2 + y^2) + 4*x + 3 ≤ 0} ∩ {(x^2 + y^2) - 4*x + 1 ≥ 0} ∩ {9*(x^2 + y^2) + 32*x + 25 ≥ 0} ∩ {x ≥ 0}</span>

<span class="sd">        An intersection which is an (unbounded) polygon touching the unit disk::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.vertical(-1).left_half_space(),</span>
<span class="sd">            ....:     H.vertical(1).right_half_space(),</span>
<span class="sd">            ....: )._normalize_drop_euclidean_redundant(boundary=H.vertical(1).right_half_space())</span>
<span class="sd">            {x + 1 ≤ 0} ∩ {x - 1 ≥ 0}</span>

<span class="sd">        An intersection which is a segment touching the unit disk::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.vertical(0).left_half_space(),</span>
<span class="sd">            ....:     H.vertical(0).right_half_space(),</span>
<span class="sd">            ....:     H.vertical(-1).left_half_space(),</span>
<span class="sd">            ....:     H.geodesic(-1, -2).right_half_space(),</span>
<span class="sd">            ....: )._normalize_drop_euclidean_redundant(boundary=H.vertical(0).left_half_space())</span>
<span class="sd">            {x + 1 ≤ 0} ∩  {x ≤ 0} ∩ {(x^2 + y^2) + 3*x + 2 ≥ 0} ∩ {x ≥ 0}</span>

<span class="sd">        An intersection which is a polygon inside the unit disk::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.vertical(1).left_half_space(),</span>
<span class="sd">            ....:     H.vertical(-1).right_half_space(),</span>
<span class="sd">            ....:     H.geodesic(0, -1).right_half_space(),</span>
<span class="sd">            ....:     H.geodesic(0, 1).left_half_space(),</span>
<span class="sd">            ....: )._normalize_drop_euclidean_redundant(boundary=H.geodesic(0, 1).left_half_space())</span>
<span class="sd">            {(x^2 + y^2) - x ≥ 0} ∩ {x - 1 ≤ 0} ∩ {x + 1 ≥ 0} ∩ {(x^2 + y^2) + x ≥ 0}</span>

<span class="sd">        A polygon which has no vertices inside the unit disk but intersects the unit disk::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.geodesic(2, 3).left_half_space(),</span>
<span class="sd">            ....:     H.geodesic(-3, -2).left_half_space(),</span>
<span class="sd">            ....:     H.geodesic(-1/2, -1/3).left_half_space(),</span>
<span class="sd">            ....:     H.geodesic(1/3, 1/2).left_half_space(),</span>
<span class="sd">            ....: )._normalize_drop_euclidean_redundant(boundary=H.geodesic(1/3, 1/2).left_half_space())</span>
<span class="sd">            {6*(x^2 + y^2) - 5*x + 1 ≥ 0} ∩ {(x^2 + y^2) - 5*x + 6 ≥ 0} ∩ {(x^2 + y^2) + 5*x + 6 ≥ 0} ∩ {6*(x^2 + y^2) + 5*x + 1 ≥ 0}</span>

<span class="sd">        A single half plane::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.vertical(0).left_half_space()</span>
<span class="sd">            ....: )._normalize_drop_euclidean_redundant(boundary=H.vertical(0).left_half_space())</span>
<span class="sd">            {x ≤ 0}</span>

<span class="sd">        A pair of anti-parallel half planes::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.geodesic(1/2, 2).left_half_space(),</span>
<span class="sd">            ....:     H.geodesic(-1/2, -2).right_half_space(),</span>
<span class="sd">            ....: )._normalize_drop_euclidean_redundant(boundary=H.geodesic(-1/2, -2).right_half_space())</span>
<span class="sd">            {2*(x^2 + y^2) - 5*x + 2 ≥ 0} ∩ {2*(x^2 + y^2) + 5*x + 2 ≥ 0}</span>

<span class="sd">        A pair of anti-parallel half planes in the upper half plane::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.vertical(1).left_half_space(),</span>
<span class="sd">            ....:     H.vertical(-1).right_half_space(),</span>
<span class="sd">            ....: )._normalize_drop_euclidean_redundant(boundary=H.vertical(1).left_half_space())</span>
<span class="sd">            {x - 1 ≤ 0} ∩ {x + 1 ≥ 0}</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.vertical(1).left_half_space(),</span>
<span class="sd">            ....:     H.vertical(-1).right_half_space(),</span>
<span class="sd">            ....: )._normalize_drop_euclidean_redundant(boundary=H.vertical(-1).right_half_space())</span>
<span class="sd">            {x - 1 ≤ 0} ∩ {x + 1 ≥ 0}</span>

<span class="sd">        A segment in the unit disk with several superfluous half planes at infinity::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.vertical(0).left_half_space(),</span>
<span class="sd">            ....:     H.vertical(0).right_half_space(),</span>
<span class="sd">            ....:     H.vertical(1).left_half_space(),</span>
<span class="sd">            ....:     H.vertical(1/2).left_half_space(),</span>
<span class="sd">            ....:     H.vertical(1/3).left_half_space(),</span>
<span class="sd">            ....:     H.vertical(1/4).left_half_space(),</span>
<span class="sd">            ....:     H.vertical(-1).right_half_space(),</span>
<span class="sd">            ....:     H.vertical(-1/2).right_half_space(),</span>
<span class="sd">            ....:     H.vertical(-1/3).right_half_space(),</span>
<span class="sd">            ....:     H.vertical(-1/4).right_half_space(),</span>
<span class="sd">            ....: )._normalize_drop_euclidean_redundant(boundary=H.vertical(0).left_half_space())</span>
<span class="sd">            {x ≤ 0} ∩ {4*x + 1 ≥ 0} ∩ {x ≥ 0}</span>

<span class="sd">        A polygon in the unit disk with several superfluous half planes::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.vertical(1).left_half_space(),</span>
<span class="sd">            ....:     H.vertical(-1).right_half_space(),</span>
<span class="sd">            ....:     H.geodesic(0, 1).left_half_space(),</span>
<span class="sd">            ....:     H.geodesic(0, -1).right_half_space(),</span>
<span class="sd">            ....:     H.vertical(2).left_half_space(),</span>
<span class="sd">            ....:     H.vertical(-2).right_half_space(),</span>
<span class="sd">            ....:     H.geodesic(0, 1/2).left_half_space(),</span>
<span class="sd">            ....:     H.geodesic(0, -1/2).right_half_space(),</span>
<span class="sd">            ....:     H.vertical(3).left_half_space(),</span>
<span class="sd">            ....:     H.vertical(-3).right_half_space(),</span>
<span class="sd">            ....:     H.geodesic(0, 1/3).left_half_space(),</span>
<span class="sd">            ....:     H.geodesic(0, -1/3).right_half_space(),</span>
<span class="sd">            ....: )._normalize_drop_euclidean_redundant(boundary=H.vertical(1).left_half_space())</span>
<span class="sd">            {(x^2 + y^2) - x ≥ 0} ∩ {x - 1 ≤ 0} ∩ {x + 1 ≥ 0} ∩ {(x^2 + y^2) + x ≥ 0}</span>

<span class="sd">        TESTS:</span>

<span class="sd">        An example that caused trouble at some point::</span>

<span class="sd">            sage: P = polygon(</span>
<span class="sd">            ....:   H.geodesic(7, -4, -3, model=&quot;half_plane&quot;).left_half_space(),</span>
<span class="sd">            ....:   H.geodesic(1, -1, 0, model=&quot;half_plane&quot;).left_half_space(),</span>
<span class="sd">            ....:   H.vertical(1/2).right_half_space(),</span>
<span class="sd">            ....:   H.vertical(1).right_half_space(),</span>
<span class="sd">            ....:   H.geodesic(1, 4, -5, model=&quot;half_plane&quot;).left_half_space(),</span>
<span class="sd">            ....:   H.geodesic(50, 57, -43, model=&quot;half_plane&quot;).left_half_space(),</span>
<span class="sd">            ....:   H.geodesic(3, 2, -3, model=&quot;half_plane&quot;).left_half_space()</span>
<span class="sd">            ....: )</span>
<span class="sd">            sage: P._normalize_drop_euclidean_redundant(boundary=P._normalize_euclidean_boundary())</span>
<span class="sd">            {(x^2 + y^2) - x ≥ 0} ∩ {2*x - 1 ≥ 0} ∩ {x - 1 ≥ 0}</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            There are some additional assumptions on the input than what is</span>
<span class="sd">            stated here. Please refer to the implementation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">half_spaces</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_half_spaces</span><span class="p">)</span>

        <span class="n">half_spaces</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">half_spaces</span><span class="p">[</span><span class="n">half_spaces</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">boundary</span><span class="p">)</span> <span class="p">:]</span>
            <span class="o">+</span> <span class="n">half_spaces</span><span class="p">[:</span> <span class="n">half_spaces</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">boundary</span><span class="p">)]</span>
        <span class="p">)</span>
        <span class="n">half_spaces</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

        <span class="n">required_half_spaces</span> <span class="o">=</span> <span class="p">[</span><span class="n">half_spaces</span><span class="o">.</span><span class="n">pop</span><span class="p">()]</span>

        <span class="k">while</span> <span class="n">half_spaces</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">required_half_spaces</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">half_spaces</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">half_spaces</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">half_spaces</span> <span class="k">else</span> <span class="n">required_half_spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Determine whether B is redundant, i.e., whether the intersection</span>
            <span class="c1"># A, B, C and A, C are the same.</span>
            <span class="c1"># Since we know that A is required and the space non-empty, the</span>
            <span class="c1"># question here is whether C blocks the line of sight from A to B.</span>

            <span class="c1"># We distinguish cases, depending of the nature of the intersection of A and B.</span>
            <span class="n">AB</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">boundary</span><span class="p">()</span><span class="o">.</span><span class="n">_configuration</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">boundary</span><span class="p">())</span>
            <span class="n">BC</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">boundary</span><span class="p">()</span><span class="o">.</span><span class="n">_configuration</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">boundary</span><span class="p">())</span>
            <span class="n">AC</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">boundary</span><span class="p">()</span><span class="o">.</span><span class="n">_configuration</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">boundary</span><span class="p">())</span>

            <span class="n">required</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">AB</span> <span class="o">==</span> <span class="s2">&quot;convex&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">BC</span> <span class="o">==</span> <span class="s2">&quot;concave&quot;</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">AC</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;equal&quot;</span><span class="p">,</span> <span class="s2">&quot;concave&quot;</span><span class="p">]</span>
                    <span class="n">required</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">elif</span> <span class="n">BC</span> <span class="o">==</span> <span class="s2">&quot;convex&quot;</span><span class="p">:</span>
                    <span class="n">BC</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">boundary</span><span class="p">()</span><span class="o">.</span><span class="n">_intersection</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">boundary</span><span class="p">())</span>
                    <span class="n">required</span> <span class="o">=</span> <span class="n">AC</span> <span class="o">==</span> <span class="s2">&quot;negative&quot;</span> <span class="ow">or</span> <span class="p">(</span><span class="n">BC</span> <span class="ow">in</span> <span class="n">A</span> <span class="ow">and</span> <span class="n">BC</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">A</span><span class="o">.</span><span class="n">boundary</span><span class="p">())</span>

                <span class="k">elif</span> <span class="n">BC</span> <span class="o">==</span> <span class="s2">&quot;negative&quot;</span><span class="p">:</span>
                    <span class="n">required</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">elif</span> <span class="n">BC</span> <span class="o">==</span> <span class="s2">&quot;anti-parallel&quot;</span><span class="p">:</span>
                    <span class="n">required</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;B and C are in unsupported configuration: </span><span class="si">{</span><span class="n">BC</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

            <span class="k">elif</span> <span class="n">AB</span> <span class="o">==</span> <span class="s2">&quot;negative&quot;</span><span class="p">:</span>
                <span class="n">required</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">elif</span> <span class="n">AB</span> <span class="o">==</span> <span class="s2">&quot;anti-parallel&quot;</span><span class="p">:</span>
                <span class="n">required</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">elif</span> <span class="n">AB</span> <span class="o">==</span> <span class="s2">&quot;concave&quot;</span><span class="p">:</span>
                <span class="n">required</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;A and B are in unsupported configuration: </span><span class="si">{</span><span class="n">AB</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">required</span><span class="p">:</span>
                <span class="n">required_half_spaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">required_half_spaces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">half_spaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">required_half_spaces</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>

        <span class="n">required_half_spaces</span> <span class="o">=</span> <span class="n">HyperbolicHalfSpaces</span><span class="p">(</span>
            <span class="n">required_half_spaces</span><span class="p">,</span> <span class="n">assume_sorted</span><span class="o">=</span><span class="s2">&quot;rotated&quot;</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span>
            <span class="n">required_half_spaces</span><span class="p">,</span>
            <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">assume_minimal</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">marked_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicConvexPolygon._normalize_drop_unit_disk_redundant"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexPolygon._normalize_drop_unit_disk_redundant">[docs]</a>    <span class="k">def</span> <span class="nf">_normalize_drop_unit_disk_redundant</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the intersection of the Euclidean ``half_spaces`` defining this</span>
<span class="sd">        polygon with the unit disk.</span>

<span class="sd">        The ``half_spaces`` must be minimal to describe their intersection in</span>
<span class="sd">        the Euclidean plane. If that intersection does not intersect the unit</span>
<span class="sd">        disk, then return the :meth:`HyperbolicPlane.empty_set`.</span>

<span class="sd">        Otherwise, return a minimal sublist of ``half_spaces`` that describes</span>
<span class="sd">        the intersection inside the unit disk.</span>

<span class="sd">        This is a helper method for :meth:`_normalize`.</span>

<span class="sd">        ALGORITHM:</span>

<span class="sd">        When passing to the Klein model, i.e., intersecting the polygon with the</span>
<span class="sd">        unit disk, some of the edges of the (possibly unbounded) polygon</span>
<span class="sd">        described by the ``half_spaces`` are unnecessary because they are not</span>
<span class="sd">        intersecting the unit disk.</span>

<span class="sd">        If none of the edges intersect the unit disk, then the polygon has</span>
<span class="sd">        empty intersection with the unit disk.</span>

<span class="sd">        Otherwise, we can drop the half spaces describing the edges that do not</span>
<span class="sd">        intersect the unit disk.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        A helper to create non-normalized polygons for testing::</span>

<span class="sd">            sage: polygon = lambda *half_spaces: H.polygon(half_spaces, check=False, assume_sorted=False, assume_minimal=True)</span>

<span class="sd">        An intersection which is a single point on the boundary of the unit</span>
<span class="sd">        disk::</span>

<span class="sd">            sage: polygon(*H.infinity().half_spaces())._normalize_drop_unit_disk_redundant()</span>
<span class="sd">            ∞</span>

<span class="sd">        An intersection which is a segment outside of the unit disk::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.vertical(0).left_half_space(),</span>
<span class="sd">            ....:     H.vertical(0).right_half_space(),</span>
<span class="sd">            ....:     H.half_space(-2, -2, 1, model=&quot;klein&quot;),</span>
<span class="sd">            ....:     H.half_space(17/8, 2, -1, model=&quot;klein&quot;),</span>
<span class="sd">            ....: )._normalize_drop_unit_disk_redundant()</span>
<span class="sd">            {}</span>

<span class="sd">        An intersection which is a polygon outside of the unit disk::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.half_space(0, 1, 0, model=&quot;klein&quot;),</span>
<span class="sd">            ....:     H.half_space(1, -2, 0, model=&quot;klein&quot;),</span>
<span class="sd">            ....:     H.half_space(-2, -2, 1, model=&quot;klein&quot;),</span>
<span class="sd">            ....:     H.half_space(17/8, 2, -1, model=&quot;klein&quot;),</span>
<span class="sd">            ....: )._normalize_drop_unit_disk_redundant()</span>
<span class="sd">            {}</span>

<span class="sd">        An intersection which is an (unbounded) polygon touching the unit disk::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.vertical(-1).left_half_space(),</span>
<span class="sd">            ....:     H.vertical(1).right_half_space())._normalize_drop_unit_disk_redundant()</span>
<span class="sd">            ∞</span>

<span class="sd">        An intersection which is a segment touching the unit disk::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.vertical(0).left_half_space(),</span>
<span class="sd">            ....:     H.vertical(0).right_half_space(),</span>
<span class="sd">            ....:     H.vertical(-1).left_half_space(),</span>
<span class="sd">            ....:     H.geodesic(-1, -2).right_half_space())._normalize_drop_unit_disk_redundant()</span>
<span class="sd">            ∞</span>

<span class="sd">        An intersection which is a polygon inside the unit disk::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.vertical(1).left_half_space(),</span>
<span class="sd">            ....:     H.vertical(-1).right_half_space(),</span>
<span class="sd">            ....:     H.geodesic(0, -1).right_half_space(),</span>
<span class="sd">            ....:     H.geodesic(0, 1).left_half_space())._normalize_drop_unit_disk_redundant()</span>
<span class="sd">            {(x^2 + y^2) - x ≥ 0} ∩ {x - 1 ≤ 0} ∩ {x + 1 ≥ 0} ∩ {(x^2 + y^2) + x ≥ 0}</span>

<span class="sd">        A polygon which has no vertices inside the unit disk but intersects the unit disk::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.geodesic(2, 3).left_half_space(),</span>
<span class="sd">            ....:     H.geodesic(-3, -2).left_half_space(),</span>
<span class="sd">            ....:     H.geodesic(-1/2, -1/3).left_half_space(),</span>
<span class="sd">            ....:     H.geodesic(1/3, 1/2).left_half_space())._normalize_drop_unit_disk_redundant()</span>
<span class="sd">            {6*(x^2 + y^2) - 5*x + 1 ≥ 0} ∩ {(x^2 + y^2) - 5*x + 6 ≥ 0} ∩ {(x^2 + y^2) + 5*x + 6 ≥ 0} ∩ {6*(x^2 + y^2) + 5*x + 1 ≥ 0}</span>

<span class="sd">        A single half plane::</span>

<span class="sd">            sage: polygon(H.vertical(0).left_half_space())._normalize_drop_unit_disk_redundant()</span>
<span class="sd">            {x ≤ 0}</span>

<span class="sd">        A pair of anti-parallel half planes::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.geodesic(1/2, 2).left_half_space(),</span>
<span class="sd">            ....:     H.geodesic(-1/2, -2).right_half_space())._normalize_drop_unit_disk_redundant()</span>
<span class="sd">            {2*(x^2 + y^2) - 5*x + 2 ≥ 0} ∩ {2*(x^2 + y^2) + 5*x + 2 ≥ 0}</span>

<span class="sd">        A segment in the unit disk with a superfluous half plane at infinity::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.vertical(0).left_half_space(),</span>
<span class="sd">            ....:     H.vertical(0).right_half_space(),</span>
<span class="sd">            ....:     H.vertical(1).left_half_space())._normalize_drop_unit_disk_redundant()</span>
<span class="sd">            {x = 0}</span>

<span class="sd">        A polygon in the unit disk with several superfluous half planes::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.vertical(1).left_half_space(),</span>
<span class="sd">            ....:     H.vertical(-1).right_half_space(),</span>
<span class="sd">            ....:     H.geodesic(0, 1).left_half_space(),</span>
<span class="sd">            ....:     H.geodesic(0, -1).right_half_space(),</span>
<span class="sd">            ....:     H.vertical(2).left_half_space(),</span>
<span class="sd">            ....:     H.geodesic(0, 1/2).left_half_space())._normalize_drop_unit_disk_redundant()</span>
<span class="sd">            {(x^2 + y^2) - x ≥ 0} ∩ {x - 1 ≤ 0} ∩ {x + 1 ≥ 0} ∩ {(x^2 + y^2) + x ≥ 0}</span>

<span class="sd">        A segment touching the inside of the unit disk::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:   H.vertical(1).left_half_space(),</span>
<span class="sd">            ....:   H.half_circle(0, 2).left_half_space(),</span>
<span class="sd">            ....:   H.vertical(0).left_half_space(),</span>
<span class="sd">            ....:   H.vertical(0).right_half_space(),</span>
<span class="sd">            ....: )._normalize_drop_unit_disk_redundant()</span>
<span class="sd">            {x = 0} ∩ {(x^2 + y^2) - 2 ≥ 0}</span>

<span class="sd">        An unbounded polygon touching the unit disk from the inside::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.vertical(1).left_half_space(),</span>
<span class="sd">            ....:     H.vertical(-1).right_half_space(),</span>
<span class="sd">            ....: )._normalize_drop_unit_disk_redundant()</span>
<span class="sd">            {x - 1 ≤ 0} ∩ {x + 1 ≥ 0}</span>

<span class="sd">        A segment inside the unit disk::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.vertical(0).right_half_space(),</span>
<span class="sd">            ....:     H.vertical(0).left_half_space(),</span>
<span class="sd">            ....:     H.geodesic(-2, 2).right_half_space(),</span>
<span class="sd">            ....:     H.geodesic(-1/2, 1/2).left_half_space(),</span>
<span class="sd">            ....: )._normalize_drop_unit_disk_redundant()</span>
<span class="sd">            {x = 0} ∩ {(x^2 + y^2) - 4 ≤ 0} ∩ {4*(x^2 + y^2) - 1 ≥ 0}</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            There are some additional assumptions on the input than what is</span>
<span class="sd">            stated here. Please refer to the implementation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">required_half_spaces</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">maybe_empty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">maybe_point</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">maybe_segment</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_half_spaces</span><span class="o">.</span><span class="n">triples</span><span class="p">(</span><span class="n">repeat</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">AB</span> <span class="o">=</span> <span class="p">(</span>
                <span class="kc">None</span>
                <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">boundary</span><span class="p">()</span><span class="o">.</span><span class="n">_configuration</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">boundary</span><span class="p">())</span> <span class="o">==</span> <span class="s2">&quot;concave&quot;</span>
                <span class="k">else</span> <span class="n">A</span><span class="o">.</span><span class="n">boundary</span><span class="p">()</span><span class="o">.</span><span class="n">_intersection</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">boundary</span><span class="p">())</span>
            <span class="p">)</span>
            <span class="n">BC</span> <span class="o">=</span> <span class="p">(</span>
                <span class="kc">None</span>
                <span class="k">if</span> <span class="n">B</span><span class="o">.</span><span class="n">boundary</span><span class="p">()</span><span class="o">.</span><span class="n">_configuration</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">boundary</span><span class="p">())</span> <span class="o">==</span> <span class="s2">&quot;concave&quot;</span>
                <span class="k">else</span> <span class="n">B</span><span class="o">.</span><span class="n">boundary</span><span class="p">()</span><span class="o">.</span><span class="n">_intersection</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">boundary</span><span class="p">())</span>
            <span class="p">)</span>

            <span class="n">segment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">boundary</span><span class="p">(),</span> <span class="n">AB</span><span class="p">,</span> <span class="n">BC</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="n">HyperbolicEmptySet</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="n">HyperbolicPoint</span><span class="p">):</span>
                <span class="n">maybe_empty</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">maybe_point</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">maybe_point</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">maybe_point</span> <span class="o">=</span> <span class="n">segment</span>
                <span class="k">elif</span> <span class="n">maybe_point</span> <span class="o">!=</span> <span class="n">segment</span><span class="p">:</span>
                    <span class="c1"># Unsurprisingly, pylint gets confused by maybe_point being</span>
                    <span class="c1"># both a boolean and a point at times. The code should</span>
                    <span class="c1"># probably be cleaned up. But here, it must be a point so</span>
                    <span class="c1"># the call is save.</span>
                    <span class="c1"># pylint: disable=no-member</span>
                    <span class="k">assert</span> <span class="ow">not</span> <span class="n">maybe_point</span><span class="o">.</span><span class="n">is_finite</span><span class="p">()</span>
                    <span class="c1"># pylint: enable=no-member</span>
                    <span class="k">assert</span> <span class="ow">not</span> <span class="n">segment</span><span class="o">.</span><span class="n">is_finite</span><span class="p">()</span>

                    <span class="n">maybe_point</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">maybe_empty</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">maybe_point</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="k">if</span> <span class="n">maybe_segment</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">maybe_segment</span> <span class="o">=</span> <span class="n">segment</span>
                <span class="k">elif</span> <span class="n">maybe_segment</span> <span class="o">==</span> <span class="o">-</span><span class="n">segment</span><span class="p">:</span>
                    <span class="c1"># For the intersection to be only segment, we must see the</span>
                    <span class="c1"># segment twice, once from both sides.</span>
                    <span class="k">return</span> <span class="n">segment</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">maybe_segment</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="n">required_half_spaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">maybe_empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">empty_set</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">maybe_point</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">maybe_point</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">required_half_spaces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;there is no convex set to represent the full space yet&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">required_half_spaces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">required_half_spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span>
            <span class="n">required_half_spaces</span><span class="p">,</span>
            <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">assume_minimal</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">marked_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicConvexPolygon._normalize_euclidean_boundary"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexPolygon._normalize_euclidean_boundary">[docs]</a>    <span class="k">def</span> <span class="nf">_normalize_euclidean_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a half space whose (Euclidean) boundary intersects the boundary</span>
<span class="sd">        of the intersection of the ``half_spaces`` defining this polygon in</span>
<span class="sd">        more than a point.</span>

<span class="sd">        Consider the half spaces in the Klein model. Ignoring the unit disk,</span>
<span class="sd">        they also describe half spaces in the Euclidean plane.</span>

<span class="sd">        If their intersection contains a segment it must be on the boundary of</span>
<span class="sd">        one of the ``half_spaces`` which is returned by this method.</span>

<span class="sd">        If this is not the case, and the intersection is empty in the</span>
<span class="sd">        hyperbolic plane, return the :meth:`HyperbolicPlane.empty_set`.</span>
<span class="sd">        Otherwise, if the intersection is a point in the hyperbolic plane,</span>
<span class="sd">        return that point.</span>

<span class="sd">        The ``half_spaces`` must already be sorted with respect to</span>
<span class="sd">        :meth:`HyperbolicHalfSpaces._lt_`.</span>

<span class="sd">        This is a helper method for :meth:`_normalize`.</span>

<span class="sd">        ALGORITHM:</span>

<span class="sd">        We initially ignore the hyperbolic structure and just consider the half</span>
<span class="sd">        spaces of the Klein model as Euclidean half spaces.</span>

<span class="sd">        We use a relatively standard randomized optimization approach to find a</span>
<span class="sd">        point in the intersection: we randomly shuffle the half spaces and then</span>
<span class="sd">        optimize a segment on some boundary of the half spaces. The</span>
<span class="sd">        randomization makes this a linear time algorithm, see e.g.,</span>
<span class="sd">        https://www2.cs.arizona.edu/classes/cs437/fall07/Lecture4.prn.pdf</span>

<span class="sd">        If the only segment we can construct is a point, then the intersection</span>
<span class="sd">        is a single point in the Euclidean plane. The intersection in the</span>
<span class="sd">        hyperbolic plane might be a single point or empty.</span>

<span class="sd">        If not even a point exists, the intersection is empty in the Euclidean</span>
<span class="sd">        plane and therefore empty in the hyperbolic plane.</span>

<span class="sd">        Note that the segment returned might not be within the unit disk.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        A helper to create non-normalized polygons for testing::</span>

<span class="sd">            sage: polygon = lambda *half_spaces: H.polygon(half_spaces, check=False, assume_sorted=False, assume_minimal=True)</span>

<span class="sd">        Make the following randomized tests reproducible::</span>

<span class="sd">            sage: set_random_seed(0)</span>

<span class="sd">        An intersection that is already empty in the Euclidean plane::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.geodesic(2, 1/2).left_half_space(),</span>
<span class="sd">            ....:     H.geodesic(-1/2, -2).left_half_space()</span>
<span class="sd">            ....: )._normalize_euclidean_boundary()</span>
<span class="sd">            {}</span>

<span class="sd">        An intersection which in the Euclidean plane is a single point but</span>
<span class="sd">        outside the unit disk::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.half_space(0, 1, 0, model=&quot;klein&quot;),</span>
<span class="sd">            ....:     H.half_space(0, -1, 0, model=&quot;klein&quot;),</span>
<span class="sd">            ....:     H.half_space(2, 2, -1, model=&quot;klein&quot;),</span>
<span class="sd">            ....:     H.half_space(-2, -2, 1, model=&quot;klein&quot;),</span>
<span class="sd">            ....: )._normalize_euclidean_boundary()</span>
<span class="sd">            {}</span>

<span class="sd">        An intersection which is a single point inside the unit disk::</span>

<span class="sd">            sage: polygon(*H(I).half_spaces())._normalize_euclidean_boundary()</span>
<span class="sd">            I</span>

<span class="sd">        An intersection which is a single point on the boundary of the unit</span>
<span class="sd">        disk::</span>

<span class="sd">            sage: polygon(*H.infinity().half_spaces())._normalize_euclidean_boundary()</span>
<span class="sd">            {x - 1 ≥ 0}</span>

<span class="sd">        An intersection which is a segment outside of the unit disk::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.vertical(0).left_half_space(),</span>
<span class="sd">            ....:     H.vertical(0).right_half_space(),</span>
<span class="sd">            ....:     H.half_space(-2, -2, 1, model=&quot;klein&quot;),</span>
<span class="sd">            ....:     H.half_space(17/8, 2, -1, model=&quot;klein&quot;),</span>
<span class="sd">            ....: )._normalize_euclidean_boundary()</span>
<span class="sd">            {x ≤ 0}</span>

<span class="sd">        An intersection which is a polygon outside of the unit disk::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.half_space(0, 1, 0, model=&quot;klein&quot;),</span>
<span class="sd">            ....:     H.half_space(1, -2, 0, model=&quot;klein&quot;),</span>
<span class="sd">            ....:     H.half_space(-2, -2, 1, model=&quot;klein&quot;),</span>
<span class="sd">            ....:     H.half_space(17/8, 2, -1, model=&quot;klein&quot;),</span>
<span class="sd">            ....: )._normalize_euclidean_boundary()</span>
<span class="sd">            {9*(x^2 + y^2) + 32*x + 25 ≥ 0}</span>

<span class="sd">        An intersection which is an (unbounded) polygon touching the unit disk::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.vertical(-1).left_half_space(),</span>
<span class="sd">            ....:     H.vertical(1).right_half_space(),</span>
<span class="sd">            ....: )._normalize_euclidean_boundary()</span>
<span class="sd">            {x - 1 ≥ 0}</span>

<span class="sd">        An intersection which is a segment touching the unit disk::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.vertical(0).left_half_space(),</span>
<span class="sd">            ....:     H.vertical(0).right_half_space(),</span>
<span class="sd">            ....:     H.vertical(-1).left_half_space(),</span>
<span class="sd">            ....:     H.geodesic(-1, -2).right_half_space(),</span>
<span class="sd">            ....: )._normalize_euclidean_boundary()</span>
<span class="sd">            {x ≥ 0}</span>

<span class="sd">        An intersection which is a polygon inside the unit disk::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.vertical(1).left_half_space(),</span>
<span class="sd">            ....:     H.vertical(-1).right_half_space(),</span>
<span class="sd">            ....:     H.geodesic(0, -1).right_half_space(),</span>
<span class="sd">            ....:     H.geodesic(0, 1).left_half_space(),</span>
<span class="sd">            ....: )._normalize_euclidean_boundary()</span>
<span class="sd">            {(x^2 + y^2) - x ≥ 0}</span>

<span class="sd">        A polygon which has no vertices inside the unit disk but intersects the unit disk::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.geodesic(2, 3).left_half_space(),</span>
<span class="sd">            ....:     H.geodesic(-3, -2).left_half_space(),</span>
<span class="sd">            ....:     H.geodesic(-1/2, -1/3).left_half_space(),</span>
<span class="sd">            ....:     H.geodesic(1/3, 1/2).left_half_space(),</span>
<span class="sd">            ....: )._normalize_euclidean_boundary()</span>
<span class="sd">            {6*(x^2 + y^2) - 5*x + 1 ≥ 0}</span>

<span class="sd">        A single half plane::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.vertical(0).left_half_space()</span>
<span class="sd">            ....: )._normalize_euclidean_boundary()</span>
<span class="sd">            {x ≤ 0}</span>

<span class="sd">        A pair of anti-parallel half planes::</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:     H.geodesic(1/2, 2).left_half_space(),</span>
<span class="sd">            ....:     H.geodesic(-1/2, -2).right_half_space(),</span>
<span class="sd">            ....: )._normalize_euclidean_boundary()</span>
<span class="sd">            {2*(x^2 + y^2) - 5*x + 2 ≥ 0}</span>

<span class="sd">        TESTS:</span>

<span class="sd">        A case that caused problems at some point::</span>

<span class="sd">            sage: set_random_seed(1)</span>

<span class="sd">            sage: polygon(</span>
<span class="sd">            ....:    H.geodesic(300, 3389, -1166, model=&quot;half_plane&quot;).right_half_space(),</span>
<span class="sd">            ....:    H.geodesic(5, -24, -5, model=&quot;half_plane&quot;).left_half_space(),</span>
<span class="sd">            ....:    H.geodesic(182, -1135, 522, model=&quot;half_plane&quot;).left_half_space(),</span>
<span class="sd">            ....: )._normalize_euclidean_boundary()</span>
<span class="sd">            {5*(x^2 + y^2) - 24*x - 5 ≥ 0}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_half_spaces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;list of half spaces must not be empty&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_half_spaces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_half_spaces</span><span class="p">))</span>

        <span class="c1"># Randomly shuffle the half spaces so the loop below runs in expected linear time.</span>
        <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">shuffle</span>

        <span class="n">random_half_spaces</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_half_spaces</span><span class="p">)</span>
        <span class="n">shuffle</span><span class="p">(</span><span class="n">random_half_spaces</span><span class="p">)</span>

        <span class="c1"># Move from the random starting point to a point that is contained in all half spaces.</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">random_half_spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">boundary</span><span class="p">()</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">half_space</span> <span class="ow">in</span> <span class="n">random_half_spaces</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">half_space</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># The point is not in this half space. Find a point on the</span>
                <span class="c1"># boundary of half_space that is contained in all the half</span>
                <span class="c1"># spaces we have seen so far.</span>
                <span class="n">boundary</span> <span class="o">=</span> <span class="n">half_space</span><span class="o">.</span><span class="n">boundary</span><span class="p">()</span>

                <span class="c1"># We parametrize the boundary points of half space, i.e., the</span>
                <span class="c1"># points that satisfy a + bx + cy = 0 by picking a base point B</span>
                <span class="c1"># and then writing points as (x, y) = B + λ(c, -b).</span>

                <span class="c1"># Each half space constrains the possible values of λ, starting</span>
                <span class="c1"># from (-∞,∞) to a smaller closed interval.</span>
                <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">RealSet</span><span class="p">,</span> <span class="n">oo</span>

                <span class="c1"># Note that RealSet.real_line() would require SageMath 9.4</span>
                <span class="n">interval</span> <span class="o">=</span> <span class="n">RealSet</span><span class="p">(</span><span class="o">-</span><span class="n">oo</span><span class="p">,</span> <span class="n">oo</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">constraining</span> <span class="ow">in</span> <span class="n">random_half_spaces</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">constraining</span> <span class="ow">is</span> <span class="n">half_space</span><span class="p">:</span>
                        <span class="k">break</span>

                    <span class="n">intersection</span> <span class="o">=</span> <span class="n">boundary</span><span class="o">.</span><span class="n">_intersection</span><span class="p">(</span><span class="n">constraining</span><span class="o">.</span><span class="n">boundary</span><span class="p">())</span>

                    <span class="k">if</span> <span class="n">intersection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># constraining is anti-parallel to half_space</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">boundary</span><span class="o">.</span><span class="n">unparametrize</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                            <span class="ow">not</span> <span class="ow">in</span> <span class="n">constraining</span>
                        <span class="p">):</span>
                            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">empty_set</span><span class="p">()</span>

                        <span class="c1"># The intersection is non-empty, so this adds no further constraints.</span>
                        <span class="k">continue</span>

                    <span class="n">λ</span> <span class="o">=</span> <span class="n">boundary</span><span class="o">.</span><span class="n">parametrize</span><span class="p">(</span>
                        <span class="n">intersection</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span>
                    <span class="p">)</span>

                    <span class="c1"># RealSet in SageMath does not like number fields. We move</span>
                    <span class="c1"># everything through AA (which might not always work) to</span>
                    <span class="c1"># work around this problem.</span>
                    <span class="k">if</span> <span class="n">λ</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">is_exact</span><span class="p">():</span>
                        <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">AA</span>

                        <span class="n">rλ</span> <span class="o">=</span> <span class="n">AA</span><span class="p">(</span><span class="n">λ</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">rλ</span> <span class="o">=</span> <span class="n">λ</span>

                    <span class="c1"># Determine whether this half space constrains to (-∞, λ] or [λ, ∞).</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">boundary</span><span class="o">.</span><span class="n">unparametrize</span><span class="p">(</span><span class="n">λ</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                        <span class="ow">in</span> <span class="n">constraining</span>
                    <span class="p">):</span>
                        <span class="n">constraint</span> <span class="o">=</span> <span class="n">RealSet</span><span class="o">.</span><span class="n">unbounded_above_closed</span><span class="p">(</span><span class="n">rλ</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">constraint</span> <span class="o">=</span> <span class="n">RealSet</span><span class="o">.</span><span class="n">unbounded_below_closed</span><span class="p">(</span><span class="n">rλ</span><span class="p">)</span>

                    <span class="n">interval</span> <span class="o">=</span> <span class="n">interval</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">interval</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
                        <span class="c1"># The constraints leave no possibility for λ.</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">empty_set</span><span class="p">()</span>

                <span class="c1"># Construct a point from any of the λ in interval.</span>
                <span class="n">λ</span> <span class="o">=</span> <span class="n">interval</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>

                <span class="n">point</span> <span class="o">=</span> <span class="n">boundary</span><span class="o">.</span><span class="n">unparametrize</span><span class="p">(</span><span class="n">λ</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_extend_to_euclidean_boundary</span><span class="p">(</span><span class="n">point</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_normalize_extend_to_euclidean_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extend ``point`` to a (Euclidean) half space which intersects the</span>
<span class="sd">        intersection of the ``half_spaces`` defining this polygon in more than</span>
<span class="sd">        one point.</span>

<span class="sd">        This is a helper method for :meth:`_normalize_euclidean_boundary`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        A helper to create non-normalized polygons for testing::</span>

<span class="sd">            sage: polygon = lambda *half_spaces: H.polygon(half_spaces, check=False, assume_sorted=False, assume_minimal=True)</span>

<span class="sd">        We extend from a single point to half space::</span>

<span class="sd">            sage: P = polygon(*H.infinity().half_spaces())</span>

<span class="sd">            sage: P._normalize_extend_to_euclidean_boundary(H.infinity())</span>
<span class="sd">            {x ≤ 0}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">half_spaces</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">half_space</span>
            <span class="k">for</span> <span class="n">half_space</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_half_spaces</span>
            <span class="k">if</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">half_space</span><span class="o">.</span><span class="n">boundary</span><span class="p">()</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">half_spaces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;point must be on the boundary of a defining half space&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">half_spaces</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">half_spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">half_space</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">half_spaces</span><span class="p">):</span>
            <span class="n">following</span> <span class="o">=</span> <span class="n">half_spaces</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">half_spaces</span><span class="p">)]</span>
            <span class="n">configuration</span> <span class="o">=</span> <span class="n">half_space</span><span class="o">.</span><span class="n">boundary</span><span class="p">()</span><span class="o">.</span><span class="n">_configuration</span><span class="p">(</span><span class="n">following</span><span class="o">.</span><span class="n">boundary</span><span class="p">())</span>

            <span class="k">if</span> <span class="n">configuration</span> <span class="o">==</span> <span class="s2">&quot;convex&quot;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">configuration</span> <span class="o">==</span> <span class="s2">&quot;negative&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">half_space</span>

            <span class="k">if</span> <span class="n">configuration</span> <span class="o">==</span> <span class="s2">&quot;concave&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">half_space</span>

            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;cannot extend point to segment when half spaces are in configuration </span><span class="si">{</span><span class="n">configuration</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">point</span><span class="o">.</span><span class="n">is_ultra_ideal</span><span class="p">():</span>
            <span class="c1"># There is no actual intersection in the hyperbolic plane.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">empty_set</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">point</span>

    <span class="k">def</span> <span class="nf">_normalize_drop_marked_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of this polygon with marked vertices removed that are</span>
<span class="sd">        already vertices of the polygon anyway.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: P = H.polygon([</span>
<span class="sd">            ....:     H.vertical(0).right_half_space(),</span>
<span class="sd">            ....:     H.vertical(1).left_half_space(),</span>
<span class="sd">            ....:     H.half_circle(0, 2).left_half_space()],</span>
<span class="sd">            ....:     marked_vertices=[oo], assume_minimal=True, check=False)</span>
<span class="sd">            sage: P</span>
<span class="sd">            {x - 1 ≤ 0} ∩ {x ≥ 0} ∩ {(x^2 + y^2) - 2 ≥ 0} ∪ {∞}</span>

<span class="sd">            sage: P._normalize_drop_marked_vertices()</span>
<span class="sd">            {x - 1 ≤ 0} ∩ {x ≥ 0} ∩ {(x^2 + y^2) - 2 ≥ 0}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">vertex</span>
            <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_marked_vertices</span>
            <span class="k">if</span> <span class="n">vertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">(</span><span class="n">marked_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_half_spaces</span><span class="p">,</span>
            <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">assume_minimal</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">marked_vertices</span><span class="o">=</span><span class="n">vertices</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="HyperbolicConvexPolygon.dimension"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexPolygon.dimension">[docs]</a>    <span class="k">def</span> <span class="nf">dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the dimension of this polygon, i.e., 2.</span>

<span class="sd">        This implements :meth:`HyperbolicConvexSet.dimension`.</span>

<span class="sd">        Note that this also returns 2 if the actual dimension of the polygon is</span>
<span class="sd">        smaller. This is, however, only possible for polygons created with</span>
<span class="sd">        :meth:`HyperbolicPlane.polygon` setting ``check=False``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: P = H.polygon([</span>
<span class="sd">            ....:     H.vertical(-1).right_half_space(),</span>
<span class="sd">            ....:     H.vertical(1).left_half_space(),</span>
<span class="sd">            ....:     H.half_circle(0, 1).left_half_space(),</span>
<span class="sd">            ....:     H.half_circle(0, 4).right_half_space(),</span>
<span class="sd">            ....: ])</span>
<span class="sd">            sage: P.dimension()</span>
<span class="sd">            2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">ZZ</span>

        <span class="k">return</span> <span class="n">ZZ</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicConvexPolygon.edges"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexPolygon.edges">[docs]</a>    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">as_segments</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">marked_vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the :class:`segments &lt;HyperbolicOrientedSegment&gt;` and</span>
<span class="sd">        :class:`geodesics &lt;HyperbolicOrientedGeodesic&gt;` defining this polygon.</span>

<span class="sd">        This implements :meth:`HyperbolicConvexSet.edges` for polygons.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``as_segments`` -- a boolean (default: ``False``); whether to also</span>
<span class="sd">          return the geodesics as segments with ideal end points.</span>

<span class="sd">        - ``marked_vertices`` -- a boolean (default: ``True``); if set, edges</span>
<span class="sd">          with end points at a marked vertex are reported, otherwise, marked</span>
<span class="sd">          vertices are completely ignored.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        A set of segments and geodesics. Iteration through this set is in</span>
<span class="sd">        counterclockwise order with respect to the points of the set.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        The edges of a polygon::</span>

<span class="sd">            sage: P = H.intersection(</span>
<span class="sd">            ....:   H.vertical(-1).right_half_space(),</span>
<span class="sd">            ....:   H.vertical(1).left_half_space(),</span>
<span class="sd">            ....:   H.half_circle(0, 1).left_half_space(),</span>
<span class="sd">            ....:   H.half_circle(0, 4).right_half_space())</span>

<span class="sd">            sage: P.edges()</span>
<span class="sd">            {{-x + 1 = 0} ∩ {2*(x^2 + y^2) - 5*x - 3 ≤ 0}, {-(x^2 + y^2) + 4 = 0} ∩ {(x^2 + y^2) - 5*x + 1 ≥ 0} ∩ {(x^2 + y^2) + 5*x + 1 ≥ 0}, {x + 1 = 0} ∩ {2*(x^2 + y^2) + 5*x - 3 ≤ 0}, {(x^2 + y^2) - 1 = 0}}</span>

<span class="sd">            sage: [type(e) for e in P.edges()]</span>
<span class="sd">            [&lt;class &#39;flatsurf.geometry.hyperbolic.HyperbolicOrientedSegment_with_category_with_category&#39;&gt;,</span>
<span class="sd">             &lt;class &#39;flatsurf.geometry.hyperbolic.HyperbolicOrientedSegment_with_category_with_category&#39;&gt;,</span>
<span class="sd">             &lt;class &#39;flatsurf.geometry.hyperbolic.HyperbolicOrientedSegment_with_category_with_category&#39;&gt;,</span>
<span class="sd">             &lt;class &#39;flatsurf.geometry.hyperbolic.HyperbolicOrientedGeodesic_with_category_with_category&#39;&gt;]</span>

<span class="sd">            sage: [type(e) for e in P.edges(as_segments=True)]</span>
<span class="sd">            [&lt;class &#39;flatsurf.geometry.hyperbolic.HyperbolicOrientedSegment_with_category_with_category&#39;&gt;,</span>
<span class="sd">             &lt;class &#39;flatsurf.geometry.hyperbolic.HyperbolicOrientedSegment_with_category_with_category&#39;&gt;,</span>
<span class="sd">             &lt;class &#39;flatsurf.geometry.hyperbolic.HyperbolicOrientedSegment_with_category_with_category&#39;&gt;,</span>
<span class="sd">             &lt;class &#39;flatsurf.geometry.hyperbolic.HyperbolicOrientedSegment_with_category_with_category&#39;&gt;]</span>

<span class="sd">        The edges of a polygon with marked vertices::</span>

<span class="sd">            sage: P = H.convex_hull(-1, 1, I, 2*I, marked_vertices=True)</span>
<span class="sd">            sage: P.edges()</span>
<span class="sd">            {{-(x^2 + y^2) - 3*x + 4 = 0} ∩ {3*(x^2 + y^2) - 25*x - 12 ≤ 0}, {-(x^2 + y^2) + 3*x + 4 = 0} ∩ {3*(x^2 + y^2) + 25*x - 12 ≤ 0}, {(x^2 + y^2) - 1 = 0} ∩ {x ≤ 0}, {(x^2 + y^2) - 1 = 0} ∩ {x ≥ 0}}</span>
<span class="sd">            sage: P.edges(marked_vertices=False)</span>
<span class="sd">            {{-(x^2 + y^2) - 3*x + 4 = 0} ∩ {3*(x^2 + y^2) - 25*x - 12 ≤ 0}, {-(x^2 + y^2) + 3*x + 4 = 0} ∩ {3*(x^2 + y^2) + 25*x - 12 ≤ 0}, {(x^2 + y^2) - 1 = 0}}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">boundaries</span> <span class="o">=</span> <span class="p">[</span><span class="n">half_space</span><span class="o">.</span><span class="n">boundary</span><span class="p">()</span> <span class="k">for</span> <span class="n">half_space</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_half_spaces</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">boundaries</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">boundaries</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">B</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">boundaries</span><span class="p">):</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">boundaries</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">boundaries</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">boundaries</span><span class="p">)]</span>

            <span class="n">AB</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">_configuration</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
            <span class="n">BC</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">_configuration</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>

            <span class="n">start</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">end</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">AB</span> <span class="o">==</span> <span class="s2">&quot;convex&quot;</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">_intersection</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">start</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="n">AB</span> <span class="o">==</span> <span class="s2">&quot;concave&quot;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">AB</span> <span class="o">==</span> <span class="s2">&quot;negative&quot;</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="n">AB</span> <span class="o">==</span> <span class="s2">&quot;anti-parallel&quot;</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;cannot determine edges when boundaries are in configuration </span><span class="si">{</span><span class="n">AB</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">BC</span> <span class="o">==</span> <span class="s2">&quot;convex&quot;</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">_intersection</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">end</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="n">BC</span> <span class="o">==</span> <span class="s2">&quot;concave&quot;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">BC</span> <span class="o">==</span> <span class="s2">&quot;negative&quot;</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="n">BC</span> <span class="o">==</span> <span class="s2">&quot;anti-parallel&quot;</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;cannot determine edges when boundaries are in configuration </span><span class="si">{</span><span class="n">BC</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span>
                    <span class="n">B</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span> <span class="n">assume_normalized</span><span class="o">=</span><span class="n">as_segments</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">marked_vertices</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_marked_vertices</span><span class="p">:</span>
            <span class="n">edges_without_marked_vertices</span> <span class="o">=</span> <span class="n">edges</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges_without_marked_vertices</span><span class="p">:</span>
                <span class="n">vertices_on_edge</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">vertex</span> <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_marked_vertices</span> <span class="k">if</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">edge</span>
                <span class="p">]</span>

                <span class="k">def</span> <span class="nf">key</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">geodesic</span><span class="o">=</span><span class="n">edge</span><span class="o">.</span><span class="n">geodesic</span><span class="p">()):</span>
                    <span class="k">return</span> <span class="n">geodesic</span><span class="o">.</span><span class="n">parametrize</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">)</span>

                <span class="n">vertices_on_edge</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
                <span class="n">vertices_on_edge</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>

                <span class="n">start</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">vertices_on_edge</span><span class="p">:</span>
                    <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span>
                            <span class="n">edge</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(),</span>
                            <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
                            <span class="n">end</span><span class="o">=</span><span class="n">vertex</span><span class="p">,</span>
                            <span class="n">assume_normalized</span><span class="o">=</span><span class="n">as_segments</span><span class="p">,</span>
                            <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">vertex</span>

        <span class="k">return</span> <span class="n">HyperbolicEdges</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicConvexPolygon.vertices"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexPolygon.vertices">[docs]</a>    <span class="k">def</span> <span class="nf">vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">marked_vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the vertices of this polygon, i.e., the (possibly ideal) end</span>
<span class="sd">        points of the :meth:`edges`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        -- ``marked_vertices`` -- a boolean (default: ``True``) whether to</span>
<span class="sd">        include marked vertices in the output</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        Returns a set of points. Iteration over this set is in counterclockwise</span>
<span class="sd">        order.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        A finite polygon with a marked vertex::</span>

<span class="sd">            sage: P = H.polygon([</span>
<span class="sd">            ....:   H.vertical(1).left_half_space(),</span>
<span class="sd">            ....:   H.vertical(-1).right_half_space(),</span>
<span class="sd">            ....:   H.half_circle(0, 1).left_half_space(),</span>
<span class="sd">            ....:   H.half_circle(0, 4).right_half_space(),</span>
<span class="sd">            ....: ], marked_vertices=[I])</span>
<span class="sd">            sage: P.vertices()</span>
<span class="sd">            {-1, I, 1, (2/5, 3/5), (-2/5, 3/5)}</span>

<span class="sd">            sage: P.vertices(marked_vertices=False)</span>
<span class="sd">            {-1, 1, (2/5, 3/5), (-2/5, 3/5)}</span>

<span class="sd">        Currently, vertices cannot be computed if some of them have coordinates</span>
<span class="sd">        which do not live over the :meth:`HyperbolicPlane.base_ring`; see</span>
<span class="sd">        :class:`HyperbolicVertices`::</span>

<span class="sd">            sage: P = H.polygon([</span>
<span class="sd">            ....:   H.half_circle(0, 1).left_half_space(),</span>
<span class="sd">            ....:   H.half_circle(0, 2).right_half_space(),</span>
<span class="sd">            ....: ])</span>
<span class="sd">            sage: P.vertices()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: ...</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicConvexSet.vertices` for more details.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">marked_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">end</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">start</span> <span class="o">!=</span> <span class="n">end</span><span class="p">:</span>
                <span class="n">vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>

            <span class="n">end</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
            <span class="n">vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">marked_vertices</span><span class="p">:</span>
            <span class="n">vertices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_marked_vertices</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">HyperbolicVertices</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicConvexPolygon.half_spaces"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexPolygon.half_spaces">[docs]</a>    <span class="k">def</span> <span class="nf">half_spaces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a minimal set of half spaces whose intersection this polygon is.</span>

<span class="sd">        This implements :meth:`HyperbolicConvexSet.half_spaces`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        Marked vertices are not encoded in the half spaces in any way::</span>

<span class="sd">            sage: P = H.polygon([</span>
<span class="sd">            ....:   H.vertical(1).left_half_space(),</span>
<span class="sd">            ....:   H.vertical(-1).right_half_space(),</span>
<span class="sd">            ....:   H.half_circle(0, 1).left_half_space(),</span>
<span class="sd">            ....:   H.half_circle(0, 4).right_half_space(),</span>
<span class="sd">            ....: ], marked_vertices=[I + 1])</span>
<span class="sd">            sage: P</span>
<span class="sd">            {x - 1 ≤ 0} ∩ {(x^2 + y^2) - 4 ≤ 0} ∩ {x + 1 ≥ 0} ∩ {(x^2 + y^2) - 1 ≥ 0} ∪ {1 + I}</span>

<span class="sd">            sage: H.polygon(P.half_spaces())</span>
<span class="sd">            {x - 1 ≤ 0} ∩ {(x^2 + y^2) - 4 ≤ 0} ∩ {x + 1 ≥ 0} ∩ {(x^2 + y^2) - 1 ≥ 0}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_half_spaces</span></div>

    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a printable representation of this polygon.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: P = H.polygon([</span>
<span class="sd">            ....:   H.vertical(1).left_half_space(),</span>
<span class="sd">            ....:   H.vertical(-1).right_half_space(),</span>
<span class="sd">            ....:   H.half_circle(0, 1).left_half_space(),</span>
<span class="sd">            ....:   H.half_circle(0, 4).right_half_space(),</span>
<span class="sd">            ....: ], marked_vertices=[I + 1])</span>
<span class="sd">            sage: P</span>
<span class="sd">            {x - 1 ≤ 0} ∩ {(x^2 + y^2) - 4 ≤ 0} ∩ {x + 1 ≥ 0} ∩ {(x^2 + y^2) - 1 ≥ 0} ∪ {1 + I}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">half_spaces</span> <span class="o">=</span> <span class="s2">&quot; ∩ &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">repr</span><span class="p">(</span><span class="n">half_space</span><span class="p">)</span> <span class="k">for</span> <span class="n">half_space</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_half_spaces</span><span class="p">])</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">repr</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span> <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_marked_vertices</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">vertices</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">half_spaces</span><span class="si">}</span><span class="s2"> ∪ </span><span class="se">{{</span><span class="si">{</span><span class="n">vertices</span><span class="si">}</span><span class="se">}}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">half_spaces</span>

<div class="viewcode-block" id="HyperbolicConvexPolygon.plot"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexPolygon.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a plot of this polygon in the hyperbolic ``model``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``model`` -- one of ``&quot;half_plane&quot;`` and ``&quot;klein&quot;``</span>

<span class="sd">        - ``color`` -- a string (default: ``&quot;#efffff&quot;``); the fill color of</span>
<span class="sd">          polygons</span>

<span class="sd">        - ``edgecolor`` -- a string (default: ``&quot;blue&quot;``); the color of</span>
<span class="sd">          geodesics and segments</span>

<span class="sd">        See :func:`flatsurf.graphical.hyperbolic.hyperbolic_path` for additional keyword arguments to</span>
<span class="sd">        customize the plot.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        A finite triangle::</span>

<span class="sd">            sage: P = H.polygon([</span>
<span class="sd">            ....:     H.vertical(0).right_half_space(),</span>
<span class="sd">            ....:     H.geodesic(I, I + 1).left_half_space(),</span>
<span class="sd">            ....:     H.geodesic(I + 1, 2*I).left_half_space()</span>
<span class="sd">            ....: ])</span>
<span class="sd">            sage: P</span>
<span class="sd">            {(x^2 + y^2) - x - 1 ≥ 0} ∩ {(x^2 + y^2) + 2*x - 4 ≤ 0} ∩ {x ≥ 0}</span>

<span class="sd">        In the upper half plane model, this plots as a polygon bounded by a</span>
<span class="sd">        segment and two arcs::</span>

<span class="sd">            sage: P.plot(&quot;half_plane&quot;)[0]</span>
<span class="sd">            CartesianPathPlot([CartesianPathPlotCommand(code=&#39;MOVETO&#39;, args=(0.000000000000000, 1.00000000000000)),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;RARCTO&#39;, args=((1.00000000000000, 1.00000000000000), (0.500000000000000, 0))),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;ARCTO&#39;, args=((0.000000000000000, 2.00000000000000), (-1.00000000000000, 0))),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;LINETO&#39;, args=(0.000000000000000, 1.00000000000000))])</span>

<span class="sd">        Technically, the plot consists of two parts, a filled layer with</span>
<span class="sd">        transparent stroke and a transparent layer with solid stroke. The</span>
<span class="sd">        latter shows the (finite) edges of the polygon::</span>

<span class="sd">            sage: P.plot(&quot;half_plane&quot;)[1]</span>
<span class="sd">            CartesianPathPlot([CartesianPathPlotCommand(code=&#39;MOVETO&#39;, args=(0.000000000000000, 1.00000000000000)),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;RARCTO&#39;, args=((1.00000000000000, 1.00000000000000), (0.500000000000000, 0))),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;ARCTO&#39;, args=((0.000000000000000, 2.00000000000000), (-1.00000000000000, 0))),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;LINETO&#39;, args=(0.000000000000000, 1.00000000000000))])</span>

<span class="sd">        In the Klein disk model, this plots as two identical Euclidean</span>
<span class="sd">        triangles (one for the background, one for the edges,) with an added</span>
<span class="sd">        circle representing the ideal points in that model::</span>

<span class="sd">            sage: P.plot(&quot;klein&quot;)[0]</span>
<span class="sd">            Circle defined by (0.0,0.0) with r=1.0</span>
<span class="sd">            sage: P.plot(&quot;klein&quot;)[1]</span>
<span class="sd">            CartesianPathPlot([CartesianPathPlotCommand(code=&#39;MOVETO&#39;, args=(0.000000000000000, 0.000000000000000)),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;LINETO&#39;, args=(0.666666666666667, 0.333333333333333)),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;LINETO&#39;, args=(0.000000000000000, 0.600000000000000)),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;LINETO&#39;, args=(0.000000000000000, 0.000000000000000))])</span>
<span class="sd">            sage: P.plot(&quot;klein&quot;)[2]</span>
<span class="sd">            CartesianPathPlot([CartesianPathPlotCommand(code=&#39;MOVETO&#39;, args=(0.000000000000000, 0.000000000000000)),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;LINETO&#39;, args=(0.666666666666667, 0.333333333333333)),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;LINETO&#39;, args=(0.000000000000000, 0.600000000000000)),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;LINETO&#39;, args=(0.000000000000000, 0.000000000000000))])</span>

<span class="sd">        An ideal triangle plots the same way in the Klein model but now has two</span>
<span class="sd">        rays in the upper half plane model::</span>

<span class="sd">            sage: P = H.polygon([</span>
<span class="sd">            ....:     H.vertical(0).right_half_space(),</span>
<span class="sd">            ....:     H.geodesic(0, 1).left_half_space(),</span>
<span class="sd">            ....:     H.vertical(1).left_half_space()</span>
<span class="sd">            ....: ])</span>
<span class="sd">            sage: P</span>
<span class="sd">            {(x^2 + y^2) - x ≥ 0} ∩ {x - 1 ≤ 0} ∩ {x ≥ 0}</span>

<span class="sd">            sage: P.plot(&quot;half_plane&quot;)[0]</span>
<span class="sd">            CartesianPathPlot([CartesianPathPlotCommand(code=&#39;MOVETO&#39;, args=(0.000000000000000, 0.000000000000000)),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;RARCTO&#39;, args=((1.00000000000000, 0.000000000000000), (0.500000000000000, 0))),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;RAYTO&#39;, args=(0, 1)),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;LINETO&#39;, args=(0.000000000000000, 0.000000000000000))])</span>

<span class="sd">            sage: P.plot(&quot;klein&quot;)[1]</span>
<span class="sd">            CartesianPathPlot([CartesianPathPlotCommand(code=&#39;MOVETO&#39;, args=(0.000000000000000, -1.00000000000000)),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;LINETO&#39;, args=(1.00000000000000, 0.000000000000000)),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;LINETO&#39;, args=(0.000000000000000, 1.00000000000000)),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;LINETO&#39;, args=(0.000000000000000, -1.00000000000000))])</span>

<span class="sd">        A polygon can contain infinitely many ideal points as is the case in</span>
<span class="sd">        this intersection of two half spaces::</span>

<span class="sd">            sage: P = H.polygon([</span>
<span class="sd">            ....:     H.vertical(0).right_half_space(),</span>
<span class="sd">            ....:     H.vertical(1).left_half_space()</span>
<span class="sd">            ....: ])</span>
<span class="sd">            sage: P</span>
<span class="sd">            {x - 1 ≤ 0} ∩ {x ≥ 0}</span>

<span class="sd">            sage: P.plot(&quot;half_plane&quot;)[0]</span>
<span class="sd">            CartesianPathPlot([CartesianPathPlotCommand(code=&#39;MOVETO&#39;, args=(1.00000000000000, 0.000000000000000)),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;RAYTO&#39;, args=(0, 1)),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;LINETO&#39;, args=(0.000000000000000, 0.000000000000000)),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;LINETO&#39;, args=(1.00000000000000, 0.000000000000000))])</span>

<span class="sd">        The last part, the line connecting 0 and 1, is missing from the</span>
<span class="sd">        stroke plot since we only stroke finite edges::</span>

<span class="sd">            sage: P.plot(&quot;half_plane&quot;)[1]</span>
<span class="sd">            CartesianPathPlot([CartesianPathPlotCommand(code=&#39;MOVETO&#39;, args=(1.00000000000000, 0.000000000000000)),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;RAYTO&#39;, args=(0, 1)),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;LINETO&#39;, args=(0.000000000000000, 0.000000000000000))])</span>

<span class="sd">        Similarly in the Klein model picture, the arc of infinite points is</span>
<span class="sd">        only part of the fill, not of the stroke::</span>

<span class="sd">            sage: P.plot(&quot;klein&quot;)[1]</span>
<span class="sd">            CartesianPathPlot([CartesianPathPlotCommand(code=&#39;MOVETO&#39;, args=(1.00000000000000, 0.000000000000000)),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;LINETO&#39;, args=(0.000000000000000, 1.00000000000000)),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;LINETO&#39;, args=(0.000000000000000, -1.00000000000000)),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;ARCTO&#39;, args=((1.00000000000000, 0.000000000000000), (0, 0)))])</span>

<span class="sd">            sage: P.plot(&quot;klein&quot;)[2]</span>
<span class="sd">            CartesianPathPlot([CartesianPathPlotCommand(code=&#39;MOVETO&#39;, args=(1.00000000000000, 0.000000000000000)),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;LINETO&#39;, args=(0.000000000000000, 1.00000000000000)),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;LINETO&#39;, args=(0.000000000000000, -1.00000000000000))])</span>

<span class="sd">        If the polygon contains unbounded set of reals, we get a horizontal ray</span>
<span class="sd">        in the half plane picture::</span>

<span class="sd">            sage: P = H.polygon([</span>
<span class="sd">            ....:     H.vertical(0).right_half_space(),</span>
<span class="sd">            ....:     H.half_circle(2, 1).left_half_space(),</span>
<span class="sd">            ....: ])</span>
<span class="sd">            sage: P</span>
<span class="sd">            {(x^2 + y^2) - 4*x + 3 ≥ 0} ∩ {x ≥ 0}</span>

<span class="sd">            sage: P.plot(&quot;half_plane&quot;)[0]</span>
<span class="sd">            CartesianPathPlot([CartesianPathPlotCommand(code=&#39;MOVETO&#39;, args=(1.00000000000000, 0.000000000000000)),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;RARCTO&#39;, args=((3.00000000000000, 0.000000000000000), (2.00000000000000, 0))),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;RAYTO&#39;, args=(1, 0)),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;RAYTO&#39;, args=(0, 1)),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;LINETO&#39;, args=(0.000000000000000, 0.000000000000000)),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;LINETO&#39;, args=(1.00000000000000, 0.000000000000000))])</span>

<span class="sd">            sage: P.plot(&quot;half_plane&quot;)[1]</span>
<span class="sd">            CartesianPathPlot([CartesianPathPlotCommand(code=&#39;MOVETO&#39;, args=(1.00000000000000, 0.000000000000000)),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;RARCTO&#39;, args=((3.00000000000000, 0.000000000000000), (2.00000000000000, 0))),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;MOVETOINFINITY&#39;, args=(0, 1)),</span>
<span class="sd">                               CartesianPathPlotCommand(code=&#39;LINETO&#39;, args=(0.000000000000000, 0.000000000000000))])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwds</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;color&quot;</span><span class="p">,</span> <span class="s2">&quot;#efffff&quot;</span><span class="p">)</span>
        <span class="n">kwds</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;edgecolor&quot;</span><span class="p">,</span> <span class="s2">&quot;blue&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_half_spaces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot plot full space&quot;</span><span class="p">)</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">as_segments</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">marked_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

        <span class="kn">from</span> <span class="nn">flatsurf.graphical.hyperbolic</span> <span class="kn">import</span> <span class="n">HyperbolicPathPlotCommand</span>

        <span class="n">commands</span> <span class="o">=</span> <span class="p">[</span><span class="n">HyperbolicPathPlotCommand</span><span class="p">(</span><span class="s2">&quot;MOVETO&quot;</span><span class="p">,</span> <span class="n">pos</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">!=</span> <span class="n">pos</span><span class="p">:</span>
                <span class="n">commands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">HyperbolicPathPlotCommand</span><span class="p">(</span><span class="s2">&quot;MOVETO&quot;</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">start</span><span class="p">()))</span>

            <span class="n">commands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">HyperbolicPathPlotCommand</span><span class="p">(</span><span class="s2">&quot;LINETO&quot;</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">end</span><span class="p">()))</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">!=</span> <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">():</span>
            <span class="n">commands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">HyperbolicPathPlotCommand</span><span class="p">(</span><span class="s2">&quot;MOVETO&quot;</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">()))</span>

        <span class="kn">from</span> <span class="nn">flatsurf.graphical.hyperbolic</span> <span class="kn">import</span> <span class="n">hyperbolic_path</span>

        <span class="n">plot</span> <span class="o">=</span> <span class="n">hyperbolic_path</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enhance_plot</span><span class="p">(</span><span class="n">plot</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicConvexPolygon.change"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexPolygon.change">[docs]</a>    <span class="k">def</span> <span class="nf">change</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">oriented</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a modified copy of this polygon.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``ring`` -- a ring (default: ``None`` to keep the current</span>
<span class="sd">          :meth:`~HyperbolicPlane.base_ring`); the ring over which the polygon</span>
<span class="sd">          will be defined.</span>

<span class="sd">        - ``geometry`` -- a :class:`HyperbolicGeometry` (default: ``None`` to</span>
<span class="sd">          keep the current geometry); the geometry that will be used for the</span>
<span class="sd">          polygon.</span>

<span class="sd">        - ``oriented`` -- a boolean (default: ``None`` to keep the current</span>
<span class="sd">          orientedness); must be ``None`` or ``False`` since polygons cannot</span>
<span class="sd">          have an explicit orientation. See :meth:`~HyperbolicConvexSet.is_oriented`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        We change the ring over which a polygon is defined::</span>

<span class="sd">            sage: P = H.polygon([</span>
<span class="sd">            ....:     H.vertical(1).left_half_space(),</span>
<span class="sd">            ....:     H.vertical(-1).right_half_space(),</span>
<span class="sd">            ....:     H.half_circle(0, 1).left_half_space()],</span>
<span class="sd">            ....:     marked_vertices=[I])</span>

<span class="sd">            sage: P.change(ring=AA)</span>
<span class="sd">            {x - 1 ≤ 0} ∩ {x + 1 ≥ 0} ∩ {(x^2 + y^2) - 1 ≥ 0} ∪ {I}</span>

<span class="sd">        We cannot give a polygon an explicit orientation::</span>

<span class="sd">            sage: P.change(oriented=False) == P</span>
<span class="sd">            True</span>

<span class="sd">            sage: P.change(oriented=True)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            NotImplementedError: polygons cannot have an explicit orientation</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ring</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">geometry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
                <span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">geometry</span><span class="p">)</span>
                <span class="o">.</span><span class="n">polygon</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">half_space</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="n">ring</span><span class="o">=</span><span class="n">ring</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">geometry</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">half_space</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_half_spaces</span>
                    <span class="p">],</span>
                    <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">assume_minimal</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">marked_vertices</span><span class="o">=</span><span class="p">[</span>
                        <span class="n">vertex</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="n">ring</span><span class="o">=</span><span class="n">ring</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">geometry</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_marked_vertices</span>
                    <span class="p">],</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">oriented</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">oriented</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">oriented</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;polygons cannot have an explicit orientation&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="HyperbolicConvexPolygon.__eq__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexPolygon.__eq__">[docs]</a>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this polygon is indistinguishable from ``other``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: P = H.polygon([H.vertical(1).left_half_space(), H.vertical(-1).right_half_space()])</span>
<span class="sd">            sage: P == P</span>
<span class="sd">            True</span>

<span class="sd">        Marked vertices are taken into account to determine equality::</span>

<span class="sd">            sage: Q = H.polygon([H.vertical(1).left_half_space(), H.vertical(-1).right_half_space()], marked_vertices=[I + 1])</span>
<span class="sd">            sage: Q == Q</span>
<span class="sd">            True</span>
<span class="sd">            sage: P == Q</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">HyperbolicConvexPolygon</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_half_spaces</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_half_spaces</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_marked_vertices</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_marked_vertices</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicConvexPolygon.__hash__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexPolygon.__hash__">[docs]</a>    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a hash value for this polygon.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>

<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        Since polygons are hashable, they can be put in a hash table, such</span>
<span class="sd">        as a Python ``set``::</span>

<span class="sd">            sage: S = {H.polygon([H.vertical(1).left_half_space(), H.vertical(-1).right_half_space()])}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_half_spaces</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_marked_vertices</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_apply_isometry_klein</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">isometry</span><span class="p">,</span> <span class="n">on_right</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the image of this polygon under ``isometry``.</span>

<span class="sd">        Helper method for :meth:`HyperbolicConvexSet.apply_isometry`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``isometry`` -- a 3×3 matrix over the</span>
<span class="sd">          :meth:`~HyperbolicPlane.base_ring` describing an isometry in the</span>
<span class="sd">          hyperboloid model.</span>

<span class="sd">        - ``on_right`` -- a boolean (default: ``False``) whether to return the</span>
<span class="sd">          result of the right action.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: isometry = matrix([[1, -1, 1], [1, 1/2, 1/2], [1, -1/2, 3/2]])</span>
<span class="sd">            sage: P = H.polygon([</span>
<span class="sd">            ....:     H.vertical(0).right_half_space(),</span>
<span class="sd">            ....:     H.half_circle(0, 4).left_half_space()],</span>
<span class="sd">            ....:     marked_vertices=[4*I])</span>
<span class="sd">            sage: P._apply_isometry_klein(isometry)</span>
<span class="sd">            {(x^2 + y^2) - 2*x - 3 ≥ 0} ∩ {x - 1 ≥ 0} ∪ {1 + 4*I}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">half_spaces</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">h</span><span class="o">.</span><span class="n">apply_isometry</span><span class="p">(</span><span class="n">isometry</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span> <span class="n">on_right</span><span class="o">=</span><span class="n">on_right</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_half_spaces</span>
        <span class="p">]</span>
        <span class="n">marked_vertices</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">p</span><span class="o">.</span><span class="n">apply_isometry</span><span class="p">(</span><span class="n">isometry</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span> <span class="n">on_right</span><span class="o">=</span><span class="n">on_right</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_marked_vertices</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span>
            <span class="n">half_spaces</span><span class="o">=</span><span class="n">half_spaces</span><span class="p">,</span>
            <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">assume_minimal</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">marked_vertices</span><span class="o">=</span><span class="n">marked_vertices</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="HyperbolicConvexPolygon._isometry_conditions"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexPolygon._isometry_conditions">[docs]</a>    <span class="k">def</span> <span class="nf">_isometry_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterable of primitive pairs that must map to each other in an</span>
<span class="sd">        isometry that maps this set to ``other``.</span>

<span class="sd">        Helper method for :meth:`HyperbolicPlane._isometry_conditions`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: P = H.polygon([</span>
<span class="sd">            ....:     H.vertical(0).right_half_space(),</span>
<span class="sd">            ....:     H.half_circle(0, 4).left_half_space()],</span>
<span class="sd">            ....:     marked_vertices=[4*I])</span>

<span class="sd">            sage: conditions = P._isometry_conditions(P)</span>
<span class="sd">            sage: list(conditions)</span>
<span class="sd">            [[({x ≥ 0}, {(x^2 + y^2) - 4 ≥ 0}),</span>
<span class="sd">              ({(x^2 + y^2) - 4 ≥ 0}, {x ≥ 0}),</span>
<span class="sd">              (4*I, 4*I)],</span>
<span class="sd">             [({x ≥ 0}, {x ≥ 0}),</span>
<span class="sd">              ({(x^2 + y^2) - 4 ≥ 0}, {(x^2 + y^2) - 4 ≥ 0}),</span>
<span class="sd">              (4*I, 4*I)],</span>
<span class="sd">             [({x ≥ 0}, {x ≥ 0}),</span>
<span class="sd">              ({(x^2 + y^2) - 4 ≥ 0}, {(x^2 + y^2) - 4 ≥ 0}),</span>
<span class="sd">              (4*I, 4*I)],</span>
<span class="sd">             [({x ≥ 0}, {(x^2 + y^2) - 4 ≥ 0}),</span>
<span class="sd">              ({(x^2 + y^2) - 4 ≥ 0}, {x ≥ 0}),</span>
<span class="sd">              (4*I, 4*I)]]</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicConvexSet._isometry_conditions` for a general description.</span>

<span class="sd">        r&quot;&quot;&quot;</span>
        <span class="c1"># We are likely returning too many conditions here.</span>
        <span class="c1"># In particular there are many more ways to determine that no isometry</span>
        <span class="c1"># can possibly exist here.</span>

        <span class="k">for</span> <span class="n">reverse</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">]:</span>
            <span class="n">preimage</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">half_spaces</span><span class="p">())</span>
            <span class="n">image</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">half_spaces</span><span class="p">())</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">preimage</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
                <span class="n">image</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="p">)):</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">image</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_marked_vertices</span><span class="p">:</span>
                    <span class="n">preimage_vertices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_marked_vertices</span><span class="p">)</span>
                    <span class="n">image_vertices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_marked_vertices</span><span class="p">)</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">preimage_vertices</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">image_vertices</span><span class="p">):</span>
                        <span class="k">continue</span>

                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">image_vertices</span><span class="p">)):</span>
                        <span class="n">image_vertices</span> <span class="o">=</span> <span class="n">image_vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">image_vertices</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>

                        <span class="k">yield</span> <span class="nb">list</span><span class="p">(</span>
                            <span class="nb">zip</span><span class="p">(</span><span class="n">preimage</span> <span class="o">+</span> <span class="n">preimage_vertices</span><span class="p">,</span> <span class="n">image</span> <span class="o">+</span> <span class="n">image_vertices</span><span class="p">)</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">preimage</span><span class="p">,</span> <span class="n">image</span><span class="p">))</span></div>

<div class="viewcode-block" id="HyperbolicConvexPolygon.random_set"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexPolygon.random_set">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">random_set</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a random hyperbolic convex polygon.</span>

<span class="sd">        This implements :meth:`HyperbolicConvexSet.random_set`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``parent`` -- the :class:`HyperbolicPlane` containing the polygon</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicConvexPolygon</span>
<span class="sd">            sage: x = HyperbolicConvexPolygon.random_set(H)</span>

<span class="sd">            sage: x.dimension()</span>
<span class="sd">            2</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicPlane.random_element`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">ZZ</span>

            <span class="n">interior_points</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">ZZ</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span> <span class="o">+</span> <span class="mi">3</span>

            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">interior_points</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">HyperbolicPointFromCoordinates</span><span class="o">.</span><span class="n">random_set</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">is_ideal</span><span class="p">():</span>
                    <span class="k">continue</span>
                <span class="n">interior_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

            <span class="n">half_spaces</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">half_spaces</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">interior_points</span><span class="p">):</span>
                <span class="n">half_space</span> <span class="o">=</span> <span class="n">HyperbolicHalfSpace</span><span class="o">.</span><span class="n">random_set</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">interior_points</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">half_space</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">half_space</span><span class="o">.</span><span class="n">equation</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>

                    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>

                    <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>

                    <span class="n">half_space</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">half_space</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>

                    <span class="k">assert</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">half_space</span>

                <span class="n">half_spaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">half_space</span><span class="p">)</span>

            <span class="n">polygon</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">half_spaces</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">HyperbolicConvexPolygon</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">polygon</span></div>

<div class="viewcode-block" id="HyperbolicConvexPolygon.is_degenerate"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicConvexPolygon.is_degenerate">[docs]</a>    <span class="k">def</span> <span class="nf">is_degenerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this is considered to be a degenerate polygon.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        We consider polygons of area zero as degenerate::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: P = H.polygon([</span>
<span class="sd">            ....:     H.vertical(0).left_half_space(),</span>
<span class="sd">            ....:     H.half_circle(0, 1).left_half_space(),</span>
<span class="sd">            ....:     H.half_circle(0, 2).right_half_space(),</span>
<span class="sd">            ....:     H.vertical(0).right_half_space()</span>
<span class="sd">            ....: ], check=False, assume_minimal=True)</span>
<span class="sd">            sage: P.is_degenerate()</span>
<span class="sd">            True</span>

<span class="sd">        We also consider polygons with marked points as degenerate::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: P = H.polygon([</span>
<span class="sd">            ....:     H.vertical(1).left_half_space(),</span>
<span class="sd">            ....:     H.half_circle(0, 2).left_half_space(),</span>
<span class="sd">            ....:     H.half_circle(0, 4).right_half_space(),</span>
<span class="sd">            ....:     H.vertical(-1).right_half_space()</span>
<span class="sd">            ....: ], marked_vertices=[2*I])</span>
<span class="sd">            sage: P.is_degenerate()</span>
<span class="sd">            True</span>

<span class="sd">            sage: H.polygon(P.half_spaces()).is_degenerate()</span>
<span class="sd">            False</span>

<span class="sd">        Finally, we consider polygons with ideal points as degenerate::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: P = H.polygon([</span>
<span class="sd">            ....:     H.vertical(1).left_half_space(),</span>
<span class="sd">            ....:     H.vertical(-1).right_half_space()</span>
<span class="sd">            ....: ])</span>
<span class="sd">            sage: P.is_degenerate()</span>
<span class="sd">            True</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            This is not a terribly meaningful notion. This exists mostly</span>
<span class="sd">            because degenerate polygons have a more obvious meaning in</span>
<span class="sd">            Euclidean geometry where this check is used when rendering a</span>
<span class="sd">            polygon as a string.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">half_spaces</span><span class="p">())</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_finite</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="HyperbolicSegment"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicSegment">[docs]</a><span class="k">class</span> <span class="nc">HyperbolicSegment</span><span class="p">(</span><span class="n">HyperbolicConvexFacade</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A segment (possibly infinite) in the hyperbolic plane.</span>

<span class="sd">    This is an abstract base class of :class:`HyperbolicOrientedSegment` and</span>
<span class="sd">    :class:`HyperbolicUnorientedSegment`.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``parent`` -- the :class:`HyperbolicPlane` containing this segment</span>

<span class="sd">    - ``geodesic`` -- the :class:`HyperbolicGeodesic` of which this segment is a subset</span>

<span class="sd">    - ``start`` -- a :class:`HyperbolicPoint` or ``None`` (default: ``None``);</span>
<span class="sd">      the finite endpoint of the segment. If ``None``, then the segment extends</span>
<span class="sd">      all the way to the ideal starting point of the geodesic.</span>

<span class="sd">    - ``end`` -- a :class:`HyperbolicPoint` or ``None`` (default: ``None``);</span>
<span class="sd">      the finite endpoint of the segment. If ``None``, then the segment extends</span>
<span class="sd">      all the way to the ideal end point of the geodesic.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">        sage: H = HyperbolicPlane()</span>

<span class="sd">        sage: H.segment(H.vertical(0), start=I)</span>
<span class="sd">        {-x = 0} ∩ {(x^2 + y^2) - 1 ≥ 0}</span>

<span class="sd">        sage: H(I).segment(oo)</span>
<span class="sd">        {-x = 0} ∩ {(x^2 + y^2) - 1 ≥ 0}</span>

<span class="sd">    .. SEEALSO::</span>

<span class="sd">        Use :meth:`HyperbolicPlane.segment` or :meth:`HyperbolicPoint.segment`</span>
<span class="sd">        to create segments.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="HyperbolicSegment.__init__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicSegment.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">geodesic</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicSegment</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: segment = H.segment(H.vertical(0), start=I)</span>
<span class="sd">            sage: isinstance(segment, HyperbolicSegment)</span>
<span class="sd">            True</span>

<span class="sd">            sage: TestSuite(segment).run()</span>

<span class="sd">            sage: segment = segment.unoriented()</span>
<span class="sd">            sage: isinstance(segment, HyperbolicSegment)</span>
<span class="sd">            True</span>

<span class="sd">            sage: TestSuite(segment).run()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geodesic</span><span class="p">,</span> <span class="n">HyperbolicOrientedGeodesic</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;geodesic must be an oriented hyperbolic geodesic&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">HyperbolicPoint</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;start must be a hyperbolic point&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">HyperbolicPoint</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;end must be a hyperbolic point&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span> <span class="o">=</span> <span class="n">geodesic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_end</span> <span class="o">=</span> <span class="n">end</span></div>

    <span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">require_normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify that this is a valid segment.</span>

<span class="sd">        This implements :meth:`HyperbolicConvexSet._check`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``require_normalized`` -- a boolean (default: ``True``); whether to</span>
<span class="sd">          assume that normalization has already happened, i.e., segments with</span>
<span class="sd">          no finite end points have been rewritten into geodesics.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicConvexPolygon</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        The end points of the segment must be on the defining geodesic::</span>

<span class="sd">            sage: s = H.segment(H.vertical(0), start=1, check=False, assume_normalized=True)</span>
<span class="sd">            sage: s._check()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: start point must be on the geodesic</span>

<span class="sd">            sage: s = H.segment(H.vertical(0), end=1, check=False, assume_normalized=True)</span>
<span class="sd">            sage: s._check()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: end point must be on the geodesic</span>

<span class="sd">        The end points must be ordered correctly::</span>

<span class="sd">            sage: s = H.segment(H.vertical(0), start=2*I, end=I, check=False, assume_normalized=True)</span>
<span class="sd">            sage: s._check()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: end point of segment must not be before start point on the underlying geodesic</span>

<span class="sd">        The end points must be distinct::</span>

<span class="sd">            sage: s = H.segment(H.vertical(0), start=I, end=I, check=False, assume_normalized=True)</span>
<span class="sd">            sage: s._check(require_normalized=False)</span>

<span class="sd">            sage: s = H.segment(H.vertical(0), start=I, end=I, check=False, assume_normalized=True)</span>
<span class="sd">            sage: s._check(require_normalized=True)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: end point of segment must be after start point on the underlying geodesic</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;start point must be on the geodesic&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_end</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;end point must be on the geodesic&quot;</span><span class="p">)</span>

        <span class="n">start</span> <span class="o">=</span> <span class="p">(</span>
            <span class="kc">None</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span><span class="o">.</span><span class="n">parametrize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="p">(</span>
            <span class="kc">None</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_end</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span><span class="o">.</span><span class="n">parametrize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_end</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;end point of segment must not be before start point on the underlying geodesic&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">require_normalized</span> <span class="ow">and</span> <span class="n">end</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;end point of segment must be after start point on the underlying geodesic&quot;</span>
                <span class="p">)</span>

<div class="viewcode-block" id="HyperbolicSegment._normalize"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicSegment._normalize">[docs]</a>    <span class="k">def</span> <span class="nf">_normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return this set possibly rewritten in a simpler form.</span>

<span class="sd">        This implements :meth:`HyperbolicConvexSet._normalize`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        We define a helper method for easier testing::</span>

<span class="sd">            sage: segment = lambda *args, **kwds: H.segment(*args, **kwds, check=False, assume_normalized=True)</span>

<span class="sd">        A segment that consists of an ideal point, is just that point::</span>

<span class="sd">            sage: segment(H.vertical(-1), start=H.infinity(), end=H.infinity())._normalize()</span>
<span class="sd">            ∞</span>

<span class="sd">            sage: segment(H.vertical(0), start=H.infinity(), end=None)._normalize()</span>
<span class="sd">            ∞</span>

<span class="sd">            sage: segment(-H.vertical(0), start=None, end=H.infinity())._normalize()</span>
<span class="sd">            ∞</span>

<span class="sd">        A segment that has two ideal end points is a geodesic::</span>

<span class="sd">            sage: segment(H.vertical(0), start=None, end=H.infinity())._normalize()</span>
<span class="sd">            {-x = 0}</span>

<span class="sd">            sage: segment(-H.vertical(0), start=H.infinity(), end=None)._normalize()</span>
<span class="sd">            {x = 0}</span>

<span class="sd">        Segments that remain segments in normalization::</span>

<span class="sd">            sage: segment(H.vertical(0), start=I, end=H.infinity())._normalize()</span>
<span class="sd">            {-x = 0} ∩ {(x^2 + y^2) - 1 ≥ 0}</span>

<span class="sd">            sage: segment(-H.vertical(0), start=H.infinity(), end=I)._normalize()</span>
<span class="sd">            {x = 0} ∩ {(x^2 + y^2) - 1 ≥ 0}</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            This method is not numerically robust and should be improve over inexact rings.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span><span class="o">.</span><span class="n">is_ultra_ideal</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">empty_set</span><span class="p">()</span>

        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span>
        <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_end</span>

        <span class="k">def</span> <span class="nf">λ</span><span class="p">(</span><span class="n">point</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span><span class="o">.</span><span class="n">parametrize</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">λ</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">λ</span><span class="p">(</span><span class="n">end</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;end point of segment must be after start point on the underlying geodesic&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">start</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
                <span class="c1"># We should use a specialized predicate of geometry to make</span>
                <span class="c1"># this more robust over inexact rings.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_sgn</span><span class="p">(</span><span class="n">λ</span><span class="p">(</span><span class="n">start</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">empty_set</span><span class="p">()</span> <span class="k">if</span> <span class="n">start</span><span class="o">.</span><span class="n">is_ultra_ideal</span><span class="p">()</span> <span class="k">else</span> <span class="n">start</span>
                    <span class="p">)</span>
                <span class="n">start</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">end</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
                <span class="c1"># We should use a specialized predicate of geometry to make</span>
                <span class="c1"># this more robust over inexact rings.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_sgn</span><span class="p">(</span><span class="n">λ</span><span class="p">(</span><span class="n">end</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">empty_set</span><span class="p">()</span> <span class="k">if</span> <span class="n">end</span><span class="o">.</span><span class="n">is_ultra_ideal</span><span class="p">()</span> <span class="k">else</span> <span class="n">end</span>
                <span class="n">end</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">segment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">():</span>
                <span class="n">segment</span> <span class="o">=</span> <span class="n">segment</span><span class="o">.</span><span class="n">unoriented</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">segment</span>

        <span class="k">assert</span> <span class="p">(</span><span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">start</span><span class="o">.</span><span class="n">is_ultra_ideal</span><span class="p">())</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">end</span><span class="o">.</span><span class="n">is_ultra_ideal</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">start</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
            <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span>
            <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">assume_normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">oriented</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">(),</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_apply_isometry_klein</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">isometry</span><span class="p">,</span> <span class="n">on_right</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the image of this segment under ``isometry``.</span>

<span class="sd">        Helper method for :meth:`HyperbolicConvexSet.apply_isometry`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``isometry`` -- a 3×3 matrix over the</span>
<span class="sd">          :meth:`~HyperbolicPlane.base_ring` describing an isometry in the</span>
<span class="sd">          hyperboloid model.</span>

<span class="sd">        - ``on_right`` -- a boolean (default: ``False``) whether to return the</span>
<span class="sd">          result of the right action.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        We apply an isometry to an oriented segment::</span>

<span class="sd">            sage: isometry = matrix([[1, -1, 1], [1, 1/2, 1/2], [1, -1/2, 3/2]])</span>
<span class="sd">            sage: segment = H(I).segment(2*I)</span>
<span class="sd">            sage: segment._apply_isometry_klein(isometry)</span>
<span class="sd">            {-x + 1 = 0} ∩ {2*(x^2 + y^2) - 3*x - 1 ≥ 0} ∩ {(x^2 + y^2) - 3*x - 2 ≤ 0}</span>

<span class="sd">        We apply an isometry of negative determinant to an oriented segment::</span>

<span class="sd">            sage: isometry = matrix([[-1, 0, 0], [0, 1, 0], [0, 0, 1]])</span>
<span class="sd">            sage: segment._apply_isometry_klein(isometry) == segment</span>
<span class="sd">            True</span>

<span class="sd">            sage: segment.start().apply_isometry(isometry, model=&quot;klein&quot;) == segment.start()</span>
<span class="sd">            True</span>

<span class="sd">            sage: segment.end().apply_isometry(isometry, model=&quot;klein&quot;) == segment.end()</span>
<span class="sd">            True</span>

<span class="sd">        Note that this behavior is different from how the start and end point</span>
<span class="sd">        of a geodesic behave under such an isometry::</span>

<span class="sd">            sage: segment.geodesic().apply_isometry(isometry, model=&quot;klein&quot;) == segment.geodesic()</span>
<span class="sd">            False</span>

<span class="sd">            sage: segment.geodesic().apply_isometry(isometry, model=&quot;klein&quot;).start() == segment.geodesic().end()</span>
<span class="sd">            True</span>

<span class="sd">            sage: segment.geodesic().apply_isometry(isometry, model=&quot;klein&quot;).end() == segment.geodesic().start()</span>
<span class="sd">            True</span>

<span class="sd">        We can also apply an isometry to an unoriented geodesic::</span>

<span class="sd">            sage: segment.unoriented()._apply_isometry_klein(isometry) == segment.unoriented()</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geodesic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodesic</span><span class="p">()</span><span class="o">.</span><span class="n">_apply_isometry_klein</span><span class="p">(</span><span class="n">isometry</span><span class="p">,</span> <span class="n">on_right</span><span class="o">=</span><span class="n">on_right</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">isometry</span><span class="o">.</span><span class="n">det</span><span class="p">()</span><span class="o">.</span><span class="n">sign</span><span class="p">()</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">geodesic</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">():</span>
            <span class="n">geodesic</span> <span class="o">=</span> <span class="o">-</span><span class="n">geodesic</span>

        <span class="n">start</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="o">.</span><span class="n">apply_isometry</span><span class="p">(</span><span class="n">isometry</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span> <span class="n">on_right</span><span class="o">=</span><span class="n">on_right</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="kc">None</span>
        <span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_end</span><span class="o">.</span><span class="n">apply_isometry</span><span class="p">(</span><span class="n">isometry</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span> <span class="n">on_right</span><span class="o">=</span><span class="n">on_right</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="kc">None</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span>
            <span class="n">geodesic</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span> <span class="n">oriented</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">()</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_endpoint_half_spaces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the half spaces that stop the segment at its endpoints.</span>

<span class="sd">        A helper method for printing and :meth:`half_spaces`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicSegment</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: s = H.segment(H.half_circle(0, 1), end=I)</span>
<span class="sd">            sage: list(s._endpoint_half_spaces())</span>
<span class="sd">            [{x ≤ 0}]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span><span class="o">.</span><span class="n">equation</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">half_space</span><span class="p">(</span>
                <span class="o">-</span><span class="n">c</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">b</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_end</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">half_space</span><span class="p">(</span>
                <span class="n">c</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">b</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a printable representation of this segment.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicSegment</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.segment(H.half_circle(0, 1), end=I)</span>
<span class="sd">            {(x^2 + y^2) - 1 = 0} ∩ {x ≤ 0}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span><span class="p">)]</span>
        <span class="n">bounds</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">half_space</span><span class="p">)</span> <span class="k">for</span> <span class="n">half_space</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endpoint_half_spaces</span><span class="p">())</span>

        <span class="k">return</span> <span class="s2">&quot; ∩ &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>

<div class="viewcode-block" id="HyperbolicSegment.half_spaces"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicSegment.half_spaces">[docs]</a>    <span class="k">def</span> <span class="nf">half_spaces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a minimal set of half spaces whose intersection is this segment.</span>

<span class="sd">        This implements :meth:`HyperbolicConvexSet.half_spaces`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicSegment</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: segment = H.segment(H.half_circle(0, 1), end=I)</span>
<span class="sd">            sage: segment.half_spaces()</span>
<span class="sd">            {{x ≤ 0}, {(x^2 + y^2) - 1 ≤ 0}, {(x^2 + y^2) - 1 ≥ 0}}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span><span class="o">.</span><span class="n">half_spaces</span><span class="p">()</span> <span class="o">+</span> <span class="n">HyperbolicHalfSpaces</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_endpoint_half_spaces</span><span class="p">()</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicSegment.plot"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicSegment.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a plot of this segment.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``model`` -- one of ``&quot;half_plane&quot;`` or ``&quot;klein&quot;`` (default:</span>
<span class="sd">          ``&quot;half_plane&quot;``); in which model to produce the plot</span>

<span class="sd">        See :func:`flatsurf.graphical.hyperbolic.hyperbolic_path` for additional keyword arguments to</span>
<span class="sd">        customize the plot.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        .. jupyter-execute::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicSegment</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: segment = H.segment(H.half_circle(0, 1), end=I)</span>
<span class="sd">            sage: segment.plot()  # long time (.25s)</span>
<span class="sd">            ...Graphics object consisting of 1 graphics primitive</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="n">oriented</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">RR</span>

        <span class="n">kwds</span><span class="p">[</span><span class="s2">&quot;fill&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">RR</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">flatsurf.graphical.hyperbolic</span> <span class="kn">import</span> <span class="p">(</span>
            <span class="n">hyperbolic_path</span><span class="p">,</span>
            <span class="n">HyperbolicPathPlotCommand</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">plot</span> <span class="o">=</span> <span class="n">hyperbolic_path</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">HyperbolicPathPlotCommand</span><span class="p">(</span><span class="s2">&quot;MOVETO&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">()),</span>
                <span class="n">HyperbolicPathPlotCommand</span><span class="p">(</span><span class="s2">&quot;LINETO&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">()),</span>
            <span class="p">],</span>
            <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwds</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enhance_plot</span><span class="p">(</span><span class="n">plot</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicSegment.__eq__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicSegment.__eq__">[docs]</a>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this segment is indistinguishable from ``other`` (except</span>
<span class="sd">        for scaling in the defining geodesic&#39;s equation.)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicSegment</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        Oriented segments are equal if they have the same start and end points::</span>

<span class="sd">            sage: H(I).segment(2*I) == H(2*I).segment(I)</span>
<span class="sd">            False</span>

<span class="sd">        For an unoriented segment the endpoints must be the same but order does not matter::</span>

<span class="sd">            sage: H(I).segment(2*I).unoriented() == H(2*I).segment(I).unoriented()</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geodesic</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">geodesic</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicSegment.change"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicSegment.change">[docs]</a>    <span class="k">def</span> <span class="nf">change</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">oriented</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a modified copy of this segment.</span>

<span class="sd">        - ``ring`` -- a ring (default: ``None`` to keep the current</span>
<span class="sd">          :meth:`~HyperbolicPlane.base_ring`); the ring over which the new half</span>
<span class="sd">          space will be defined.</span>

<span class="sd">        - ``geometry`` -- a :class:`HyperbolicGeometry` (default: ``None`` to</span>
<span class="sd">          keep the current geometry); the geometry that will be used for the</span>
<span class="sd">          new half space.</span>

<span class="sd">        - ``oriented`` -- a boolean (default: ``None`` to keep the current</span>
<span class="sd">          orientedness); must be ``None`` or ``False`` since half spaces cannot</span>
<span class="sd">          have an explicit orientation. See :meth:`~HyperbolicConvexSet.is_oriented`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        We change the ring over which the segment is defined::</span>

<span class="sd">            sage: s = H(I).segment(2*I)</span>

<span class="sd">            sage: s.change(ring=AA)</span>
<span class="sd">            {-x = 0} ∩ {3/5*(x^2 + y^2) - 3/5 ≥ 0} ∩ {6/25*(x^2 + y^2) - 24/25 ≤ 0}</span>

<span class="sd">        We make the segment unoriented::</span>

<span class="sd">            sage: s.change(oriented=False).is_oriented()</span>
<span class="sd">            False</span>

<span class="sd">        We pick a (somewhat) random orientation of an unoriented segment::</span>

<span class="sd">            sage: s.unoriented().change(oriented=True).is_oriented()</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ring</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">geometry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="n">ring</span><span class="o">=</span><span class="n">ring</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">geometry</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="k">else</span> <span class="kc">None</span>
            <span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_end</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="n">ring</span><span class="o">=</span><span class="n">ring</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">geometry</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="k">else</span> <span class="kc">None</span>
            <span class="p">)</span>

            <span class="bp">self</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
                <span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">ring</span><span class="o">=</span><span class="n">ring</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">geometry</span><span class="p">)</span>
                <span class="o">.</span><span class="n">segment</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="n">ring</span><span class="o">=</span><span class="n">ring</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">geometry</span><span class="p">),</span>
                    <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
                    <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span>
                    <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">assume_normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">oriented</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">(),</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">oriented</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">oriented</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">oriented</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">():</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span><span class="p">,</span>
                <span class="n">start</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">,</span>
                <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_end</span><span class="p">,</span>
                <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">assume_normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">oriented</span><span class="o">=</span><span class="n">oriented</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="HyperbolicSegment.geodesic"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicSegment.geodesic">[docs]</a>    <span class="k">def</span> <span class="nf">geodesic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the geodesic on which this segment lies.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: s = H(I).segment(2*I)</span>
<span class="sd">            sage: s.geodesic()</span>
<span class="sd">            {-x = 0}</span>

<span class="sd">        Since the segment is oriented, the geodesic is also oriented::</span>

<span class="sd">            sage: s.is_oriented()</span>
<span class="sd">            True</span>

<span class="sd">            sage: s.geodesic().is_oriented()</span>
<span class="sd">            True</span>

<span class="sd">            sage: s.unoriented().geodesic().is_oriented()</span>
<span class="sd">            False</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            geodesics also implement this method so that segments and geodesics</span>
<span class="sd">            can be treated uniformly, see :meth:`HyperbolicGeodesic.geodesic`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geodesic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">():</span>
            <span class="n">geodesic</span> <span class="o">=</span> <span class="n">geodesic</span><span class="o">.</span><span class="n">unoriented</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">geodesic</span></div>

<div class="viewcode-block" id="HyperbolicSegment.vertices"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicSegment.vertices">[docs]</a>    <span class="k">def</span> <span class="nf">vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">marked_vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the end poinst of this segment.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``marked_vertices`` -- a boolean (default: ``True``), ignored since a</span>
<span class="sd">          segment cannot have marked vertices.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: s = H(I).segment(2*I)</span>
<span class="sd">            sage: s.vertices()</span>
<span class="sd">            {I, 2*I}</span>

<span class="sd">        Note that iteration in the set is not consistent with the orientation</span>
<span class="sd">        of the segment (it is chosen such that the subset relation on vertices</span>
<span class="sd">        can be checked quickly)::</span>

<span class="sd">            sage: (-s).vertices()</span>
<span class="sd">            {I, 2*I}</span>

<span class="sd">        Use :meth:`~HyperbolicOrientedSegment.start` and</span>
<span class="sd">        :meth:`~HyperbolicOrientedSegment.end` to get the vertices in an order</span>
<span class="sd">        that is consistent with the orientation::</span>

<span class="sd">            sage: s.start(), s.end()</span>
<span class="sd">            (I, 2*I)</span>
<span class="sd">            sage: (-s).start(), (-s).end()</span>
<span class="sd">            (2*I, I)</span>

<span class="sd">        Both finite and ideal end points of the segment are returned::</span>

<span class="sd">            sage: s = H(-1).segment(I)</span>
<span class="sd">            sage: s.vertices()</span>
<span class="sd">            {-1, I}</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicConvexSet.vertices` for more details.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="n">oriented</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">HyperbolicVertices</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">()])</span></div>

<div class="viewcode-block" id="HyperbolicSegment.dimension"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicSegment.dimension">[docs]</a>    <span class="k">def</span> <span class="nf">dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the dimension of this segment, i.e., 1.</span>

<span class="sd">        This implements :meth:`HyperbolicConvexSet.dimension`.</span>

<span class="sd">        Note that this also returns 1 if the actual dimension of the segment is</span>
<span class="sd">        smaller. This is, however, only possible for segments created with</span>
<span class="sd">        :meth:`HyperbolicPlane.segment` setting ``check=False``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H(I).segment(2*I).dimension()</span>
<span class="sd">            1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">ZZ</span>

        <span class="k">return</span> <span class="n">ZZ</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicSegment.midpoint"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicSegment.midpoint">[docs]</a>    <span class="k">def</span> <span class="nf">midpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the midpoint of this segment.</span>

<span class="sd">        ALGORITHM:</span>

<span class="sd">        We use the construction as explained on `Wikipedia</span>
<span class="sd">        &lt;https://en.wikipedia.org/wiki/Beltrami%E2%80%93Klein_model#Compass_and_straightedge_constructions&gt;`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicSegment</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: s = H(I).segment(4*I)</span>
<span class="sd">            sage: s.midpoint()</span>
<span class="sd">            2*I</span>

<span class="sd">        ::</span>

<span class="sd">            sage: K.&lt;a&gt; = NumberField(x^2 - 2, embedding=1.414)</span>
<span class="sd">            sage: H = HyperbolicPlane(K)</span>
<span class="sd">            sage: s = H(I - 1).segment(I + 1)</span>
<span class="sd">            sage: s.midpoint()</span>
<span class="sd">            a*I</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicSegment.perpendicular` for the perpendicular bisector</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">start</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">start</span><span class="o">.</span><span class="n">is_finite</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">end</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodesic</span><span class="p">()</span><span class="o">.</span><span class="n">midpoint</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">start</span><span class="o">.</span><span class="n">is_finite</span><span class="p">()</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">end</span><span class="o">.</span><span class="n">is_finite</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;cannot compute midpoint of unbounded segment </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodesic</span><span class="p">()</span><span class="o">.</span><span class="n">perpendicular</span><span class="p">(</span><span class="n">start</span><span class="p">)</span><span class="o">.</span><span class="n">vertices</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodesic</span><span class="p">()</span><span class="o">.</span><span class="n">perpendicular</span><span class="p">(</span><span class="n">end</span><span class="p">)</span><span class="o">.</span><span class="n">vertices</span><span class="p">():</span>
                <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
                <span class="n">intersection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">intersection</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">intersection</span>

            <span class="c1"># One of the two lines start at any p must intersect the segment</span>
            <span class="c1"># already. No need to check the other p.</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="kc">False</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;segment </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> must have a midpoint but the straightedge and compass construction did not yield any&quot;</span></div>

<div class="viewcode-block" id="HyperbolicSegment.perpendicular"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicSegment.perpendicular">[docs]</a>    <span class="k">def</span> <span class="nf">perpendicular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the geodesic through ``point`` that is perpendicular to this</span>
<span class="sd">        segment.</span>

<span class="sd">        If no point is given, return the perpendicular bisector of this</span>
<span class="sd">        segment.</span>

<span class="sd">        ALGORITHM:</span>

<span class="sd">        See :meth:`HyperbolicGeodesic.perpendicular`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``point`` -- a point on this segment or ``None`` (the default)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicSegment</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: s = H(I).segment(4*I)</span>
<span class="sd">            sage: s.perpendicular()</span>
<span class="sd">            {(x^2 + y^2) - 4 = 0}</span>
<span class="sd">            sage: s.perpendicular(I)</span>
<span class="sd">            {(x^2 + y^2) - 1 = 0}</span>

<span class="sd">        ::</span>

<span class="sd">            sage: K.&lt;a&gt; = NumberField(x^2 - 2, embedding=1.414)</span>
<span class="sd">            sage: H = HyperbolicPlane(K)</span>
<span class="sd">            sage: s = H(I - 1).segment(I + 1)</span>
<span class="sd">            sage: s.perpendicular()</span>
<span class="sd">            {x = 0}</span>
<span class="sd">            sage: s.perpendicular(I - 1)</span>
<span class="sd">            {4/3*(x^2 + y^2) + 16/3*x + 8/3 = 0}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">point</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">midpoint</span><span class="p">()</span>

        <span class="n">point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">point</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">point</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;point must be in the segment but </span><span class="si">{</span><span class="n">point</span><span class="si">}</span><span class="s2"> is not in </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodesic</span><span class="p">()</span><span class="o">.</span><span class="n">perpendicular</span><span class="p">(</span><span class="n">point</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="HyperbolicUnorientedSegment"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicUnorientedSegment">[docs]</a><span class="k">class</span> <span class="nc">HyperbolicUnorientedSegment</span><span class="p">(</span><span class="n">HyperbolicSegment</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An unoriented (possibly infinity) segment in the hyperbolic plane.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">        sage: H = HyperbolicPlane()</span>

<span class="sd">        sage: segment = H.segment(H.vertical(0), start=I).unoriented()</span>

<span class="sd">    TESTS::</span>

<span class="sd">        sage: from flatsurf.geometry.hyperbolic import HyperbolicUnorientedSegment</span>
<span class="sd">        sage: isinstance(segment, HyperbolicUnorientedSegment)</span>
<span class="sd">        True</span>

<span class="sd">    .. SEEALSO::</span>

<span class="sd">        Use :meth:`HyperbolicPlane.segment` or</span>
<span class="sd">        :meth:`~HyperbolicConvexSet.unoriented` to construct unoriented</span>
<span class="sd">        segments.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="HyperbolicUnorientedSegment.__hash__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicUnorientedSegment.__hash__">[docs]</a>    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a hash value for this set.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>

<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: s = H(I).segment(2*I)</span>

<span class="sd">        Since an oriented segment is hashable, it can be put in a hash table,</span>
<span class="sd">        such as a Python ``set``::</span>

<span class="sd">            sage: {s.unoriented(), (-s).unoriented()}</span>
<span class="sd">            {{-x = 0} ∩ {(x^2 + y^2) - 1 ≥ 0} ∩ {(x^2 + y^2) - 4 ≤ 0}}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="nb">frozenset</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_end</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodesic</span><span class="p">()))</span></div>

<div class="viewcode-block" id="HyperbolicUnorientedSegment._isometry_conditions"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicUnorientedSegment._isometry_conditions">[docs]</a>    <span class="k">def</span> <span class="nf">_isometry_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterable of primitive pairs that must map to each other in an</span>
<span class="sd">        isometry that maps this set to ``other``.</span>

<span class="sd">        Helper method for :meth:`HyperbolicPlane._isometry_conditions`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: s = H(I).segment(2*I).unoriented()</span>

<span class="sd">            sage: conditions = s._isometry_conditions(s)</span>
<span class="sd">            sage: list(conditions)</span>
<span class="sd">            [[({-x = 0} ∩ {(x^2 + y^2) - 1 ≥ 0} ∩ {(x^2 + y^2) - 4 ≤ 0},</span>
<span class="sd">               {-x = 0} ∩ {(x^2 + y^2) - 1 ≥ 0} ∩ {(x^2 + y^2) - 4 ≤ 0})],</span>
<span class="sd">             [({-x = 0} ∩ {(x^2 + y^2) - 1 ≥ 0} ∩ {(x^2 + y^2) - 4 ≤ 0},</span>
<span class="sd">               {x = 0} ∩ {(x^2 + y^2) - 4 ≤ 0} ∩ {(x^2 + y^2) - 1 ≥ 0})]]</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicConvexSet._isometry_conditions` for a general description.</span>

<span class="sd">        r&quot;&quot;&quot;</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="n">oriented</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="n">oriented</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">yield</span> <span class="p">[(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)]</span>
        <span class="k">yield</span> <span class="p">[(</span><span class="bp">self</span><span class="p">,</span> <span class="o">-</span><span class="n">other</span><span class="p">)]</span></div>

<div class="viewcode-block" id="HyperbolicUnorientedSegment.random_set"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicUnorientedSegment.random_set">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">random_set</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a random unoriented segment.</span>

<span class="sd">        This implements :meth:`HyperbolicConvexSet.random_set`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``parent`` -- the :class:`HyperbolicPlane` containing the segment</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicUnorientedSegment</span>
<span class="sd">            sage: x = HyperbolicUnorientedSegment.random_set(H)</span>

<span class="sd">            sage: x.dimension()</span>
<span class="sd">            1</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicPlane.random_element`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">HyperbolicOrientedSegment</span><span class="o">.</span><span class="n">random_set</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span><span class="o">.</span><span class="n">unoriented</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="HyperbolicOrientedSegment"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicOrientedSegment">[docs]</a><span class="k">class</span> <span class="nc">HyperbolicOrientedSegment</span><span class="p">(</span><span class="n">HyperbolicSegment</span><span class="p">,</span> <span class="n">HyperbolicOrientedConvexSet</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An oriented (possibly infinite) segment in the hyperbolic plane such as a</span>
<span class="sd">    boundary edge of a :class:`HyperbolicConvexPolygon`.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">        sage: H = HyperbolicPlane()</span>

<span class="sd">        sage: s = H(I).segment(2*I)</span>

<span class="sd">    TESTS::</span>

<span class="sd">        sage: from flatsurf.geometry.hyperbolic import HyperbolicOrientedSegment</span>
<span class="sd">        sage: isinstance(s, HyperbolicOrientedSegment)</span>
<span class="sd">        True</span>

<span class="sd">    .. SEEALSO::</span>

<span class="sd">        Use :meth:`HyperbolicPlane.segment` or :meth:`HyperbolicPoint.segment`</span>
<span class="sd">        to construct oriented segments.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="HyperbolicOrientedSegment.__neg__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicOrientedSegment.__neg__">[docs]</a>    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return this segment with its orientation reversed.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: s = H(I).segment(2*I)</span>
<span class="sd">            sage: s</span>
<span class="sd">            {-x = 0} ∩ {(x^2 + y^2) - 1 ≥ 0} ∩ {(x^2 + y^2) - 4 ≤ 0}</span>

<span class="sd">            sage: -s</span>
<span class="sd">            {x = 0} ∩ {(x^2 + y^2) - 4 ≤ 0} ∩ {(x^2 + y^2) - 1 ≥ 0}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span>
            <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_end</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">assume_normalized</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicOrientedSegment.__hash__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicOrientedSegment.__hash__">[docs]</a>    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a hash value for this set.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>

<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: s = H(I).segment(2*I)</span>

<span class="sd">        Since this set is hashable, it can be put in a hash table, such as a</span>
<span class="sd">        Python ``set``::</span>

<span class="sd">            sage: {s}</span>
<span class="sd">            {{-x = 0} ∩ {(x^2 + y^2) - 1 ≥ 0} ∩ {(x^2 + y^2) - 4 ≤ 0}}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_end</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodesic</span><span class="p">()))</span></div>

<div class="viewcode-block" id="HyperbolicOrientedSegment._isometry_conditions"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicOrientedSegment._isometry_conditions">[docs]</a>    <span class="k">def</span> <span class="nf">_isometry_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterable of primitive pairs that must map to each other in an</span>
<span class="sd">        isometry that maps this set to ``other``.</span>

<span class="sd">        Helper method for :meth:`HyperbolicPlane._isometry_conditions`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: s = H(I).segment(2*I)</span>

<span class="sd">            sage: conditions = s._isometry_conditions(s)</span>
<span class="sd">            sage: list(conditions)</span>
<span class="sd">            [[(I, I), (2*I, 2*I)]]</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicConvexSet._isometry_conditions` for a general description.</span>

<span class="sd">        r&quot;&quot;&quot;</span>
        <span class="k">yield</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">other</span><span class="o">.</span><span class="n">start</span><span class="p">()),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">other</span><span class="o">.</span><span class="n">end</span><span class="p">())]</span></div>

<div class="viewcode-block" id="HyperbolicOrientedSegment.start"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicOrientedSegment.start">[docs]</a>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the start point of this segment.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: s = H(I).segment(2*I)</span>
<span class="sd">            sage: s.start()</span>
<span class="sd">            I</span>

<span class="sd">            sage: s.start().is_finite()</span>
<span class="sd">            True</span>

<span class="sd">        The start point can also be an ideal point::</span>

<span class="sd">            sage: s = H(0).segment(2*I)</span>
<span class="sd">            sage: s.start()</span>
<span class="sd">            0</span>

<span class="sd">            sage: s.start().is_ideal()</span>
<span class="sd">            True</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`end`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span><span class="o">.</span><span class="n">start</span><span class="p">()</span></div>

<div class="viewcode-block" id="HyperbolicOrientedSegment.end"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicOrientedSegment.end">[docs]</a>    <span class="k">def</span> <span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the end point of this segment.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: s = H(I).segment(2*I)</span>
<span class="sd">            sage: s.end()</span>
<span class="sd">            2*I</span>

<span class="sd">            sage: s.end().is_finite()</span>
<span class="sd">            True</span>

<span class="sd">        The end point can also be an ideal point::</span>

<span class="sd">            sage: s = H(I).segment(oo)</span>
<span class="sd">            sage: s.end()</span>
<span class="sd">            ∞</span>

<span class="sd">            sage: s.end().is_ideal()</span>
<span class="sd">            True</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`start`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_end</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geodesic</span><span class="o">.</span><span class="n">end</span><span class="p">()</span></div>

<div class="viewcode-block" id="HyperbolicOrientedSegment.random_set"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicOrientedSegment.random_set">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">random_set</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a random oriented segment.</span>

<span class="sd">        This implements :meth:`HyperbolicConvexSet.random_set`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``parent`` -- the :class:`HyperbolicPlane` containing the segment</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicOrientedSegment</span>
<span class="sd">            sage: x = HyperbolicOrientedSegment.random_set(H)</span>

<span class="sd">            sage: x.dimension()</span>
<span class="sd">            1</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicPlane.random_element`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">HyperbolicPointFromCoordinates</span><span class="o">.</span><span class="n">random_set</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">HyperbolicPointFromCoordinates</span><span class="o">.</span><span class="n">random_set</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">is_finite</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">b</span><span class="o">.</span><span class="n">is_finite</span><span class="p">()):</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">HyperbolicPointFromCoordinates</span><span class="o">.</span><span class="n">random_set</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">parent</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">start</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">b</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="HyperbolicEmptySet"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicEmptySet">[docs]</a><span class="k">class</span> <span class="nc">HyperbolicEmptySet</span><span class="p">(</span><span class="n">HyperbolicConvexFacade</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The empty subset of the hyperbolic plane.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``parent`` -- the :class:`HyperbolicPlane` this is the empty set of</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">        sage: H = HyperbolicPlane()</span>

<span class="sd">        sage: H.empty_set()</span>
<span class="sd">        {}</span>

<span class="sd">    TESTS::</span>

<span class="sd">        sage: from flatsurf.geometry.hyperbolic import HyperbolicEmptySet</span>

<span class="sd">        sage: ø = H.empty_set()</span>
<span class="sd">        sage: isinstance(ø, HyperbolicEmptySet)</span>
<span class="sd">        True</span>

<span class="sd">        sage: TestSuite(ø).run()</span>

<span class="sd">    .. SEEALSO::</span>

<span class="sd">        Use :meth:`HyperbolicPlane.empty_set` to construct the empty set.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="HyperbolicEmptySet.__eq__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicEmptySet.__eq__">[docs]</a>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this empty set is indistinguishable from ``other``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: H.empty_set() == H.empty_set()</span>
<span class="sd">            True</span>
<span class="sd">            sage: H.empty_set() == HyperbolicPlane(AA).empty_set()</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">HyperbolicEmptySet</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span></div>

<div class="viewcode-block" id="HyperbolicEmptySet.some_elements"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicEmptySet.some_elements">[docs]</a>    <span class="k">def</span> <span class="nf">some_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return some representative points of this set for testing.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Since this set is empty, there are no points to return::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: H.empty_set().some_elements()</span>
<span class="sd">            []</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[]</span></div>

    <span class="k">def</span> <span class="nf">_test_an_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do not run tests on an element of this empty set (disabling the generic</span>
<span class="sd">        tests run by all parents otherwise.)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: H._test_an_element()</span>

<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_test_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do not run any tests on the elements of this empty set (disabling the</span>
<span class="sd">        generic tests run by all parents otherwise.)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: H._test_elements()</span>

<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a printable representation of the empty set.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.empty_set()</span>
<span class="sd">            {}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span>

    <span class="k">def</span> <span class="nf">_apply_isometry_klein</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">isometry</span><span class="p">,</span> <span class="n">on_right</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the result of applying the ``isometry`` to the empty set, i.e.,</span>
<span class="sd">        the empty set.</span>

<span class="sd">        Helper method for :meth:`HyperbolicConvexSet.apply_isometry`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``isometry`` -- a 3×3 matrix over the</span>
<span class="sd">          :meth:`~HyperbolicPlane.base_ring` describing an isometry in the</span>
<span class="sd">          hyperboloid model.</span>

<span class="sd">        - ``on_right`` -- a boolean (default: ``False``) whether to return the</span>
<span class="sd">          result of the right action.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: isometry = matrix([[1, -1, 1], [1, 1/2, 1/2], [1, -1/2, 3/2]])</span>
<span class="sd">            sage: H.empty_set()._apply_isometry_klein(isometry) == H.empty_set()</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="HyperbolicEmptySet.plot"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicEmptySet.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;half_plane&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a plot of the empty set.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``model`` -- one of ``&quot;half_plane&quot;`` and ``&quot;klein&quot;`` (default: ``&quot;half_plane&quot;``)</span>

<span class="sd">        Any keyword arguments are ignored.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        .. jupyter-execute::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.empty_set().plot()</span>
<span class="sd">            ...Graphics object consisting of 0 graphics primitives</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">Graphics</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enhance_plot</span><span class="p">(</span><span class="n">Graphics</span><span class="p">(),</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicEmptySet.dimension"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicEmptySet.dimension">[docs]</a>    <span class="k">def</span> <span class="nf">dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the dimension of this set; returns -1 for the empty set.</span>

<span class="sd">        This implements :meth:`HyperbolicConvexSet.dimension`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.empty_set().dimension()</span>
<span class="sd">            -1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">ZZ</span>

        <span class="k">return</span> <span class="n">ZZ</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicEmptySet.half_spaces"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicEmptySet.half_spaces">[docs]</a>    <span class="k">def</span> <span class="nf">half_spaces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a minimal set of half spaces whose intersection is empty.</span>

<span class="sd">        This implements :meth:`HyperbolicConvexSet.half_spaces`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.empty_set().half_spaces()</span>
<span class="sd">            {{(x^2 + y^2) + 4*x + 3 ≤ 0}, {(x^2 + y^2) - 4*x + 3 ≤ 0}}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">HyperbolicHalfSpaces</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">half_circle</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">right_half_space</span><span class="p">(),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">half_circle</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">right_half_space</span><span class="p">(),</span>
            <span class="p">]</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicEmptySet.change"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicEmptySet.change">[docs]</a>    <span class="k">def</span> <span class="nf">change</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">oriented</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of the empty set.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``ring`` -- a ring (default: ``None`` to keep the current</span>
<span class="sd">          :meth:`HyperbolicPlane.base_ring`); the ring over which the empty set</span>
<span class="sd">          will be defined.</span>

<span class="sd">        - ``geometry`` -- a :class:`HyperbolicGeometry` (default: ``None`` to</span>
<span class="sd">          keep the current geometry); the geometry that will be used for the</span>
<span class="sd">          empty set.</span>

<span class="sd">        - ``oriented`` -- a boolean (default: ``None`` to keep the current</span>
<span class="sd">          orientedness); must be ``None`` or ``False`` since the empty set</span>
<span class="sd">          cannot have an explicit orientation.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.empty_set().change(ring=AA) == HyperbolicPlane(AA).empty_set()</span>
<span class="sd">            True</span>

<span class="sd">            sage: H.empty_set().change(oriented=True)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            NotImplementedError: cannot change orientation of empty set</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ring</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">geometry</span><span class="p">)</span><span class="o">.</span><span class="n">empty_set</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">oriented</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">oriented</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">oriented</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_oriented</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot change orientation of empty set&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="HyperbolicEmptySet.__hash__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicEmptySet.__hash__">[docs]</a>    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a hash value for this set.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>

<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        Since this set is hashable, it can be put in a hash table, such as a</span>
<span class="sd">        Python ``set``::</span>

<span class="sd">            sage: {H.empty_set()}</span>
<span class="sd">            {{}}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="HyperbolicEmptySet.vertices"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicEmptySet.vertices">[docs]</a>    <span class="k">def</span> <span class="nf">vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">marked_vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the vertices of this empty, i.e., an empty set of points.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``marked_vertices`` -- a boolean (default: ``True``), ignored</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.empty_set().vertices()</span>
<span class="sd">            {}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">HyperbolicVertices</span><span class="p">([])</span></div>

    <span class="k">def</span> <span class="nf">_an_element_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a point in this set, i.e., raise an exception since there are no</span>
<span class="sd">        points.</span>

<span class="sd">        See :meth:`HyperbolicConvexSet._an_element_` for more interesting</span>
<span class="sd">        examples of this method.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.empty_set().an_element()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            Exception: empty set has no points</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;empty set has no points&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="HyperbolicEmptySet.random_set"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicEmptySet.random_set">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">random_set</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a random empty set, i.e., the empty set.</span>

<span class="sd">        This implements :meth:`HyperbolicConvexSet.random_set`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``parent`` -- the :class:`HyperbolicPlane` this is the empty set of.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicEmptySet</span>
<span class="sd">            sage: x = HyperbolicEmptySet.random_set(H)</span>

<span class="sd">            sage: x.dimension()</span>
<span class="sd">            -1</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicPlane.random_element`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">parent</span><span class="o">.</span><span class="n">empty_set</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="OrderedSet"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.OrderedSet">[docs]</a><span class="k">class</span> <span class="nc">OrderedSet</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Set</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A set of objects sorted by :meth:`OrderedSet._lt_`.</span>

<span class="sd">    This is used to efficiently represent</span>
<span class="sd">    :meth:`HyperbolicConvexSet.half_spaces`,</span>
<span class="sd">    :meth:`HyperbolicConvexSet.vertices`, and</span>
<span class="sd">    :meth:`HyperbolicConvexSet.edges`. In particular, it allows us to create</span>
<span class="sd">    and merge such sets in linear time.</span>

<span class="sd">    This is an abstract base class for specialized sets such as</span>
<span class="sd">    :class:`HyperbolicHalfSpaces`, :class:`HyperbolicVertices`, and</span>
<span class="sd">    :class:`HyperbolicEdges`.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``entries`` -- an iterable, the elements of this set</span>

<span class="sd">    - ``assume_sorted`` -- a boolean or ``&quot;rotated&quot;`` (default: ``True``); whether to assume</span>
<span class="sd">      that the ``entries`` are already sorted with respect to :meth:`_lt_`. If</span>
<span class="sd">      ``&quot;rotated&quot;``, we assume that the entries are sorted modulo a cyclic permutation.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">        sage: H = HyperbolicPlane()</span>

<span class="sd">        sage: segment = H(I).segment(2*I)</span>
<span class="sd">        sage: segment.vertices()</span>
<span class="sd">        {I, 2*I}</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="OrderedSet.__init__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.OrderedSet.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entries</span><span class="p">,</span> <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import OrderedSet</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: vertices = H(I).segment(2*I).vertices()</span>

<span class="sd">            sage: isinstance(vertices, OrderedSet)</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">assume_sorted</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">assume_sorted</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entries</span><span class="p">,</span> <span class="n">OrderedSet</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">assume_sorted</span> <span class="o">==</span> <span class="s2">&quot;rotated&quot;</span><span class="p">:</span>
            <span class="nb">min</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">entries</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lt_</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">entries</span><span class="p">[</span><span class="nb">min</span><span class="p">]):</span>
                    <span class="nb">min</span> <span class="o">=</span> <span class="n">i</span>

            <span class="n">entries</span> <span class="o">=</span> <span class="n">entries</span><span class="p">[</span><span class="nb">min</span><span class="p">:]</span> <span class="o">+</span> <span class="n">entries</span><span class="p">[:</span><span class="nb">min</span><span class="p">]</span>
            <span class="n">assume_sorted</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">assume_sorted</span><span class="p">:</span>
            <span class="n">entries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge</span><span class="p">(</span><span class="o">*</span><span class="p">[[</span><span class="n">entry</span><span class="p">]</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_entries</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">entries</span><span class="p">)</span></div>

<div class="viewcode-block" id="OrderedSet._lt_"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.OrderedSet._lt_">[docs]</a>    <span class="k">def</span> <span class="nf">_lt_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether ``lhs`` should come before ``rhs`` in this set.</span>

<span class="sd">        Subclasses must implement this method.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import OrderedSet</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: vertices = H(I).segment(2*I).vertices()</span>

<span class="sd">            sage: vertices._lt_(vertices[0], vertices[1])</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="OrderedSet._merge"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.OrderedSet._merge">[docs]</a>    <span class="k">def</span> <span class="nf">_merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">sets</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the merge of sorted lists of ``sets`` using merge sort.</span>

<span class="sd">        Note that this set itself is not part of the merge.</span>

<span class="sd">        Naturally, when there are a lot of small sets, such a merge sort takes</span>
<span class="sd">        quasi-linear time. However, when there are only a few sets, this runs</span>
<span class="sd">        in linear time.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``sets`` -- iterables that are sorted with respect to :meth:`_lt_`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicHalfSpaces</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: HyperbolicHalfSpaces([])._merge()</span>
<span class="sd">            []</span>

<span class="sd">            sage: HyperbolicHalfSpaces([])._merge([H.vertical(0).left_half_space()], [H.vertical(0).left_half_space()])</span>
<span class="sd">            [{x ≤ 0}]</span>

<span class="sd">            sage: HyperbolicHalfSpaces([])._merge(*[[half_space] for half_space in H.real(0).half_spaces()])</span>
<span class="sd">            [{(x^2 + y^2) + x ≤ 0}, {x ≥ 0}]</span>

<span class="sd">            sage: HyperbolicHalfSpaces([])._merge(list(H.real(0).half_spaces()), list(H.real(0).half_spaces()))</span>
<span class="sd">            [{(x^2 + y^2) + x ≤ 0}, {x ≥ 0}]</span>

<span class="sd">            sage: HyperbolicHalfSpaces([])._merge(*[[half_space] for half_space in list(H.real(0).half_spaces()) * 2])</span>
<span class="sd">            [{(x^2 + y^2) + x ≤ 0}, {x ≥ 0}]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># A standard merge-sort implementation.</span>
        <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sets</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># The non-trivial base case.</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">sets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">sets</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">while</span> <span class="n">A</span> <span class="ow">and</span> <span class="n">B</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lt_</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">merged</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lt_</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">merged</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Drop duplicate from set</span>
                    <span class="n">A</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

            <span class="n">merged</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

            <span class="k">return</span> <span class="n">A</span> <span class="o">+</span> <span class="n">B</span> <span class="o">+</span> <span class="n">merged</span>

        <span class="c1"># Divide &amp; Conquer recursively.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge</span><span class="p">(</span>
            <span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_merge</span><span class="p">(</span><span class="o">*</span><span class="n">sets</span><span class="p">[:</span> <span class="n">count</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge</span><span class="p">(</span><span class="o">*</span><span class="n">sets</span><span class="p">[</span><span class="n">count</span> <span class="o">//</span> <span class="mi">2</span> <span class="p">:]))</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="OrderedSet.__eq__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.OrderedSet.__eq__">[docs]</a>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this set is equal to ``other``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.vertical(0).vertices() == (-H.vertical(0)).vertices()</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entries</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_entries</span></div>

<div class="viewcode-block" id="OrderedSet.__ne__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.OrderedSet.__ne__">[docs]</a>    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this set is not equal to ``other``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.vertical(0).vertices() != H.vertical(1).vertices()</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="OrderedSet.__hash__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.OrderedSet.__hash__">[docs]</a>    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a hash value for this set that is consistent with :meth:`__eq__`</span>
<span class="sd">        and :meth:`__ne__`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: hash(H.vertical(0).vertices()) != hash(H.vertical(1).vertices())</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entries</span><span class="p">))</span></div>

<div class="viewcode-block" id="OrderedSet.__add__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.OrderedSet.__add__">[docs]</a>    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the :meth:`_merge` of this set and ``other``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``other`` -- another set of the same kind</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.vertical(0).half_spaces() + H.vertical(1).half_spaces()</span>
<span class="sd">            {{x ≤ 0}, {x - 1 ≤ 0}, {x ≥ 0}, {x - 1 ≥ 0}}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;both sets must be of the same type&quot;</span><span class="p">)</span>
        <span class="n">entries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entries</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_entries</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">entries</span><span class="p">,</span> <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="OrderedSet.__repr__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.OrderedSet.__repr__">[docs]</a>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a printable representation of this set.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: H.half_circle(0, 1).vertices()</span>
<span class="sd">            {-1, 1}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entries</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span></div>

<div class="viewcode-block" id="OrderedSet.__iter__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.OrderedSet.__iter__">[docs]</a>    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterator of this set.</span>

<span class="sd">        Iteration happens in sorted order, consistent with :meth:`_lt_`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: vertices = H.half_circle(0, 1).vertices()</span>
<span class="sd">            sage: list(vertices)</span>
<span class="sd">            [-1, 1]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entries</span><span class="p">)</span></div>

<div class="viewcode-block" id="OrderedSet.__len__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.OrderedSet.__len__">[docs]</a>    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cardinality of this set.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: vertices = H.half_circle(0, 1).vertices()</span>
<span class="sd">            sage: len(vertices)</span>
<span class="sd">            2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entries</span><span class="p">)</span></div>

<div class="viewcode-block" id="OrderedSet.pairs"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.OrderedSet.pairs">[docs]</a>    <span class="k">def</span> <span class="nf">pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterable that iterates over all consecutive pairs of elements</span>
<span class="sd">        in this set; including the pair formed by the last element and the</span>
<span class="sd">        first element.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``repeat`` -- a boolean (default: ``False``); whether to produce pair</span>
<span class="sd">          consisting of the first element twice if there is only one element</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: vertices = H.half_circle(0, 1).vertices()</span>
<span class="sd">            sage: list(vertices.pairs())</span>
<span class="sd">            [(1, -1), (-1, 1)]</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`triples`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entries</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">repeat</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entries</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entries</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></div>

<div class="viewcode-block" id="OrderedSet.triples"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.OrderedSet.triples">[docs]</a>    <span class="k">def</span> <span class="nf">triples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterable that iterates over all consecutive triples of</span>
<span class="sd">        elements in this set; including the triples formed by wrapping around</span>
<span class="sd">        the end of the set.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``repeat`` -- a boolean (default: ``False``); whether to produce</span>
<span class="sd">          triples by wrapping around even if there are fewer than three</span>
<span class="sd">          elements</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        There must be at least three elements to form any triples::</span>

<span class="sd">            sage: vertices = H.half_circle(0, 1).vertices()</span>
<span class="sd">            sage: list(vertices.triples())</span>
<span class="sd">            []</span>

<span class="sd">            sage: half_spaces = H(I).segment(2*I).half_spaces()</span>
<span class="sd">            sage: list(half_spaces.triples())</span>
<span class="sd">            [({(x^2 + y^2) - 1 ≥ 0}, {x ≤ 0}, {(x^2 + y^2) - 4 ≤ 0}),</span>
<span class="sd">             ({x ≤ 0}, {(x^2 + y^2) - 4 ≤ 0}, {x ≥ 0}),</span>
<span class="sd">             ({(x^2 + y^2) - 4 ≤ 0}, {x ≥ 0}, {(x^2 + y^2) - 1 ≥ 0}),</span>
<span class="sd">             ({x ≥ 0}, {(x^2 + y^2) - 1 ≥ 0}, {x ≤ 0})]</span>

<span class="sd">        However, we can force triples to be produced by wrapping around with</span>
<span class="sd">        ``repeat``::</span>

<span class="sd">            sage: vertices = H.half_circle(0, 1).vertices()</span>
<span class="sd">            sage: list(vertices.triples(repeat=True))</span>
<span class="sd">            [(1, -1, 1), (-1, 1, -1)]</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`pairs`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entries</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">repeat</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entries</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entries</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entries</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entries</span><span class="p">[</span>
                <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entries</span><span class="p">)</span>
            <span class="p">]</span></div>

<div class="viewcode-block" id="OrderedSet.__getitem__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.OrderedSet.__getitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return items from this set by index.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        Any arguments that can be used to access a tuple are accepted.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: vertices = H.half_circle(0, 1).vertices()</span>
<span class="sd">            sage: vertices[0]</span>
<span class="sd">            -1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entries</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="OrderedSet.__contains__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.OrderedSet.__contains__">[docs]</a>    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this set contains ``x``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: vertices = H.half_circle(0, 1).vertices()</span>

<span class="sd">            sage: H(0) in vertices</span>
<span class="sd">            False</span>

<span class="sd">            sage: H(1) in vertices</span>
<span class="sd">            True</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            Presently, this method is not used. It only exists to satisfy the</span>
<span class="sd">            conditions of the Python abc for sets. It could be implemented more</span>
<span class="sd">            efficiently.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entries</span></div></div>


<div class="viewcode-block" id="HyperbolicVertices"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicVertices">[docs]</a><span class="k">class</span> <span class="nc">HyperbolicVertices</span><span class="p">(</span><span class="n">OrderedSet</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A set of vertices on the boundary of a convex set in the hyperbolic plane,</span>
<span class="sd">    sorted in counterclockwise order.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``vertices`` -- an iterable of :class:`HyperbolicPoint`, the vertices of this set</span>

<span class="sd">    - ``assume_sorted`` -- a boolean or ``&quot;rotated&quot;`` (default: ``True``);</span>
<span class="sd">      whether to assume that the ``vertices`` are already sorted with respect</span>
<span class="sd">      to :meth:`_lt_`. If ``&quot;rotated&quot;``, we assume that the vertices are sorted</span>
<span class="sd">      modulo a cyclic permutation.</span>

<span class="sd">    ALGORITHM:</span>

<span class="sd">    We keep vertices sorted in counterclockwise order relative to a fixed</span>
<span class="sd">    reference vertex (the leftmost and bottommost in the Klein model.)</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">        sage: H = HyperbolicPlane()</span>
<span class="sd">        sage: V = H.vertical(0).vertices()</span>
<span class="sd">        sage: V</span>
<span class="sd">        {0, ∞}</span>

<span class="sd">    Note that in this example, ``0`` is chosen as the reference point::</span>

<span class="sd">        sage: V._start</span>
<span class="sd">        0</span>

<span class="sd">    TESTS::</span>

<span class="sd">        sage: from flatsurf.geometry.hyperbolic import HyperbolicVertices</span>
<span class="sd">        sage: isinstance(V, HyperbolicVertices)</span>
<span class="sd">        True</span>

<span class="sd">    .. SEEALSO::</span>

<span class="sd">        :meth:`HyperbolicConvexSet.vertices` to obtain such a set</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="HyperbolicVertices.__init__"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicVertices.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicVertices</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>
<span class="sd">            sage: V = H.vertical(0).vertices()</span>

<span class="sd">            sage: isinstance(V, HyperbolicVertices)</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">assume_sorted</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># We sort vertices in counterclockwise order. We need to fix a starting</span>
                <span class="c1"># point consistently, namely we choose the leftmost point in the Klein</span>
                <span class="c1"># model and if there are ties the one with minimal y coordinate.</span>
                <span class="c1"># That way we can then order vertices by their slopes with the starting</span>
                <span class="c1"># point to get a counterclockwise walk.</span>

                <span class="c1"># A very common special case is that we are presented with two</span>
                <span class="c1"># end points of a geodesic. This is a hack but getting the</span>
                <span class="c1"># consistent ordering to work with a mix of points without</span>
                <span class="c1"># using their coordinates is a lot of work.</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                    <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">HyperbolicPointFromGeodesic</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">HyperbolicPointFromGeodesic</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_geodesic</span> <span class="o">==</span> <span class="o">-</span><span class="n">vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">_geodesic</span>
                <span class="p">):</span>
                    <span class="n">geodesic</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_geodesic</span>
                    <span class="c1"># Note that we should use more robust predicates from the &quot;geometry&quot; to</span>
                    <span class="c1"># make this work more reliably over inexact rings.</span>
                    <span class="k">if</span> <span class="n">geodesic</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_zero</span><span class="p">(</span><span class="n">geodesic</span><span class="o">.</span><span class="n">_c</span><span class="p">):</span>
                        <span class="c1"># This is a vertical in the Klein model. Both end points have the</span>
                        <span class="c1"># same x coordinate.</span>
                        <span class="k">if</span> <span class="n">geodesic</span><span class="o">.</span><span class="n">_b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1"># This vertical is oriented downwards, so the end point has the</span>
                            <span class="c1"># minimal y coordinate.</span>
                            <span class="n">vertices</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                    <span class="k">elif</span> <span class="n">geodesic</span><span class="o">.</span><span class="n">_c</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># This geodesic points right-to-left in the Klein model. The</span>
                        <span class="c1"># end point has minimal x coordinate.</span>
                        <span class="n">vertices</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">assume_sorted</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                        <span class="n">vertices</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">vertex</span><span class="p">:</span> <span class="n">vertex</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>
                    <span class="p">)</span>

        <span class="c1"># _lt_ needs to know the global structure of the convex hull of the vertices.</span>
        <span class="c1"># The base class constructor will replace _entries with a sorted version of _entries.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_entries</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">assume_sorted</span><span class="o">=</span><span class="n">assume_sorted</span><span class="p">)</span></div>

<div class="viewcode-block" id="HyperbolicVertices._merge"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicVertices._merge">[docs]</a>    <span class="k">def</span> <span class="nf">_merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">sets</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the merge of sorted lists of ``sets``.</span>

<span class="sd">        Note that this set itself is not part of the merge (but its reference</span>
<span class="sd">        point is used.)</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``sets`` -- iterables that are sorted with respect to :meth:`_lt_`.</span>

<span class="sd">        .. WARNING::</span>

<span class="sd">            For this to work correctly, the result of the merge must eventually</span>
<span class="sd">            have the reference point of this set as its reference point.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicHalfSpaces</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: V = H.vertical(0).vertices()</span>

<span class="sd">            sage: V._merge([H(1)], [H(0)], [H(oo)])</span>
<span class="sd">            [0, 1, ∞]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_merge</span><span class="p">(</span><span class="o">*</span><span class="n">sets</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_slope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the slope of ``vertex`` with respect to the chosen reference</span>
<span class="sd">        vertex of this set as a tuple (Δy, Δx).</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicHalfSpaces</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: V = H.vertical(0).vertices()</span>

<span class="sd">        We compute the Euclidean slope from 0 to 1 in the Klein model::</span>

<span class="sd">            sage: V._slope(H(1))</span>
<span class="sd">            (1, 1)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sx</span><span class="p">,</span> <span class="n">sy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">vertex</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">sy</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">sx</span><span class="p">)</span>

<div class="viewcode-block" id="HyperbolicVertices._lt_"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicVertices._lt_">[docs]</a>    <span class="k">def</span> <span class="nf">_lt_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether ``lhs`` should come before ``rhs`` in this set.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``lhs`` -- a :class:`HyperbolicPoint`</span>

<span class="sd">        - ``rhs`` -- a :class:`HyperbolicPoint`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicHalfSpaces</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: V = H.vertical(0).vertices()</span>

<span class="sd">        We find that we go counterclockwise from 1 to ∞ when seen from 0 in the</span>
<span class="sd">        Klein model::</span>

<span class="sd">            sage: V._lt_(H(oo), H(1))</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lhs</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">rhs</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">lhs</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">dy_lhs</span><span class="p">,</span> <span class="n">dx_lhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slope</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span>
        <span class="n">dy_rhs</span><span class="p">,</span> <span class="n">dx_rhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slope</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">dx_lhs</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dx_rhs</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="p">),</span> <span class="s2">&quot;all points must be to the right of the starting point due to chosen normalization&quot;</span>

        <span class="k">if</span> <span class="n">dy_lhs</span> <span class="o">*</span> <span class="n">dx_rhs</span> <span class="o">&lt;</span> <span class="n">dy_rhs</span> <span class="o">*</span> <span class="n">dx_lhs</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">dy_lhs</span> <span class="o">*</span> <span class="n">dx_rhs</span> <span class="o">&gt;</span> <span class="n">dy_rhs</span> <span class="o">*</span> <span class="n">dx_lhs</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># The points (start, lhs, rhs) are collinear.</span>
        <span class="c1"># In general we cannot decide their order with only looking at start,</span>
        <span class="c1"># lhs, and rhs. We need to understand where the rest of the convex hull</span>
        <span class="c1"># lives.</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">lhs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entries</span> <span class="ow">and</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entries</span>
        <span class="p">),</span> <span class="s2">&quot;cannot compare vertices that are not defining for the convex hull&quot;</span>

        <span class="c1"># If there is any vertex with a bigger slope, then this line is at the</span>
        <span class="c1"># start of the walk in counterclockwise order.</span>
        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entries</span><span class="p">:</span>
            <span class="n">dy</span><span class="p">,</span> <span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slope</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dy</span> <span class="o">*</span> <span class="n">dx_rhs</span> <span class="o">&gt;</span> <span class="n">dy_rhs</span> <span class="o">*</span> <span class="n">dx</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dx_lhs</span> <span class="o">&lt;</span> <span class="n">dx_rhs</span>
            <span class="k">elif</span> <span class="n">dy</span> <span class="o">*</span> <span class="n">dx_rhs</span> <span class="o">&lt;</span> <span class="n">dy_rhs</span> <span class="o">*</span> <span class="n">dx</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dx_lhs</span> <span class="o">&gt;</span> <span class="n">dx_rhs</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;cannot decide counterclockwise ordering of exactly three collinear points&quot;</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="HyperbolicHalfSpaces"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicHalfSpaces">[docs]</a><span class="k">class</span> <span class="nc">HyperbolicHalfSpaces</span><span class="p">(</span><span class="n">OrderedSet</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A set of half spaces in the hyperbolic plane ordered counterclockwise.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">        sage: H = HyperbolicPlane()</span>

<span class="sd">        sage: half_spaces = H.vertical(0).half_spaces()</span>
<span class="sd">        sage: half_spaces</span>
<span class="sd">        {{x ≤ 0}, {x ≥ 0}}</span>

<span class="sd">    TESTS::</span>

<span class="sd">        sage: from flatsurf.geometry.hyperbolic import HyperbolicHalfSpaces</span>

<span class="sd">        sage: isinstance(half_spaces, HyperbolicHalfSpaces)</span>
<span class="sd">        True</span>

<span class="sd">    .. SEEALSO::</span>

<span class="sd">        :meth:`HyperbolicConvexSet.half_spaces` to obtain such a set</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="HyperbolicHalfSpaces._lt_"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicHalfSpaces._lt_">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_lt_</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether the half space ``lhs`` is smaller than ``rhs`` in a cyclic</span>
<span class="sd">        ordering of normal vectors, i.e., order half spaces by whether their</span>
<span class="sd">        normal points to the left/right, the slope of the geodesic, and finally</span>
<span class="sd">        by containment.</span>

<span class="sd">        This ordering is such that :meth:`HyperbolicPlane.intersection` can be</span>
<span class="sd">        computed in linear time for two hyperbolic convex sets.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``lhs`` -- a :class:`HyperbolicHalfSpace`</span>

<span class="sd">        - ``rhs`` -- a :class:`HyperbolicHalfSpace`</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            The implementation is not very robust over inexact rings and should be improved for that use case.</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicHalfSpaces</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">        A half space is equal to itself::</span>

<span class="sd">            sage: HyperbolicHalfSpaces._lt_(H.vertical(0).left_half_space(), H.vertical(0).left_half_space())</span>
<span class="sd">            False</span>

<span class="sd">        A half space whose normal in the Klein model points to the left is</span>
<span class="sd">        smaller than one whose normal points to the right::</span>

<span class="sd">            sage: HyperbolicHalfSpaces._lt_(H.vertical(1).left_half_space(), H.half_circle(0, 1).left_half_space())</span>
<span class="sd">            True</span>
<span class="sd">            sage: HyperbolicHalfSpaces._lt_(H.vertical(0).left_half_space(), -H.vertical(0).left_half_space())</span>
<span class="sd">            True</span>
<span class="sd">            sage: HyperbolicHalfSpaces._lt_(-H.half_circle(-1, 1).left_half_space(), -H.vertical(1).left_half_space())</span>
<span class="sd">            True</span>
<span class="sd">            sage: HyperbolicHalfSpaces._lt_(-H.half_circle(-1, 1).left_half_space(), -H.vertical(1/2).left_half_space())</span>
<span class="sd">            True</span>
<span class="sd">            sage: HyperbolicHalfSpaces._lt_(H.vertical(1).left_half_space(), H.half_circle(-1, 1).left_half_space())</span>
<span class="sd">            True</span>
<span class="sd">            sage: HyperbolicHalfSpaces._lt_(H.vertical(1/2).left_half_space(), H.half_circle(-1, 1).left_half_space())</span>
<span class="sd">            True</span>

<span class="sd">        Half spaces are ordered by the slope of their normal in the Klein model::</span>

<span class="sd">            sage: HyperbolicHalfSpaces._lt_(H.vertical(-1).left_half_space(), H.vertical(1).left_half_space())</span>
<span class="sd">            True</span>
<span class="sd">            sage: HyperbolicHalfSpaces._lt_(-H.half_circle(-1, 1).left_half_space(), H.vertical(1).left_half_space())</span>
<span class="sd">            True</span>
<span class="sd">            sage: HyperbolicHalfSpaces._lt_(H.half_circle(-1, 1).left_half_space(), -H.vertical(1).left_half_space())</span>
<span class="sd">            True</span>
<span class="sd">            sage: HyperbolicHalfSpaces._lt_(H.vertical(0).left_half_space(), H.vertical(1).left_half_space())</span>
<span class="sd">            True</span>

<span class="sd">        Parallel half spaces in the Klein model are ordered by inclusion::</span>

<span class="sd">            sage: HyperbolicHalfSpaces._lt_(-H.half_circle(-1, 1).left_half_space(), H.vertical(1/2).left_half_space())</span>
<span class="sd">            True</span>
<span class="sd">            sage: HyperbolicHalfSpaces._lt_(-H.vertical(1/2).left_half_space(), H.half_circle(-1, 1).left_half_space())</span>
<span class="sd">            True</span>
<span class="sd">            sage: HyperbolicHalfSpaces._lt_(H.half_circle(0, 2).left_half_space(), H.half_circle(0, 1).left_half_space())</span>
<span class="sd">            True</span>
<span class="sd">            sage: HyperbolicHalfSpaces._lt_(H.half_circle(0, 1).right_half_space(), H.half_circle(0, 2).right_half_space())</span>
<span class="sd">            True</span>

<span class="sd">        Verify that comparisons are projective::</span>

<span class="sd">            sage: HyperbolicHalfSpaces._lt_(H.geodesic(5, -5, -1, model=&quot;half_plane&quot;).left_half_space(), H.geodesic(5/13, -5/13, -1/13, model=&quot;half_plane&quot;).left_half_space())</span>
<span class="sd">            False</span>
<span class="sd">            sage: HyperbolicHalfSpaces._lt_(H.geodesic(5/13, -5/13, -1/13, model=&quot;half_plane&quot;).left_half_space(), H.geodesic(5, -5, -1, model=&quot;half_plane&quot;).left_half_space())</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">equation</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>
        <span class="n">aa</span><span class="p">,</span> <span class="n">bb</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">equation</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">normal_points_left</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">normal_points_left</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">!=</span> <span class="n">normal_points_left</span><span class="p">(</span><span class="n">bb</span><span class="p">,</span> <span class="n">cc</span><span class="p">):</span>
            <span class="c1"># The normal vectors of the half spaces in the Klein model are in</span>
            <span class="c1"># different half planes, one is pointing left, one is pointing</span>
            <span class="c1"># right.</span>
            <span class="k">return</span> <span class="n">normal_points_left</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

        <span class="c1"># The normal vectors of the half spaces in the Klein model are in the</span>
        <span class="c1"># same half plane, so we order them by slope.</span>
        <span class="k">if</span> <span class="n">b</span> <span class="o">*</span> <span class="n">bb</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">bb</span><span class="p">:</span>
                <span class="c1"># The normals are vertical and in the same half plane, so</span>
                <span class="c1"># they must be equal. We will order the half spaces by</span>
                <span class="c1"># inclusion later.</span>
                <span class="n">cmp</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Exactly one of the normals is vertical; we order half spaces</span>
                <span class="c1"># such that that one is bigger.</span>
                <span class="k">return</span> <span class="n">bb</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Order by the slope of the normal.</span>
            <span class="n">cmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">bb</span><span class="p">)</span><span class="o">.</span><span class="n">sign</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">bb</span> <span class="o">-</span> <span class="n">cc</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">sign</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">cmp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># The half spaces are parallel in the Klein model. We order them by</span>
            <span class="c1"># inclusion, i.e., by the offset in direction of the normal.</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">*</span> <span class="n">cc</span><span class="p">:</span>
                <span class="n">cmp</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">sign</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">cc</span> <span class="o">-</span> <span class="n">aa</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">sign</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">b</span> <span class="o">*</span> <span class="n">bb</span>
                <span class="n">cmp</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">sign</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">bb</span> <span class="o">-</span> <span class="n">aa</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">sign</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="HyperbolicHalfSpaces.convex_hull"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicHalfSpaces.convex_hull">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">convex_hull</span><span class="p">(</span><span class="n">vertices</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the convex hull of ``vertices`` as a ordered set of half spaces.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``vertices`` -- a sequence of :class:`HyperbolicPoint`</span>

<span class="sd">        ALGORITHM:</span>

<span class="sd">        We use the classical Euclidean Graham scan algorithm in the Klein</span>
<span class="sd">        model.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: from flatsurf.geometry.hyperbolic import HyperbolicHalfSpaces</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: HyperbolicHalfSpaces.convex_hull([H(0), H(1), H(oo)])</span>
<span class="sd">            {{(x^2 + y^2) - x ≥ 0}, {x - 1 ≤ 0}, {x ≥ 0}}</span>

<span class="sd">            sage: HyperbolicHalfSpaces.convex_hull([H(0), H(1), H(I), H(oo)])</span>
<span class="sd">            {{(x^2 + y^2) - x ≥ 0}, {x - 1 ≤ 0}, {x ≥ 0}}</span>

<span class="sd">            sage: HyperbolicHalfSpaces.convex_hull([H(0), H(1), H(I), H(I + 1), H(oo)])</span>
<span class="sd">            {{(x^2 + y^2) - x ≥ 0}, {x - 1 ≤ 0}, {x ≥ 0}}</span>

<span class="sd">            sage: HyperbolicHalfSpaces.convex_hull([H(1/2), H(-1/2), H(1), H(I), H(I + 1), H(oo)])</span>
<span class="sd">            {{2*(x^2 + y^2) - 3*x + 1 ≥ 0}, {x - 1 ≤ 0}, {2*x + 1 ≥ 0}, {4*(x^2 + y^2) - 1 ≥ 0}}</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`HyperbolicPlane.convex_hull`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">vertices</span><span class="p">:</span>
            <span class="c1"># We cannot return empty_set() because we do not know the HyperbolicPlane this lives in.</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;cannot compute convex hull of empty set of vertices&quot;</span>
            <span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>

        <span class="n">vertices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">vertices</span><span class="p">))</span><span class="o">.</span><span class="n">half_spaces</span><span class="p">()</span>

        <span class="n">vertices</span> <span class="o">=</span> <span class="p">[</span><span class="n">vertex</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">]</span>
        <span class="n">reference</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>

        <span class="k">class</span> <span class="nc">Slope</span><span class="p">:</span>
            <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xy</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">reference</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dy</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">reference</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">dx</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">dy</span> <span class="o">==</span> <span class="mi">0</span>

                <span class="c1"># Return whether the two points have the same slope relative to &quot;reference&quot;</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">dx</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dy</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>

            <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
                <span class="c1"># Return whether the self has smaller slope relative to &quot;reference&quot; or</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">dx</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">dy</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">dx</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">dy</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="c1"># if slopes are the same, sort by distance</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">dy</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="n">vertices</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">Slope</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">reference</span>

        <span class="c1"># Drop collinear points</span>
        <span class="n">filtered</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vertices</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">):</span>
                <span class="n">filtered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">slope</span> <span class="o">=</span> <span class="n">Slope</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
            <span class="n">next_slope</span> <span class="o">=</span> <span class="n">Slope</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">slope</span> <span class="o">==</span> <span class="n">next_slope</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">filtered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">hull</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">ccw</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Return whether the vectors A-&gt;B, B-&gt;C describe a counter-clockwise turn.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">filtered</span><span class="p">:</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">hull</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ccw</span><span class="p">(</span><span class="n">hull</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">hull</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">vertex</span><span class="p">):</span>
                <span class="n">hull</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">hull</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">hull</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">reference</span>

        <span class="n">hull</span> <span class="o">=</span> <span class="p">[</span><span class="n">H</span><span class="o">.</span><span class="n">point</span><span class="p">(</span><span class="o">*</span><span class="n">xy</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;klein&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">xy</span> <span class="ow">in</span> <span class="n">hull</span><span class="p">]</span>

        <span class="n">half_spaces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hull</span><span class="p">)):</span>
            <span class="n">half_spaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span><span class="n">hull</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">hull</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">left_half_space</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">HyperbolicHalfSpaces</span><span class="p">(</span><span class="n">half_spaces</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="HyperbolicEdges"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicEdges">[docs]</a><span class="k">class</span> <span class="nc">HyperbolicEdges</span><span class="p">(</span><span class="n">OrderedSet</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A set of hyperbolic segments and geodesics ordered counterclockwise.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">        sage: H = HyperbolicPlane()</span>

<span class="sd">        sage: edges = H.vertical(0).edges()</span>
<span class="sd">        sage: edges</span>
<span class="sd">        {{-x = 0}, {x = 0}}</span>

<span class="sd">    TESTS::</span>

<span class="sd">        sage: from flatsurf.geometry.hyperbolic import HyperbolicEdges</span>
<span class="sd">        sage: isinstance(edges, HyperbolicEdges)</span>
<span class="sd">        True</span>

<span class="sd">    .. SEEALSO::</span>

<span class="sd">        :meth:`HyperbolicConvexSet.edges` to obtain such a set</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="HyperbolicEdges._lt_"><a class="viewcode-back" href="../../../geometry/hyperbolic.html#flatsurf.geometry.hyperbolic.HyperbolicEdges._lt_">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_lt_</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether ``lhs`` should come before ``rhs`` in the ordering of this set.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from flatsurf import HyperbolicPlane</span>
<span class="sd">            sage: H = HyperbolicPlane()</span>

<span class="sd">            sage: edges = H.vertical(0).edges()</span>
<span class="sd">            sage: edges._lt_(edges[0], edges[1])</span>
<span class="sd">            True</span>

<span class="sd">        Segments on the same edge are ordered correctly::</span>

<span class="sd">            sage: segments = [</span>
<span class="sd">            ....:   H(0).segment(H(I)),</span>
<span class="sd">            ....:   H(I).segment(H(2*I)),</span>
<span class="sd">            ....:   H(2*I).segment(H(oo))</span>
<span class="sd">            ....: ]</span>

<span class="sd">            sage: edges._lt_(segments[0], segments[1])</span>
<span class="sd">            True</span>
<span class="sd">            sage: edges._lt_(segments[0], segments[2])</span>
<span class="sd">            True</span>
<span class="sd">            sage: edges._lt_(segments[1], segments[2])</span>
<span class="sd">            True</span>

<span class="sd">            sage: edges._lt_(segments[2], segments[1])</span>
<span class="sd">            False</span>
<span class="sd">            sage: edges._lt_(segments[2], segments[0])</span>
<span class="sd">            False</span>
<span class="sd">            sage: edges._lt_(segments[1], segments[0])</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lhs_geodesic</span> <span class="o">=</span> <span class="n">lhs</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">HyperbolicOrientedSegment</span><span class="p">):</span>
            <span class="n">lhs_geodesic</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">geodesic</span><span class="p">()</span>

        <span class="n">rhs_geodesic</span> <span class="o">=</span> <span class="n">rhs</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">HyperbolicOrientedSegment</span><span class="p">):</span>
            <span class="n">rhs_geodesic</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">geodesic</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">HyperbolicHalfSpaces</span><span class="o">.</span><span class="n">_lt_</span><span class="p">(</span>
            <span class="n">lhs_geodesic</span><span class="o">.</span><span class="n">left_half_space</span><span class="p">(),</span> <span class="n">rhs_geodesic</span><span class="o">.</span><span class="n">left_half_space</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">lhs_geodesic</span> <span class="o">!=</span> <span class="n">rhs_geodesic</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">lhs</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># The geodesics containing the edges are the same but they are not the</span>
        <span class="c1"># same segments. We compare the finite points on the segment to decide</span>
        <span class="c1"># which edge comes first in counterclockwise order.</span>
        <span class="n">geodesic</span> <span class="o">=</span> <span class="n">lhs_geodesic</span>

        <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">start</span><span class="p">()</span><span class="o">.</span><span class="n">is_ideal</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">rhs</span><span class="o">.</span><span class="n">start</span><span class="p">()</span><span class="o">.</span><span class="n">is_ideal</span><span class="p">():</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="ow">not</span> <span class="n">lhs</span><span class="o">.</span><span class="n">end</span><span class="p">()</span><span class="o">.</span><span class="n">is_ideal</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">rhs</span><span class="o">.</span><span class="n">end</span><span class="p">()</span><span class="o">.</span><span class="n">is_ideal</span><span class="p">()</span>
                <span class="p">),</span> <span class="s2">&quot;edges in a set of HyperbolicEdges must be sortable&quot;</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="n">lhs</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="o">!=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
                <span class="p">),</span> <span class="s2">&quot;edges were found to be different as segments but they are actually the same&quot;</span>

                <span class="k">return</span> <span class="n">geodesic</span><span class="o">.</span><span class="n">parametrize</span><span class="p">(</span>
                    <span class="n">lhs</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span>
                <span class="p">)</span> <span class="o">&lt;</span> <span class="n">geodesic</span><span class="o">.</span><span class="n">parametrize</span><span class="p">(</span><span class="n">rhs</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">rhs</span><span class="o">.</span><span class="n">start</span><span class="p">()</span><span class="o">.</span><span class="n">is_ideal</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">geodesic</span><span class="o">.</span><span class="n">parametrize</span><span class="p">(</span>
            <span class="n">lhs</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span>
        <span class="p">)</span> <span class="o">&lt;</span> <span class="n">geodesic</span><span class="o">.</span><span class="n">parametrize</span><span class="p">(</span><span class="n">rhs</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">)</span></div></div>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2016-2024, the sage-flatsurf authors
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/scripts/furo.js"></script>
    <script src="../../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    </body>
</html>