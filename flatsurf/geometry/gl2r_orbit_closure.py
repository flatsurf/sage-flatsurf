r"""
GL(2,R)-orbit closure of translation surfaces

.. TODO::

    - Theorem 1.9 of Alex Wright: the field of definition is contained in the field generated by
      the ratio of circumferences. We should provide a method, .reset_field_of_definition or
      something similar

"""

# TODO: Verify that all methods here return SageMath objects

# ****************************************************************************
#  This file is part of sage-flatsurf.
#
#        Copyright (C) 2019-2025 Julian Rüth
#                      2020      Vincent Delecroix
#
#  sage-flatsurf is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 2 of the License, or
#  (at your option) any later version.
#
#  sage-flatsurf is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with sage-flatsurf. If not, see <https://www.gnu.org/licenses/>.
# ****************************************************************************

from sage.all import FreeModule, matrix, identity_matrix, ZZ, QQ, Unknown, vector, prod, cached_method


class GL2ROrbitClosure:
    r"""
    Lower bound approximation to the tangent space of a GL(2,R)-orbit closure of a
    linear family of translation surfaces.

    EXAMPLES::

        sage: from flatsurf import polygons, similarity_surfaces
        sage: from flatsurf import GL2ROrbitClosure  # optional: pyflatsurf

        sage: T = polygons.triangle(3, 3, 5)
        sage: S = similarity_surfaces.billiard(T)
        sage: S = S.minimal_cover(cover_type="translation")
        sage: GL2ROrbitClosure(S)  # optional: pyflatsurf  # random output due to deprecation warnings in some versions of cppyy
        GL(2,R)-orbit closure of dimension at least 2 in H_5(4, 2^2) (ambient dimension 12)

    Computing an orbit closure over an exact real ring with transcendental elements::

        sage: from flatsurf import Polygon, EuclideanPolygonsWithAngles
        sage: from pyexactreal import ExactReals  # optional: pyexactreal  # random output due to matplotlib warnings with some combinations of setuptools and matplotlib

        sage: E = EuclideanPolygonsWithAngles((1, 5, 5, 5))
        sage: R = ExactReals(E.base_ring())  # optional: pyexactreal
        sage: slopes = E.slopes()
        sage: T = Polygon(angles=(1, 5, 5, 5), edges=[slopes[0], R.random_element(1/4) * slopes[1]])  # optional: pyexactreal
        sage: S = similarity_surfaces.billiard(T)  # optional: pyexactreal
        sage: S = S.minimal_cover(cover_type="translation")  # optional: pyexactreal
        sage: O = GL2ROrbitClosure(S); O  # optional: pyflatsurf, optional: pyexactreal
        GL(2,R)-orbit closure of dimension at least 4 in H_7(4^3, 0) (ambient dimension 17)
        sage: bound = E.billiard_unfolding_stratum('half-translation', marked_points=True).dimension()
        sage: for slope in S.slopes(1):  # long time, optional: pyflatsurf, optional: pyexactreal
        ....:     decomposition = S._decomposition(slope)
        ....:     O.update_tangent_space_from_flow_decomposition(decomposition)
        ....:     if O.dimension() == bound: break
        sage: O  # long time, optional: pyflatsurf, optional: pyexactreal
        GL(2,R)-orbit closure of dimension at least 8 in H_7(4^3, 0) (ambient dimension 17)

    TESTS::

        sage: from flatsurf import translation_surfaces
        sage: x = polygen(QQ)
        sage: K = NumberField(x**3 - 2, 'a', embedding=AA(2)**QQ((1,3)))
        sage: a = K.gen()
        sage: S = translation_surfaces.mcmullen_genus2_prototype(2, 1, 0, -1, a/4)

        sage: from flatsurf import GL2ROrbitClosure  # optional: pyflatsurf
        sage: O = GL2ROrbitClosure(S) # optional: pyflatsurf
        sage: O._tangent_space.base_ring()  # optional: pyflatsurf
        Number Field in a with defining polynomial x^3 - 2 with a = 1.259921049894873?

    We now illustrate the projection::

        sage: try: # optional: pyflatsurf
        ....:     V = O.proj.row_ambient_module()
        ....: except AttributeError:
        ....:     V = O.proj._row_ambient_module()
        sage: try: # optional: pyflatsurf
        ....:     H = O.proj.column_ambient_module()
        ....: except AttributeError:
        ....:     H = O.proj._column_ambient_module()
        sage: assert O.proj.rank() == H.dimension() # optional: pyflatsurf
        sage: for b in O.boundaries(): # optional: pyflatsurf
        ....:    assert (O.proj * b).is_zero()
        sage: for i, e in enumerate(O.spanning_set): # optional: pyflatsurf
        ....:     assert (O.proj * V.gen(e.index())) == H.gen(i)
    """

    def __init__(self, surface):
        from flatsurf.features import pyflatsurf_feature
        pyflatsurf_feature.require()

        if surface.__class__.__name__.startswith("FlatTriangulation<"):
            import warnings
            warnings.warn("Creating a GL2ROrbitClosure from a FlatTriangulation has been deprecated and will be removed from a future version of sage-flatsurf; create GL2ROrbitClosure from a sage-flatsurf surface directly instead")

            from flatsurf.geometry.pyflatsurf.surface import Surface_pyflatsurf

            surface = Surface_pyflatsurf(surface)

        from flatsurf.geometry.surface import Surface_base
        if not isinstance(surface, Surface_base):
            raise TypeError("surface must be a translation surface")

        from flatsurf.geometry.categories import TranslationSurfaces
        if surface not in TranslationSurfaces():
            raise NotImplementedError(
                "cannot compute orbit closure of a non-translation surface"
                )

        self._surface = surface

        # We construct a spanning set of edges, that is a subset of the edges
        # of the flat triangulation that form a basis of H_1(S, Sigma; Z).
        # It comes together with a projection matrix
        t, m = self._spanning_tree()
        assert set(t.keys()) == {f[2] for f in self._flat_triangulation().faces()}
        self.spanning_set = []
        v = set(t.values())
        for e in self._flat_triangulation().edges():
            if e.positive() not in v and e.negative() not in v:
                self.spanning_set.append(e)

        self.d = len(self.spanning_set)

        assert 3 * self.d - 3 == self._flat_triangulation().size()
        assert m.rank() == self.d

        # projection matrix from Z^E to H_1(S, Sigma; Z) in the basis
        # of spanning edges
        self.proj = matrix(ZZ, [r for r in m.columns() if r])

        self.Omega = self._intersection_matrix(t, self.spanning_set)

        self.V = FreeModule(self._surface.base_ring(), self.d)
        self.H = matrix(self._surface.base_ring(), [
            self._vector_space_conversion().section(self._flat_triangulation().fromHalfEdge(e.positive()))
            for e in self.spanning_set
        ])
        self.Hdual = self.Omega * self.H

        self._tangent_space = LazyTangentSpace(surface, self.d)

        self.update_tangent_space_from_vector(self.H.transpose()[0])
        self.update_tangent_space_from_vector(self.H.transpose()[1])

    @cached_method
    def _flat_triangulation(self):
        r"""
        Return the libflatsurf surface which we use to compute the flow
        decompositions that we process to build thet tangent space.

        EXAMPLES::

            sage: from flatsurf import polygons, similarity_surfaces
            sage: from flatsurf import GL2ROrbitClosure  # optional: pyflatsurf

            sage: T = polygons.triangle(3, 3, 5)
            sage: S = similarity_surfaces.billiard(T)
            sage: S = S.minimal_cover(cover_type="translation")
            sage: O = GL2ROrbitClosure(S)  # optional: pyflatsurf
            sage: O._flat_triangulation()  # optional: pyflatsurf
            FlatTriangulationCombinatorial(...) with vectors ...

        """
        return self._surface.pyflatsurf().codomain().flat_triangulation()

    @cached_method
    def _vector_space_conversion(self):
        r"""
        Return a conversion from the real embedded two dimensional space in
        which the surface is defined to the vectors in which
        :meth:`_flat_triangulation` is defined.

        EXAMPLES::

            sage: from flatsurf import polygons, similarity_surfaces
            sage: from flatsurf import GL2ROrbitClosure  # optional: pyflatsurf

            sage: T = polygons.triangle(3, 3, 5)
            sage: S = similarity_surfaces.billiard(T)
            sage: S = S.minimal_cover(cover_type="translation")
            sage: O = GL2ROrbitClosure(S)  # optional: pyflatsurf
            sage: O._vector_space_conversion()  # optional: pyflatsurf
            Conversion from Vector space of dimension 2 over Number Field in c with defining polynomial x^10 - 11*x^8 + 44*x^6 - 77*x^4 + 55*x^2 - 11 with c = 1.979642883761866? to flatsurf::Vector<eantic::renf_elem_class>

        """
        from flatsurf.geometry.pyflatsurf.conversion import FlatTriangulationConversion
        return FlatTriangulationConversion.from_pyflatsurf(self._flat_triangulation()).vector_space_conversion()

    @cached_method
    def _ring_conversion(self):
        r"""
        Return a conversion from the real embedded field in
        which the coordinates of the surface live to the coordinates that the
        :meth:`_flat_triangulation` uses.

        EXAMPLES::

            sage: from flatsurf import polygons, similarity_surfaces
            sage: from flatsurf import GL2ROrbitClosure  # optional: pyflatsurf

            sage: T = polygons.triangle(3, 3, 5)
            sage: S = similarity_surfaces.billiard(T)
            sage: S = S.minimal_cover(cover_type="translation")
            sage: O = GL2ROrbitClosure(S)  # optional: pyflatsurf
            sage: O._ring_conversion()  # optional: pyflatsurf
            Conversion from Number Field in c with defining polynomial x^10 - 11*x^8 + 44*x^6 - 77*x^4 + 55*x^2 - 11 with c = 1.979642883761866? to NumberField(c^10 - 11*c^8 + 44*c^6 - 77*c^4 + 55*c^2 - 11, [1.979642883761865464752184075553437574753038743897433375677230890 +/- 1.53e-64])

        """
        return self._vector_space_conversion().ring_conversion()

    @property
    @cached_method
    def V2(self):
        r"""
        A model of the vector space R² in libflatsurf, e.g., to represent the
        vector associated to a saddle connection.

        EXAMPLES::

            sage: from flatsurf import polygons, similarity_surfaces
            sage: from flatsurf import GL2ROrbitClosure  # optional: pyflatsurf

            sage: T = polygons.triangle(3, 3, 5)
            sage: S = similarity_surfaces.billiard(T)
            sage: S = S.minimal_cover(cover_type="translation")
            sage: O = GL2ROrbitClosure(S)  # optional: pyflatsurf
            sage: O.V2  # optional: pyflatsurf
            doctest:warning
            ...
            UserWarning: V2 has been deprecated as a property for GL2ROrbitClosure and will be removed in a future version of sage-flatsurf; use surface.pyflatsurf()._pyflatsurf_conversion.vector_space_conversion()._vectors() instead if you really need that parent
            Flatsurf Vectors over Real Embedded Number Field in c with defining polynomial x^10 - 11*x^8 + 44*x^6 - 77*x^4 + 55*x^2 - 11 with c = 1.979642883761866?

        """
        import warnings
        warnings.warn("V2 has been deprecated as a property for GL2ROrbitClosure and will be removed in a future version of sage-flatsurf; use surface.pyflatsurf()._pyflatsurf_conversion.vector_space_conversion()._vectors() instead if you really need that parent")

        import pyflatsurf.vector
        return pyflatsurf.vector.Vectors(self._surface.base_ring())

    def dimension(self):
        r"""
        Return the current complex dimension of the GL(2,R)-orbit closure.

        Note that this is not the dimension of the orbit closure but only a
        lower bound. It is always at least 2 (coming from a GL(2,R)-orbit).
        The current tangent space can be refined via
        :meth:`update_tangent_space_from_flow_decomposition` and
        :meth:`update_tangent_space_from_vector`.

        EXAMPLES::

            sage: from flatsurf import Polygon, similarity_surfaces
            sage: from flatsurf import GL2ROrbitClosure  # optional: pyflatsurf
            sage: T = Polygon(angles=(1, 3, 5))
            sage: S = similarity_surfaces.billiard(T)
            sage: S = S.minimal_cover(cover_type="translation")
            sage: O = GL2ROrbitClosure(S)  # optional: pyflatsurf
            sage: O.dimension()  # optional: pyflatsurf
            2
            sage: bound = T.category().billiard_unfolding_stratum('half-translation', marked_points=True).dimension()
            sage: for slope in S.slopes(bound=1, algorithm="byAngle"):  # long time, optional: pyflatsurf
            ....:     decomposition = S._decomposition(slope)
            ....:     if O.dimension() == bound: break
            ....:     O.update_tangent_space_from_flow_decomposition(decomposition)
            ....:     print(O.dimension())
            3
            5
            5
            7
            9
            10

        """
        return self._tangent_space.dimension()

    def ambient_stratum(self):
        r"""
        Return the stratum of Abelian differentials this surface belongs to.

        EXAMPLES::

            sage: from flatsurf import Polygon, similarity_surfaces
            sage: from flatsurf import GL2ROrbitClosure # optional: pyflatsurf
            sage: T = Polygon(angles=(1, 3, 5))
            sage: S = similarity_surfaces.billiard(T)
            sage: S = S.minimal_cover(cover_type="translation")
            sage: O = GL2ROrbitClosure(S)  # optional: pyflatsurf
            sage: O.ambient_stratum()  # optional: pyflatsurf
            H_3(4, 0^4)

        """
        from surface_dynamics import Stratum

        surface = self._flat_triangulation()
        angles = [surface.angle(v) for v in surface.vertices()]
        return Stratum([a - 1 for a in angles], 1)

    def base_ring(self):
        r"""
        Return the ring of coefficients for the tangent space.

        EXAMPLES::

            sage: from flatsurf import Polygon, similarity_surfaces
            sage: from flatsurf import GL2ROrbitClosure # optional: pyflatsurf
            sage: T = Polygon(angles=(1, 3, 5))
            sage: S = similarity_surfaces.billiard(T)
            sage: S = S.minimal_cover(cover_type="translation")
            sage: O = GL2ROrbitClosure(S)  # optional: pyflatsurf
            sage: O.base_ring()  # optional: pyflatsurf
            Number Field in c with defining polynomial x^6 - 6*x^4 + 9*x^2 - 3 with c = 1.969615506024417?

        ::

            sage: from flatsurf import Polygon, EuclideanPolygonsWithAngles
            sage: from pyexactreal import ExactReals  # optional: pyexactreal  # random output due to matplotlib warnings with some combinations of setuptools and matplotlib

            sage: E = EuclideanPolygonsWithAngles((1, 5, 5, 5))
            sage: R = ExactReals(E.base_ring())  # optional: pyexactreal
            sage: slopes = E.slopes()
            sage: T = Polygon(angles=(1, 5, 5, 5), edges=[slopes[0], R.random_element(1/4) * slopes[1]])  # optional: pyexactreal
            sage: S = similarity_surfaces.billiard(T)  # optional: pyexactreal
            sage: S = S.minimal_cover(cover_type="translation")  # optional: pyexactreal
            sage: O = GL2ROrbitClosure(S)  # optional: pyflatsurf, optional: pyexactreal
            sage: O.base_ring()  # optional: pyflatsurf, optional: pyexactreal
            Number Field in c0 with defining polynomial x^2 - 2 with c0 = 1.414213562373095?

        """
        base_ring = self._surface.base_ring()

        from pyexactreal.exact_reals import ExactReals
        if isinstance(base_ring, ExactReals):
            # Determine the ring underlying the exact reals and convert to the
            # standard SageMath representation, i.e., NumberField instead of
            # RealEmbeddedNumberField.
            base_ring = base_ring.base_ring()
            if base_ring in [ZZ, QQ]:
                pass
            else:
                base_ring = base_ring.number_field

        return base_ring

    def field_of_definition(self):
        r"""
        Return the field of definition of the current subspace.

        .. WARNING::

            This involves the computation of the echelon form of the matrix. It
            might be rather expensive if the computation of the tangent space is
            not terminated.

        EXAMPLES::

            sage: from flatsurf import Polygon, similarity_surfaces, EuclideanPolygonsWithAngles
            sage: from flatsurf import GL2ROrbitClosure  # optional: pyflatsurf
            sage: from pyexactreal import ExactReals  # optional: pyexactreal
            sage: E = EuclideanPolygonsWithAngles((1, 5, 5, 5))
            sage: R = ExactReals(E.base_ring())  # optional: pyexactreal
            sage: slopes = E.slopes()
            sage: T = Polygon(angles=(1, 5, 5, 5), edges=[slopes[0], R.random_element(1/4) * slopes[1]])  # optional: pyexactreal
            sage: S = similarity_surfaces.billiard(T)  # optional: pyexactreal
            sage: S = S.minimal_cover(cover_type="translation")  # optional: pyexactreal
            sage: O = GL2ROrbitClosure(S); O  # optional: pyflatsurf, optional: pyexactreal
            GL(2,R)-orbit closure of dimension at least 4 in H_7(4^3, 0) (ambient dimension 17)
            sage: O.field_of_definition() # optional: pyflatsurf, optional: pyexactreal
            Number Field in c0 with defining polynomial x^2 - 2 with c0 = 1.414213562373095?
            sage: bound = E.billiard_unfolding_stratum('half-translation', marked_points=True).dimension()
            sage: for slope in S.slopes():  # long time, optional: pyflatsurf, optional: pyexactreal
            ....:     if O.dimension() == bound: break
            ....:     O.update_tangent_space_from_flow_decomposition(S._decomposition(slope))
            sage: O.field_of_definition()  # long time, optional: pyflatsurf, optional: pyexactreal
            Rational Field

            sage: T = Polygon(angles=(1, 3, 5))
            sage: S = similarity_surfaces.billiard(T)
            sage: S = S.minimal_cover(cover_type="translation")
            sage: O = GL2ROrbitClosure(S) # optional: pyflatsurf
            sage: O.field_of_definition() # optional: pyflatsurf
            Number Field in c0 with defining polynomial x^3 - 3*x - 1 with c0 = 1.879385241571817?
            sage: bound = T.category().billiard_unfolding_stratum('half-translation', marked_points=True).dimension()
            sage: for slope in S.slopes(): # long time, optional: pyflatsurf
            ....:     if O.dimension() == bound: break
            ....:     O.update_tangent_space_from_flow_decomposition(S._decomposition(slope))
            sage: O.field_of_definition()  # long time, optional: pyflatsurf
            Rational Field
        """
        M = matrix(self._tangent_space.basis()).echelon_form()

        from flatsurf.geometry.subfield import subfield_from_elements

        L, _, _ = subfield_from_elements(M.base_ring(), M.list())

        return L

    def _half_edge_to_face(self, h):
        r"""
        Return a canonical half-edge encoding the face bounded by the half edge
        with identifier ``h``.

        This is a helper method for :meth:`_spanning_tree`.
        """
        surface = self._flat_triangulation()
        h1 = h
        h2 = surface.nextInFace(h1)
        h3 = surface.nextInFace(h2)
        return min([h1, h2, h3], key=lambda x: x.index())

    def __repr__(self):
        return f"GL(2,R)-orbit closure of dimension at least {self.dimension()} in {self.ambient_stratum()} (ambient dimension {self.d})"

    def holonomy(self, v):
        r"""
        Return the holonomy of ``v`` (with respect to the chosen homology basis).

        OUTPUT:

        A two-dimensional vector over the base ring of the translation surface.

        EXAMPLES::

            sage: from flatsurf import translation_surfaces
            sage: from flatsurf import GL2ROrbitClosure # optional: pyflatsurf
            sage: x = polygen(QQ)
            sage: K.<a> = NumberField(x^3 - 2, embedding=AA(2)**(1/3))
            sage: S = translation_surfaces.mcmullen_L(1,1,1,a)
            sage: O = GL2ROrbitClosure(S) # optional: pyflatsurf
            sage: edges = O._flat_triangulation().edges() # optional: pyflatsurf
            sage: F = FreeModule(ZZ, len(edges)) # optional: pyflatsurf

            sage: for i, e in enumerate(edges):  # optional: pyflatsurf
            ....:     holonomy = O.holonomy(O.proj * F.gen(i))
            ....:     vector = O._flat_triangulation().fromHalfEdge(e.positive())
            ....:
            ....:     assert holonomy.parent() is S.base_ring()**2
            ....:     assert holonomy == O._vector_space_conversion().section(vector)

        """
        return self.V(v) * self.H

    def holonomy_dual(self, v):
        r"""
        Return the holonomy of the dual of ``v``
        """
        return self.V(v) * self.Hdual

    def tangent_space_basis(self):
        return self._tangent_space.basis()

    def lift(self, v):
        r"""
        Given a vector in the "spanning set basis" return a vector on the full basis of
        edges.

        The vectors are returned as columns in a matrix. Each column
        corresponds to one edge in the underlying :meth:`_flat_triangulation`
        ordered as returned by its ``.edges()``.

        EXAMPLES::

            sage: from flatsurf import polygons, translation_surfaces, similarity_surfaces
            sage: from flatsurf import GL2ROrbitClosure  # optional: pyflatsurf

            sage: S = translation_surfaces.mcmullen_genus2_prototype(4,2,1,1,0)
            sage: O = GL2ROrbitClosure(S)  # optional: pyflatsurf
            sage: u0,u1 = O.tangent_space_basis()  # optional: pyflatsurf
            sage: v0 = O.lift(u0)  # optional: pyflatsurf
            sage: v1 = O.lift(u1)  # optional: pyflatsurf
            sage: span([v0, v1])  # optional: pyflatsurf
            Vector space of degree 9 and dimension 2 over Number Field in l with defining polynomial x^2 - x - 8 with l = 3.372281323269015?
            Basis matrix:
            [            1             0            -1   1/8*l + 7/8  -1/8*l + 1/8            -1   5/8*l - 5/8  -1/2*l + 3/2 -5/8*l + 13/8]
            [            0             1            -1   1/4*l - 1/4  -1/4*l + 1/4             0   1/4*l - 1/4             0  -1/4*l + 1/4]

        This can be used to deform the surface::

            sage: T = polygons.triangle(3,4,13)
            sage: S = similarity_surfaces.billiard(T)
            sage: S = S.minimal_cover("translation").erase_marked_points() # long time (3s, #122), optional: pyflatsurf
            sage: O = GL2ROrbitClosure(S)  # long time (above), optional: pyflatsurf
            sage: for slope in S.slopes(bound=4): # long time (2s, #124), optional: pyflatsurf
            ....:     d = S._decomposition(slope, limit=20)
            ....:     O.update_tangent_space_from_flow_decomposition(d)
            ....:     if O.dimension() == 4:
            ....:         break
            sage: d1,d2,d3,d4 = [O.lift(b) for b in O.tangent_space_basis()]  # long time (above), optional: pyflatsurf
            sage: dreal = d1/132 + d2/227 + d3/1280 - d4/13201  # long time (above), optional: pyflatsurf
            sage: dimag = d1/141 - d2/233 + d4/1230 + d4/14250  # long time (above), optional: pyflatsurf
            sage: d = [O._vector_space_conversion()((x,y)) for x,y in zip(dreal,dimag)]  # long time (above), optional: pyflatsurf
            sage: S2 = O._flat_triangulation() + d  # long time (6s), optional: pyflatsurf

            sage: from flatsurf.geometry.pyflatsurf.surface import Surface_pyflatsurf  # optional: pyflatsurf
            sage: S2 = Surface_pyflatsurf(S2.surface())  # long time (above), optional: pyflatsurf
            sage: O2 = GL2ROrbitClosure(S2)  # long time (above), optional: pyflatsurf
            sage: for slope in S2.slopes(bound=1):  # long time (25s, #124), optional: pyflatsurf
            ....:     d = S2._decomposition(slope, limit=20)
            ....:     O2.update_tangent_space_from_flow_decomposition(d)

        TESTS:

        Verify that this also works with exact-real coefficients::

            sage: from flatsurf import Polygon, EuclideanPolygonsWithAngles
            sage: from pyexactreal import ExactReals  # optional: pyexactreal  # random output due to matplotlib warnings with some combinations of setuptools and matplotlib

            sage: E = EuclideanPolygonsWithAngles((1, 5, 5, 5))
            sage: R = ExactReals(E.base_ring())  # optional: pyexactreal
            sage: slopes = E.slopes()
            sage: T = Polygon(angles=(1, 5, 5, 5), edges=[slopes[0], R.random_element(1/4) * slopes[1]])  # optional: pyexactreal
            sage: S = similarity_surfaces.billiard(T)  # optional: pyexactreal
            sage: S = S.minimal_cover(cover_type="translation")  # optional: pyexactreal
            sage: O = GL2ROrbitClosure(S)  # optional: pyflatsurf, optional: pyexactreal
            sage: d1, d2, d3, d4 = [O.lift(b) for b in O.tangent_space_basis()]  # optional: pyflatsurf, optional: pyexactreal

        """
        # given the values on the spanning edges we reconstruct the unique vector that
        # vanishes on the boundary
        bdry = self.boundaries()
        n = self._flat_triangulation().edges().size()
        k = len(self.spanning_set)
        assert k + len(bdry) == n + 1
        A = matrix(QQ, n + 1, n)
        for i, e in enumerate(self.spanning_set):
            A[i, e.index()] = 1
        for i, b in enumerate(bdry):
            A[k + i, :] = b

        u = vector(self._surface.base_ring(), n + 1)
        u[:k] = v


        from pyexactreal.exact_reals import ExactReals
        if isinstance(u.base_ring(), ExactReals):
            u = u.change_ring(u.base_ring().base_ring())

        return A.solve_right(u)

    def absolute_homology(self):
        vert_index = {v: i for i, v in enumerate(self._flat_triangulation().vertices())}
        m = len(vert_index)
        if m == 1:
            return self.V
        rows = []

        import pyflatsurf

        for e in self.spanning_set:
            r = [0] * m
            i = vert_index[
                pyflatsurf.flatsurf.Vertex.target(
                    e.positive(), self._flat_triangulation().combinatorial()
                )
            ]
            j = vert_index[
                pyflatsurf.flatsurf.Vertex.source(
                    e.positive(), self._flat_triangulation().combinatorial()
                )
            ]
            if i != j:
                r[i] = 1
                r[j] = -1
            rows.append(r)
        return matrix(rows).left_kernel()

    def absolute_dimension(self):
        r"""
        EXAMPLES::

            sage: from flatsurf import polygons, similarity_surfaces
            sage: from flatsurf import GL2ROrbitClosure  # optional: pyflatsurf
            sage: T = polygons.triangle(1,3,4)  # Veech octagon
            sage: S = similarity_surfaces.billiard(T)
            sage: S = S.minimal_cover("translation")
            sage: O = GL2ROrbitClosure(S)  # optional: pyflatsurf
            sage: O.absolute_dimension()  # optional: pyflatsurf
            2

        The triangular billiard (5,6,7) belongs to the canonical double cover of
        the stratum Q(5,3,0^3) in genus 3. The orbit is dense and we can check
        that the absolute dimension is indeed `6 = 2 rank`::

            sage: T = polygons.triangle(5,6,7)
            sage: S = similarity_surfaces.billiard(T)
            sage: S = S.minimal_cover("translation")
            sage: O = GL2ROrbitClosure(S)  # optional: pyflatsurf
            sage: for slope in S.slopes():  # long time (3s)  # optional: pyflatsurf
            ....:     d = S._decomposition(slope, limit=100)
            ....:     O.update_tangent_space_from_flow_decomposition(d)
            ....:     if O.dimension() == 9:
            ....:         break
            sage: O.absolute_dimension()  # long time (above)  # optional: pyflatsurf
            6
        """
        return (
            self.absolute_homology().matrix() * matrix(self._tangent_space.basis()).transpose()
        ).rank()

    def _spanning_tree(self, root=None):
        r"""
        Return a pair ``(tree, proj)`` where

        - ``tree`` is a tree encoded in a dictionary. Its keys are the faces
          (coded by their minimal adjacent half-edge) and the corresponding
          value is the half-edge to cross to go toward the root face.

        - ``proj`` a projection matrix : for a vector ``v``, the vector
          ``v * proj`` is cohomologous to ``v`` and only takes values on the
          spanning set.

        EXAMPLES:

        The following example illustrate the projection matrix::

            sage: from flatsurf import polygons, similarity_surfaces
            sage: from flatsurf import GL2ROrbitClosure  # optional: pyflatsurf
            sage: T = polygons.triangle(1,3,4)
            sage: S = similarity_surfaces.billiard(T)
            sage: S = S.minimal_cover("translation")
            sage: O = GL2ROrbitClosure(S)  # optional: pyflatsurf
            sage: num_edges = O._flat_triangulation().edges().size()  # optional: pyflatsurf
            sage: V = VectorSpace(QQ, num_edges)  # optional: pyflatsurf
            sage: tree, proj = O._spanning_tree()  # optional: pyflatsurf

        The matrix ``proj`` is indeed a projection::

            sage: proj * proj == proj # optional: pyflatsurf
            True

        We now check that the matrix maps vectors to cohomologous vectors and
        takes values only on the chosen spanning set of edges::

            sage: values = tree.values()  # optional: pyflatsurf
            sage: indices = set(e.index() for e in O._flat_triangulation().edges() if e.positive() not in values and e.negative() not in values)  # optional: pyflatsurf
            sage: B = V.subspace(O.boundaries())  # optional: pyflatsurf
            sage: for e in range(num_edges):  # optional: pyflatsurf
            ....:     v = V.gen(e)
            ....:     assert (v * proj - v) in B
            ....:     if e in indices:
            ....:         assert v * proj == v
            ....:     else:
            ....:         assert (proj * v).is_zero()
        """
        if root is None:
            root = next(iter(self._flat_triangulation().edges())).positive()

        root = self._half_edge_to_face(root)
        t = {root: None}  # face -> half edge to take to go to the root
        todo = [root]
        edges = []  # store edges in topological order to perform Gauss reduction
        while todo:
            f = todo.pop()
            for _ in range(3):
                f1 = -f
                g = self._half_edge_to_face(f1)
                if g not in t:
                    t[g] = f1
                    todo.append(g)
                    edges.append(f1)

                f = self._flat_triangulation().nextInFace(f)

        # gauss reduction
        n = self._flat_triangulation().size()
        proj = identity_matrix(ZZ, n)
        edges.reverse()
        for f1 in edges:
            f2 = self._flat_triangulation().nextInFace(f1)
            f3 = self._flat_triangulation().nextInFace(f2)
            assert self._flat_triangulation().nextInFace(f3) == f1

            i1 = f1.index()
            s1 = -1 if i1 % 2 else 1
            i2 = f2.index()
            s2 = -1 if i2 % 2 else 1
            i3 = f3.index()
            s3 = -1 if i3 % 2 else 1
            i1 = f1.edge().index()
            i2 = f2.edge().index()
            i3 = f3.edge().index()
            proj[i1] = -s1 * (s2 * proj[i2] + s3 * proj[i3])
            for j in range(n):
                assert proj[j, i1] == 0

        return (t, proj)

    def _intersection_matrix(self, t, spanning_set):
        r"""
        Given a spanning tree, compute the associated intersection matrix.

        It can be used to compute holonomies. (we can be off by a - sign)
        """
        d = len(spanning_set)
        h = spanning_set[0].positive()
        all_edges = {e.positive() for e in spanning_set}
        all_edges.update([e.negative() for e in spanning_set])
        contour = []
        contour_inv = {}  # half edge -> position in contour
        while h not in contour_inv:
            contour_inv[h] = len(contour)
            contour.append(h)
            h = self._flat_triangulation().nextAtVertex(-h)
            while h not in all_edges:
                h = self._flat_triangulation().nextAtVertex(h)

        assert len(contour) == len(all_edges)

        # two curves intersect when their relative position in the contour
        # are x y x y or y x y x
        Omega = matrix(ZZ, d)
        for i in range(len(spanning_set)):
            ei = spanning_set[i]
            pi1 = contour_inv[ei.positive()]
            pi2 = contour_inv[ei.negative()]
            if pi1 > pi2:
                si = -1
                pi1, pi2 = pi2, pi1
            else:
                si = 1
            for j in range(i + 1, len(spanning_set)):
                ej = spanning_set[j]
                pj1 = contour_inv[ej.positive()]
                pj2 = contour_inv[ej.negative()]
                if pj1 > pj2:
                    sj = -1
                    pj1, pj2 = pj2, pj1
                else:
                    sj = 1

                # pj1 pj2 pi1 pi2: pj2 < pi1
                # pi1 pi2 pj1 pj2: pi2 < pj1
                # pi1 pj1 pj2 pi2: pi1 < pj1 and pj2 < pi2
                # pj1 pi1 pi2 pj2: pj1 < pi1 and pi2 < pj2
                if (
                    (pj2 < pi1)
                    or (pi2 < pj1)
                    or (pj1 > pi1 and pj2 < pi2)
                    or (pj1 < pi1 and pj2 > pi2)
                ):
                    # no intersection
                    continue

                if pi1 < pj1 < pi2:
                    # one sign
                    Omega[i, j] = si * sj
                else:
                    # other sign
                    assert pi1 < pj2 < pi2, (pi1, pi2, pj1, pj2)
                    Omega[i, j] = -si * sj
                Omega[j, i] = -Omega[i, j]
        return Omega

    def boundaries(self):
        r"""
        Return the list of boundaries (ie sum of edges around a triangular face).

        These are elements of H_1(S, Sigma; Z). The entries of the returned
        vector correspond to the edges of the :meth:`_flat_triangulation`.

        TESTS::

            sage: from flatsurf import polygons, similarity_surfaces
            sage: from flatsurf import GL2ROrbitClosure  # optional: pyflatsurf

            sage: from itertools import product
            sage: for a in range(1,5):  # long time (1s), optional: pyflatsurf
            ....:     for b in range(a, 5):
            ....:         for c in range(b, 5):
            ....:             if gcd([a, b, c]) != 1 or (a,b,c) == (1,1,2):
            ....:                 continue
            ....:             T = polygons.triangle(a, b, c)
            ....:             S = similarity_surfaces.billiard(T)
            ....:             S = S.minimal_cover(cover_type="translation")
            ....:             O = GL2ROrbitClosure(S)
            ....:             for b in O.boundaries():
            ....:                 assert (O.proj * b).is_zero()
        """
        n = self._flat_triangulation().size()
        V = FreeModule(ZZ, n)
        B = []
        for f1, f2, f3 in self._flat_triangulation().faces():
            i1 = f1.index()
            s1 = -1 if i1 % 2 else 1
            i2 = f2.index()
            s2 = -1 if i2 % 2 else 1
            i3 = f3.index()
            s3 = -1 if i3 % 2 else 1
            i1 = f1.edge().index()
            i2 = f2.edge().index()
            i3 = f3.edge().index()
            v = [0] * n
            v[i1] = 1
            v[i2] = s1 * s2
            v[i3] = s1 * s3
            B.append(V(v))
            B[-1].set_immutable()

        return B

    def decomposition(self, v, limit=-1):
        import warnings
        warnings.warn("decomposition() has been deprecated and will be removed in a future version of sage-flatsurf; use ._decomposition() on the translation surface instead")

        return self._surface._decomposition(v, limit=limit)

    def decompositions(self, bound, limit=-1, bfs=False):
        import warnings
        warnings.warn("decompositions() has been deprecated and will be removed in a future version of sage-flatsurf; use ._decomposition() and .slopes() on the translation surface instead")

        for slope in self._surface.slopes(bound=bound, algorithm="byLength" if bfs else "byAngle"):
            yield self._surface._decomposition(slope, limit=limit)

    def decompositions_depth_first(self, bound, limit=-1):
        import warnings
        warnings.warn("decompositions_depth_first() has been deprecated and will be removed in a future version of sage-flatsurf; use ._decomposition() and .slopes() on the translation surface instead")

        return self.decompositions(bound, bfs=False, limit=limit)

    def decompositions_breadth_first(self, bound, limit=-1):
        import warnings
        warnings.warn("decompositions_breadth_first() has been deprecated and will be removed in a future version of sage-flatsurf; use ._decomposition() and .slopes() on the translation surface instead")

        return self.decompositions(bound, bfs=True, limit=limit)

    def is_teichmueller_curve(self, bound, limit=-1):
        r"""
        Return ``False`` when the program can find a direction which is either completely
        periodic with incomensurable moduli or a direction with at least one cylinder
        and at least one minimal component.

        EXAMPLES::

            sage: from flatsurf import polygons, similarity_surfaces
            sage: from flatsurf import GL2ROrbitClosure  # optional: pyflatsurf
            sage: for a in range(1,6):  # long time (8s), optional: pyflatsurf
            ....:     for b in range(a,6):
            ....:         for c in range(b,6):
            ....:             if a + b + c > 7 or gcd([a,b,c]) != 1:
            ....:                 continue
            ....:             T = polygons.triangle(a, b, c)
            ....:             S = similarity_surfaces.billiard(T)
            ....:             S = S.minimal_cover(cover_type="translation")
            ....:             O = GL2ROrbitClosure(S)
            ....:             if O.is_teichmueller_curve(3, 50) != False:
            ....:                 print(a,b,c)
            1 1 1
            1 1 2
            1 1 4
            1 2 2
            1 2 3
            1 3 3
        """
        if self._surface.base_ring() in [ZZ, QQ]:
            # square tiled surface
            return True

        if self.dimension() > 2:
            # too large orbit closure
            return False

        k = self.field_of_definition()
        if k in [ZZ, QQ]:
            # square tiled
            return True

        nv = len(self._flat_triangulation().vertices())
        ne = len(self._flat_triangulation().edges())
        nf = len(self._flat_triangulation().faces())
        genus = (ne - nv - nf) // 2 + 1
        if k.degree() > genus or not k.is_totally_real():
            return False

        for slope in self._surface.slopes(bound=bound, algorithm="byAngle"):
            decomposition = self._surface._decomposition(slope, limit=limit)
            if (
                decomposition.parabolic() == False
            ):  # we are comparing to a boost tribool so this cannot be replaced by "is False"  # noqa
                return False

        return Unknown

    def cylinder_circumference(self, component, A, sc_index, proj):
        r"""
        Return the circumference of the cylinder ``component`` in the homology
        of the underlying surface.

        INPUT:

        - ``component`` -- a cylinder

        - ``A``, ``sc_index``, ``proj`` -- the output of
          ``flow_decomposition_kontsevich_zorich_cocycle``

        EXAMPLES::

            sage: from flatsurf import translation_surfaces
            sage: from flatsurf import GL2ROrbitClosure  # optional: pyflatsurf

            sage: S = translation_surfaces.veech_double_n_gon(5)
            sage: O = GL2ROrbitClosure(S)  # optional: pyflatsurf
            sage: dec = next(iter(S._decomposition(slope) for slope in S.slopes(bound=1)))  # optional: pyflatsurf
            sage: c0, c1 = dec.components() # optional: pyflatsurf
            sage: kz = O.flow_decomposition_kontsevich_zorich_cocycle(dec) # optional: pyflatsurf
            sage: O.cylinder_circumference(c0, *kz) # optional: pyflatsurf
            (1, 1, 1, -1)
            sage: O.cylinder_circumference(c1, *kz) # optional: pyflatsurf
            (0, 0, 1, 0)

        """
        if (
            component.cylinder() != True
        ):  # we are comparing to a boost tribool so this cannot be replaced by "is not True"  # noqa
            raise ValueError

        perimeters = list(component.perimeter())
        per = perimeters[0]
        assert not per.vertical()
        sc = per.saddleConnection()
        i = sc_index[sc]
        if i < 0:
            s = -1
            i = -i - 1
        else:
            s = 1
        v = s * proj.column(i)
        circumference = -A.solve_right(v)

        # check
        hol = self.holonomy_dual(circumference)
        holbis = self._vector_space_conversion().section(component.circumferenceHolonomy())
        assert hol == holbis, (hol, holbis)

        return circumference

    def cylinder_deformation_subspace(self, decomposition):
        r"""
        Return a basis of the subspace included in the tangent space to the
        GL(2,R)-orbit closure computed from the flow decomposition
        ``decomposition``.

        From A. Wright Cylinder Deformation Theorem.
        """

        module_fractions = self.cylinder_modules(decomposition)
        circumferences = self.cylinder_circumferences(decomposition)

        return list(self._tangent_space.cylinder_deformation_subspace(module_fractions, circumferences))

    def _flow_decomposition_spanning_tree(self, decomposition, sc_index, sc_comp):
        r"""
        Helper for :meth:`flow_decomposition_kontsevich_zorich_cocycle`.

        The method is similar to `_spanning_tree` but adapted to the basis used
        in the flow decomposition ``decomposition``. It returns  a pair ``(tree,
        proj)`` where ``tree`` is a tree encoded in a dictionary and ``proj`` is a
        projection matrix.

        INPUT:

        - ``decomposition`` -- a flow decomposition

        - ``sc_index`` -- a dictionary whose keys are the saddle connections on the
          boundary of ``decomposition`` and the corresponding values are the indices
          used in the matrix

        - ``sc_comp`` -- a dictionary whose keys are the saddle connections on the
          boundary of ``decomposition`` and the corresponding values are the indices
          of the components of ``decomposition``
        """
        components = list(decomposition.components())

        n = len(sc_index)
        assert n % 2 == 0
        n //= 2

        for p in components[0].perimeter():
            break
        t = {0: None}  # face -> half edge to take to go to the root
        todo = [0]
        edges = []  # store edges in topological order to perform Gauss reduction
        while todo:
            i = todo.pop()
            c = components[i]
            for sc in c.perimeter():
                sc1 = -sc.saddleConnection()
                j = sc_comp[sc1]
                if j not in t:
                    t[j] = sc1
                    todo.append(j)
                    edges.append(sc1)

        # gauss reduction
        spanning_set = set(range(n))
        proj = identity_matrix(ZZ, n)
        edges.reverse()
        for sc1 in edges:
            i1 = sc_index[sc1]
            if i1 < 0:
                s1 = -1
                i1 = -i1 - 1
            else:
                s1 = 1
            comp = components[sc_comp[sc1]]
            proj[i1] = 0
            for p in comp.perimeter():
                sc = p.saddleConnection()
                if sc == sc1:
                    continue
                j = sc_index[sc]
                if j < 0:
                    s = -1
                    j = -j - 1
                else:
                    s = 1
                proj[i1] = -s1 * s * proj[j]

            spanning_set.remove(i1)
            for j in range(n):
                assert proj[j, i1] == 0

        return (t, sorted(spanning_set), proj)

    def flow_decomposition_kontsevich_zorich_cocycle(self, decomposition):
        r"""
        Base change from the homology of ``decomposition`` to the underlying surface.

        Return a triple ``A``, ``sc_index``, ``proj`` where

        - ``A`` is a `d \times d` matrix where `d` is the dimension of the ambient stratum
          (ie the dimension of the homology relative to the singularities)

        - ``sc_index`` is a dictionary whose keys are saddle connections appearing
          in the various components of this decomposition and the corresponding value
          is an integral index

        - ``proj`` is a projection matrix from vectors expressed as a sum of saddle
          connections appearing in this component to the chosen representative of
          cohomology with respect to this component

        EXAMPLES::

            sage: from flatsurf import translation_surfaces
            sage: from flatsurf import GL2ROrbitClosure  # optional: pyflatsurf

            sage: S = translation_surfaces.square_torus()
            sage: O = GL2ROrbitClosure(S)  # optional: pyflatsurf
            sage: for slope in S.slopes(bound=3, algorithm="byAngle"):  # optional: pyflatsurf
            ....:     dec = S._decomposition(slope)
            ....:     kz = O.flow_decomposition_kontsevich_zorich_cocycle(dec) # optional: pyflatsurf
            ....:     print(kz[0])
            [ 0  1]
            [-1 -1]
            [ 0  1]
            [-1 -2]
            [-1 -1]
            [ 1  0]
            [-1 -1]
            [ 2  1]
            [-2 -1]
            [ 3  1]
            [-1 -1]
            [ 3  2]
            [1 0]
            [0 1]
            [ 1  0]
            [-1  1]

        """
        sc_pos = (
            []
        )  # list of positive boundary saddle connections (store only one orientation for each)
        sc_index = (
            {}
        )  # inverse of sc_pos (and also reverse orientation with negative index)
        sc_comp = {}
        n_saddles = 0
        components = list(decomposition.components())
        n_components = len(components)
        for i, comp in enumerate(components):
            for p in comp.perimeter():
                sc = p.saddleConnection()
                sc_comp[sc] = i
                if sc not in sc_index:
                    sc_index[sc] = n_saddles
                    sc_pos.append(sc)
                    sc_index[-sc] = -n_saddles - 1
                    n_saddles += 1

        t, spanning_set, proj = self._flow_decomposition_spanning_tree(
            decomposition, sc_index, sc_comp
        )
        assert proj.rank() == len(spanning_set) == n_saddles - n_components + 1
        proj = proj.transpose()
        proj = matrix(ZZ, [r for r in proj.rows() if not r.is_zero()])
        assert proj.nrows() == self.proj.nrows()

        # Write the base change V^*(T') -> V^*(T) relative to our bases
        A = matrix(ZZ, self.d)
        for i, sc in enumerate(spanning_set):
            sc = sc_pos[sc]
            c = sc.chain()
            for edge in self._flat_triangulation().edges():
                A[i] += ZZ(str(c[edge])) * self.proj.column(edge.index())
        assert A.det().is_unit()
        return A, sc_index, proj

    def cylinder_circumferences(self, decomposition):
        kz = self.flow_decomposition_kontsevich_zorich_cocycle(decomposition)

        vcyls = []

        for component in decomposition.components():
            if (
                component.cylinder() == False
            ):  # we are comparing to a boost tribool so this cannot be replaced by "is False"  # noqa
                continue
            elif (
                component.cylinder() == True
            ):  # we are comparing to a boost tribool so this cannot be replaced with "is True"  # noqa
                vcyls.append(self.cylinder_circumference(component, *kz))

            else:
                return []

        return vcyls

    def cylinder_module(self, cylinder):
        section  = self._ring_conversion().section
        width = section(cylinder.width())
        height = section(cylinder.vertical().project(cylinder.circumferenceHolonomy()))

        return width, height

    def cylinder_modules(self, decomposition):
        modules = []

        for component in decomposition.components():
            if (
                component.cylinder() == False
            ):  # we are comparing to a boost tribool so this cannot be replaced by "is False"  # noqa
                continue
            elif (
                component.cylinder() == True
            ):  # we are comparing to a boost tribool so this cannot be replaced with "is True"  # noqa
                modules.append(self.cylinder_module(component))
            else:
                return []

        return modules

    def update_tangent_space_from_flow_decomposition(self, decomposition):
        r"""
        Update the current tangent space by using the cylinder deformation vectors from ``decomposition``.

        EXAMPLES::

            sage: from flatsurf import polygons, similarity_surfaces
            sage: from flatsurf import GL2ROrbitClosure  # optional: pyflatsurf

            sage: T = polygons.triangle(1, 2, 5)
            sage: S = similarity_surfaces.billiard(T)
            sage: S = S.minimal_cover(cover_type="translation")
            sage: O = GL2ROrbitClosure(S)  # optional: pyflatsurf
            sage: for slope in S.slopes(bound=1):  # long time (1s), optional: pyflatsurf
            ....:     d = S._decomposition(slope)
            ....:     O.update_tangent_space_from_flow_decomposition(d)
            sage: assert O.dimension() == 2  # long time (above), optional: pyflatsurf

        TESTS:

        A regression test for  https://github.com/flatsurf/sage-flatsurf/pull/69::

            sage: from itertools import islice
            sage: from flatsurf import polygons, similarity_surfaces
            sage: from flatsurf import GL2ROrbitClosure  # optional: pyflatsurf

            sage: for (a,b,c,dim) in [(3,2,2,7), (4,2,1,8), (4,4,3,11), (5,3,3,11), (5,4,4,13), (5,5,3,13)]: # long time, optional: pyflatsurf
            ....:     T = polygons.triangle(a, b, c)
            ....:     S = similarity_surfaces.billiard(T)
            ....:     S = S.minimal_cover(cover_type="translation")
            ....:     O = GL2ROrbitClosure(S)  # optional: pyflatsurf
            ....:     nsteps = 0
            ....:     for slope in islice(S.slopes(bound=3, algorithm="byAngle"), 10):
            ....:         d = S._decomposition(slope, limit=100)
            ....:         O.update_tangent_space_from_flow_decomposition(d)
            ....:         nsteps += 1
            ....:         if O.dimension() == dim:
            ....:             break
            ....:     print("(%d, %d, %d): %d" % (a, b, c, nsteps))
            (3, 2, 2): 5
            (4, 2, 1): 4
            (4, 4, 3): 4
            (5, 3, 3): 4
            (5, 4, 4): 7
            (5, 5, 3): 4
        """
        circumferences = self.cylinder_circumferences(decomposition)
        modules = self.cylinder_modules(decomposition)

        self._tangent_space.update_from_flow_decomposition(circumferences, modules)

    def update_tangent_space_from_vector(self, v):
        self._tangent_space.update_from_vector(v)

    def __eq__(self, other):
        r"""
        Return whether ``other`` was built starting from the same surface than
        this orbit closure.

        EXAMPLES::

            sage: from flatsurf import polygons, similarity_surfaces
            sage: from flatsurf import GL2ROrbitClosure  # optional: pyflatsurf

            sage: T = polygons.triangle(1, 2, 5)
            sage: S = similarity_surfaces.billiard(T)
            sage: S = S.minimal_cover(cover_type="translation")
            sage: GL2ROrbitClosure(S) == GL2ROrbitClosure(S) # optional: pyflatsurf
            True

        """
        return self._surface == other._surface

    def __ne__(self, other):
        r"""
        Return whether ``other`` was not built starting from the same surface
        than this orbit closure.

        EXAMPLES::

            sage: from flatsurf import polygons, similarity_surfaces
            sage: from flatsurf import GL2ROrbitClosure  # optional: pyflatsurf

            sage: T = polygons.triangle(1, 2, 5)
            sage: S = similarity_surfaces.billiard(T)
            sage: S = S.minimal_cover(cover_type="translation")
            sage: GL2ROrbitClosure(S) != GL2ROrbitClosure(S) # optional: pyflatsurf
            False

        """
        return not (self == other)

    def __hash__(self):
        r"""
        Return a hash value of this object compatible with equality operators.

        EXAMPLES::

            sage: from flatsurf import polygons, similarity_surfaces
            sage: from flatsurf import GL2ROrbitClosure  # optional: pyflatsurf

            sage: T = polygons.triangle(1, 2, 5)
            sage: S = similarity_surfaces.billiard(T)
            sage: S = S.minimal_cover(cover_type="translation")
            sage: O = GL2ROrbitClosure(S)  # optional: pyflatsurf
            sage: hash(O) == hash(O)  # optional: pyflatsurf
            True

        """
        return hash(self._surface)

    def __reduce__(self):
        r"""
        Return a serializable representation of this Orbit Closure.

        EXAMPLES::

            sage: from flatsurf import polygons, similarity_surfaces
            sage: from flatsurf import GL2ROrbitClosure  # optional: pyflatsurf

            sage: T = polygons.triangle(1, 2, 5)
            sage: S = similarity_surfaces.billiard(T)
            sage: S = S.minimal_cover(cover_type="translation")
            sage: O = GL2ROrbitClosure(S)  # optional: pyflatsurf
            sage: loads(dumps(O)) == O  # optional: pyflatsurf  # long time (6s, #123)
            True
        """
        return (
            GL2ROrbitClosure,
            (self._surface,),
        )


class LazyTangentSpace:
    def __init__(self, surface, ambient_dimension):
        self._surface_base_ring = surface.base_ring()
        self._ambient_dimension = ambient_dimension

        self._pending_for_dimension = []
        self._pending_for_basis = []

        # The tangent space we have constructed so far.
        # Can only be safely accessed after a call to _require_basis.
        # Note that we don't use Sage vector spaces because they are usually
        # way too slow (in particular we avoid calling .echelonize())
        self._basis = []

        # The tangent space vectors reduced modulo a prime ideal _p of the
        # number field containing its entries.
        # This is used to determine the dimension of the tangent space without
        # constructing the full matrix U and computing its rank.
        from sage.all import GF
        self._U_bar = matrix(GF(2), 0, ambient_dimension)
        self._primes = iter(self._create_primes())
        self._prime = None

    @cached_method
    def base_ring(self):
        # TODO: This doesn't really have anything to do with "vectors". We
        # should reimplement this in sage-flatsurf and drop the implementation
        # in pyflatsurf.
        from pyflatsurf.vector import Vectors
        return Vectors(self._surface_base_ring)._algebraic_ring()

    def _create_primes(self):
        from sage.all import next_prime

        p = 2**60

        while True:
            p = next_prime(p)

            yield ZZ.valuation(p).extensions(self.base_ring())[0]

    def _require_dimension(self):
        for item in self._pending_for_dimension:
            self._update_dimension(item)

        self._pending_for_dimension = []

    def _require_basis(self, require_dimension=True):
        if require_dimension:
            self._require_dimension()

        for item, row in self._pending_for_basis:
            self._update_basis(item, row)

        self._pending_for_basis = []

    def dimension(self):
        self._require_dimension()

        return self._U_bar.nrows()

    def basis(self):
        self._require_basis()

        return self._basis[:]

    def _update_dimension(self, item):
        if isinstance(item, tuple):
            increases = self._update_dimension_from_decomposition(*item)
        else:
            increases = self._update_dimension_from_vector(item)

        self._pending_for_basis.append((item, increases))

    def _update_dimension_from_decomposition(self, circumferences, module_fractions) -> list[int]:
        increases = []

        for i, v in enumerate(self.cylinder_deformation_subspace(circumferences, module_fractions, reduced=True)):
            if self._update_dimension_from_reduced_vector(v):
                increases.append(i)

        return increases

    def _reduce_vector(self, v):
        assert v.base_ring() is self.base_ring(), f"Expected vector over {self.base_ring()} but found vector over {v.base_ring()}"

        while True:
            p = self._require_p()

            try:
                return v.apply_map(phi=p.reduce, R=p.residue_field())
            except ValueError:
                self._require_p(force_next=True)

    def _decomposition(self, v):
        # TODO: Fix upstream in pyflatsurf
        if v.base_ring() is QQ:
            return [(QQ.one(), v)]

        # TODO: This doesn't really have anything to do with "vectors". We
        # should reimplement this in sage-flatsurf and drop the implementation
        # in pyflatsurf.
        from pyflatsurf.vector import Vectors
        return Vectors(self._surface_base_ring).decomposition(v)

    def _update_dimension_from_vector(self, v) -> list[int]:
        assert v.base_ring() is self._surface_base_ring

        decompositions = []

        # Rewrite v as vectors over base_ring(), i.e., the underlying SageMath
        # number field. (This extracts the different components of a vector
        # over exact-real. Otherwise, this is just a simple cast between an
        # e-antic number field and a SageMath number field.)
        for i, (_, w) in enumerate(self._decomposition(v)):
            assert all(x.parent() is self.base_ring() for x in w)

            w = vector(self.base_ring(), w)
            if self._update_dimension_from_reduced_vector(self._reduce_vector(w)):
                decompositions.append(i)

        return decompositions

    def _update_dimension_from_reduced_vector(self, v) -> bool:
        if self._U_bar.nrows() == self._ambient_dimension:
            return False

        U_bar = matrix(self._U_bar.base_ring(), self._U_bar.nrows() + 1, self._U_bar.ncols(), self._U_bar.rows() + [v])

        if U_bar.rank() != U_bar.nrows():
            return False

        self._U_bar = U_bar
        return True

    def _update_basis(self, item, rows: list[int]):
        if isinstance(item, tuple):
            self._update_basis_from_decomposition(*item, rows)
        else:
            self._update_basis_from_vector(item, rows)

    def _update_basis_from_decomposition(self, circumferences, module_fractions, rows: list[int]):
        for v in self.cylinder_deformation_subspace(circumferences, module_fractions, rows=rows):
            self._basis.append(v)

    def _update_basis_from_vector(self, v, rows: list[int]):
        # Rewrite v as vectors over base_ring(), i.e., the underlying SageMath
        # number field. (This extracts the different components of a vector
        # over exact-real. Otherwise, this is just a simple cast between an
        # e-antic number field and a SageMath number field.)
        for i, (_, w) in enumerate(self._decomposition(v)):
            if i not in rows:
                continue

            assert len(self._basis) < self._U_bar.nrows()

            assert all(x.parent() is self.base_ring() for x in w)
            w = vector(self.base_ring(), w)
            self._basis.append(w)

    def _require_p(self, force_next=None):
        if force_next or self._prime is None:
            self._require_basis(require_dimension=False)
            assert len(self._basis) == self._U_bar.nrows()
            while True:
                self._prime = next(self._primes)

                try:
                    reduced_basis = [v.apply_map(phi=self._prime.reduce(), R=self._prime.residue_field()) for v in self._basis]
                except ValueError:
                    continue

                self._U_bar = matrix(self._prime.residue_field(), self._U_bar.nrows(), self._U_bar.ncols(), reduced_basis)
                break
        return self._prime

    def update_from_flow_decomposition(self, circumferences, modules):
        self._pending_for_dimension.append((circumferences, modules))

    def update_from_vector(self, v):
        if len(v) != self._ambient_dimension:
            raise TypeError(f"Expected vector of length {self._ambient_dimension} but found vector of length {len(v)}")

        if v.base_ring() is not self._surface_base_ring:
            raise NotImplementedError(f"Expected vector over {self._surface_base_ring} but found vector over {v.base_ring()}")

        self._pending_for_dimension.append(v)

    @staticmethod
    def _cylinder_deformation_subspace_eliminate_denominators(fractions):
        r"""
        Given a list of ``fractions``, pairs of numerators `n_i` and
        denominators `d_i`, return a list of fractions `c n_i/d_i` scaled
        uniformly such that the value can be represented in the underlying
        ring.
        """
        fractions = list(fractions)
        try:
            return [x.parent()(x / y) for x, y in fractions]
        except (ValueError, ArithmeticError, NotImplementedError):
            denominators = {denominator for numerator, denominator in fractions}
            return [
                numerator * prod([d for d in denominators if denominator != d])
                for (numerator, denominator) in fractions
            ]

    def _cylinder_deformation_subspace_rational_vector(self, x):
        r"""
        Return the rational coefficients of `x` over its implicit basis,
        e.g., if `x` is in a number field K, return the coefficients of x
        in `K` as a vector space over the rationals.
        """
        if x.parent() in [ZZ, QQ]:
            ret = [QQ(x)]
        elif hasattr(x, "vector"):
            ret = x.vector()
        elif hasattr(x, "renf_elem"):
            ret = x.parent().number_field(x).vector()
        elif hasattr(x, "_backend"):
            # TODO: This should probably live elsewhere.
            from flatsurf.geometry.pyflatsurf.conversion import RingConversion
            section = RingConversion.to_pyflatsurf(self.base_ring()).section

            from itertools import chain
            ret = list(
                chain(
                    *[
                        self._cylinder_deformation_subspace_rational_vector(
                            section(c)
                        )
                        for c in x._backend.coefficients()
                    ]
                )
            )
        else:
            raise NotImplementedError(
                "cannot turn {}, i.e., a {}, into a rational vector yet".format(
                    x, type(x)
                )
            )

        assert all(y in QQ for y in ret)
        return ret

    def _cylinder_deformation_subspace_unify_parent(self, modules):
        if hasattr(modules[0], "_backend"):
            # Make sure all modules live in the same K-Module so that .coefficients() below produces coefficient lists of the same length.
            from functools import reduce

            parent = reduce(
                lambda m, n: m.span(m, n),
                [module._backend.module() for module in modules],
                modules[0]._backend.module(),
            )
            modules = [
                module.parent()(module._backend.promote(parent)) for module in modules
            ]

        assert all(module.parent() is modules[0].parent() for module in modules)
        return modules

    def _cylinder_deformation_subspace_reduce(self, relations, circumferences, decomposed_denominators):
        assert all(denominator.parent() is self.base_ring() for denominators in decomposed_denominators for denominator in denominators)

        while True:
            prime = self._require_p()
            k = prime.residue_field()

            reduced_relations = [relation.change_ring(k) for relation in relations]
            try:
                reduced_circumferences = [circumference.change_ring(k) for circumference in circumferences]
            except ZeroDivisionError:
                self._require_p(force_next=True)
                continue

            try:
                reduced_denominators = [[prime.reduce(d) for d in ds] for ds in decomposed_denominators]
            except ValueError:
                self._require_p(force_next=True)
                continue

            return reduced_relations, reduced_circumferences, reduced_denominators


    def cylinder_deformation_subspace(self, circumferences, module_fractions, reduced=False, rows=None):
        assert len(circumferences) == len(module_fractions)

        if not module_fractions:
            return []

        modules = self._cylinder_deformation_subspace_eliminate_denominators(module_fractions)
        modules = self._cylinder_deformation_subspace_unify_parent(modules)

        M = matrix([self._cylinder_deformation_subspace_rational_vector(module) for module in modules])
        assert M.base_ring() is QQ
        relations = self._left_kernel_matrix(M)
        assert len(circumferences) == len(module_fractions) == relations.ncols()
        relations = self._right_kernel_matrix(relations).rows()

        # TODO: This code is horrible. Find a better way to do this.
        decomposed_denominators = [dict(self._decomposition(vector([denominator]))) for (_, denominator) in module_fractions]
        transcendentals = set(sum((list(d.keys()) for d in decomposed_denominators), []))
        decomposed_denominators = [[dd.get(transcendental, [self.base_ring().zero()])[0] for dd in decomposed_denominators] for transcendental in transcendentals]

        if reduced:
            relations, circumferences, decomposed_denominators = self._cylinder_deformation_subspace_reduce(relations, circumferences, decomposed_denominators)

        row = 0
        for relation in relations:
            for denominators in decomposed_denominators:
                assert len(relation) == len(circumferences) == len(denominators)

                skip = rows is not None and row not in rows
                row += 1

                if skip:
                    continue

                yield sum(
                    t * circumference * denominator
                    for (t, circumference, denominator) in zip(relation, circumferences, denominators)
                )

    @staticmethod
    def _right_kernel_matrix(M):
        r"""
        Compute the right kernel of the rational matrix `M`.

        See https://github.com/flatsurf/sage-flatsurf/issues/100.
        """
        M = M._clear_denom()[0]

        rows = M.nrows()
        columns = M.ncols()

        # The backends cannot handle these trivial cases
        if M.ncols() == 0:
            return M.new_matrix(nrows=0, ncols=M.ncols())
        if M.nrows() == 0:
            return M.matrix_space(M.ncols(), M.ncols()).identity_matrix()

        height = M.height()

        if height >= 2**256:
            algorithm = "flint"
        elif columns >= 64 and rows >= 64:
            algorithm = "padic"
        elif rows * columns <= 32:
            algorithm = "flint"
        else:
            algorithm = "pari"

        if algorithm == "pari":
            ker = M.__pari__().matker().mattranspose().sage()
        elif algorithm == "flint":
            ker = M._rational_kernel_flint().transpose()
        else:
            ker = M._rational_kernel_iml().transpose()

        if ker.nrows() == 0 and ker.ncols() != M.ncols():
            ker = ker.new_matrix(nrows=0, ncols=M.ncols())

        return ker

    @staticmethod
    def _left_kernel_matrix(M):
        r"""
        Compute the left kernel of the rational matrix `M`.

        See https://github.com/flatsurf/sage-flatsurf/issues/100.
        """
        return LazyTangentSpace._right_kernel_matrix(M.transpose())
